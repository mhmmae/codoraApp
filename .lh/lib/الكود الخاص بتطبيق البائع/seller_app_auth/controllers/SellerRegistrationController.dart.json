{
    "sourceFile": "lib/Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø®Ø§Øµ Ø¨ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø¨Ø§Ø¦Ø¹/seller_app_auth/controllers/SellerRegistrationController.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1752491126687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752491133502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,2048 @@\n+import 'dart:io';\n+import 'dart:async';\n+import 'package:cloud_firestore/cloud_firestore.dart';\n+import 'package:codora/%D8%A7%D9%84%D9%83%D9%88%D8%AF%20%D8%A7%D9%84%D8%AE%D8%A7%D8%B5%20%D8%A8%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%20%D8%A7%D9%84%D8%A8%D8%A7%D8%A6%D8%B9/seller_app_auth/controllers/seller_auth_controller.dart';\n+import 'package:firebase_auth/firebase_auth.dart';\n+import 'package:firebase_storage/firebase_storage.dart';\n+import 'package:firebase_messaging/firebase_messaging.dart';\n+import 'package:firebase_core/firebase_core.dart';\n+import 'package:flutter/material.dart';\n+import 'package:geolocator/geolocator.dart';\n+import 'package:get/get.dart';\n+import 'package:get_storage/get_storage.dart';\n+import 'package:google_maps_flutter/google_maps_flutter.dart';\n+import 'package:image_picker/image_picker.dart';\n+import 'package:intl/intl.dart'; // For DateFormat\n+import 'package:geocoding/geocoding.dart' as geo;\n+\n+import '../../../XXX/xxx_firebase.dart';\n+import '../../../Model/SellerModel.dart';\n+import '../../ui/seller_main_screen.dart';\n+import '../ui/OtpVerificationScreen.dart';\n+import '../ui/LocationPickerScreen.dart';\n+\n+class SellerRegistrationController extends GetxController {\n+  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n+  RxDouble currentPositionAccuracy = 0.0.obs;\n+\n+  // --- Firebase Instances ---\n+  final FirebaseAuth _auth = FirebaseAuth.instance;\n+  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n+  final FirebaseStorage _storage = FirebaseStorage.instance;\n+  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n+  final RxString verificationId = ''.obs; // To store Firebase's verification ID\n+\n+  // iOS-specific Firebase Storage handler\n+  late IOSFirebaseStorageHandler _iosStorageHandler;\n+\n+  // ==========================================================================\n+  // ==========================================================================\n+  // ==========================================================================\n+\n+  // Ù„Ø¥Ø¶Ø§ÙØ© Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹\n+  String? _sellerTypeFromAuth; // Ø³ÙŠØªÙ… Ø¬Ù„Ø¨ Ù‡Ø°Ø§ Ù…Ù† SellerAuthController\n+\n+  final Rxn<int> resendToken = Rxn<int>(null); // For resending OTP\n+  final TextEditingController otpController = TextEditingController();\n+  final RxBool isOtpSending = false.obs; // Loading state for OTP sending\n+  final RxBool isOtpVerifying = false.obs; // Loading state for OTP verification\n+  Map<String, dynamic>? _tempSellerDataForSubmission;\n+  File? _tempSellerProfileImageFile;\n+  File? _tempShopFrontImageFile;\n+\n+  // --- Text Editing Controllers ---\n+  final TextEditingController sellerNameController = TextEditingController();\n+  final TextEditingController shopNameController = TextEditingController();\n+  final TextEditingController shopPhoneNumberController =\n+      TextEditingController();\n+  final TextEditingController shopDescriptionController =\n+      TextEditingController();\n+  // Add more controllers for other text fields like commercial reg no., etc.\n+\n+  // --- Image Pickers ---\n+  final ImagePicker _picker = ImagePicker();\n+  final Rxn<File> sellerProfileImageFile = Rxn<File>(null);\n+  final Rxn<File> shopFrontImageFile = Rxn<File>(null);\n+\n+  // --- Location ---\n+  final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n+  final RxString shopAddressText = ''.obs;\n+  GoogleMapController? mapController;\n+\n+  // --- Working Hours ---\n+  final List<String> dayKeys = [\n+    \"sunday_en\",\n+    \"monday_en\",\n+    \"tuesday_en\",\n+    \"wednesday_en\",\n+    \"thursday_en\",\n+    \"friday_en\",\n+    \"saturday_en\",\n+  ];\n+  final RxnString expandedDayPanel = RxnString(null); // For ExpansionPanelList\n+\n+  final RxMap<String, Map<String, dynamic>> workingHours =\n+      <String, Map<String, dynamic>>{\n+        \"sunday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø£Ø­Ø¯\",\n+        },\n+        \"monday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø§Ø«Ù†ÙŠÙ†\",\n+        },\n+        \"tuesday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡\",\n+        },\n+        \"wednesday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡\",\n+        },\n+        \"thursday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø®Ù…ÙŠØ³\",\n+        },\n+        \"friday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø¬Ù…Ø¹Ø©\",\n+        },\n+        \"saturday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"Ø§Ù„Ø³Ø¨Øª\",\n+        },\n+      }.obs;\n+  final RxnString _lastAppliedOpensAt = RxnString(null);\n+  final RxnString _lastAppliedClosesAt = RxnString(null);\n+  // --- Main Categories ---\n+  // Ù‚Ø§Ø¦Ù…Ø© Ø´Ø§Ù…Ù„Ø© Ø¨Ø¬Ù…ÙŠØ¹ ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ§Ø¬Ø± Ø§Ù„Ù…Ù…ÙƒÙ†Ø©\n+  final List<String> shopCategories = [\n+    \"Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ§Øª ÙˆÙ…Ø¹Ø¯Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n+    \"Ù…Ù„Ø§Ø¨Ø³ ÙˆØ£Ø²ÙŠØ§Ø¡\",\n+    \"Ø£Ø­Ø°ÙŠØ© ÙˆØ­Ù‚Ø§Ø¦Ø¨\",\n+    \"Ø·Ø¹Ø§Ù… ÙˆÙ…Ø´Ø±ÙˆØ¨Ø§Øª\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª ØµØ­ÙŠØ© ÙˆØªØ¬Ù…ÙŠÙ„\",\n+    \"Ø£Ø¯ÙˆÙŠØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª Ø·Ø¨ÙŠØ©\",\n+    \"ÙƒØªØ¨ ÙˆÙ…ÙˆØ§Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠØ©\",\n+    \"Ø£Ù„Ø¹Ø§Ø¨ ÙˆØªØ±ÙÙŠÙ‡\",\n+    \"Ø±ÙŠØ§Ø¶Ø© ÙˆÙ„ÙŠØ§Ù‚Ø©\",\n+    \"Ø£Ø¯ÙˆØ§Øª Ù…Ù†Ø²Ù„ÙŠØ© ÙˆÙ…Ø·Ø¨Ø®\",\n+    \"Ø£Ø«Ø§Ø« ÙˆØ¯ÙŠÙƒÙˆØ±\",\n+    \"Ø­Ø¯Ø§Ø¦Ù‚ ÙˆÙ†Ø¨Ø§ØªØ§Øª\",\n+    \"Ø³ÙŠØ§Ø±Ø§Øª ÙˆÙ‚Ø·Ø¹ ØºÙŠØ§Ø±\",\n+    \"Ø£Ø¯ÙˆØ§Øª ÙˆØ¹Ø¯Ø¯ ÙŠØ¯ÙˆÙŠØ©\",\n+    \"Ù…ÙˆØ§Ø¯ Ø¨Ù†Ø§Ø¡ ÙˆØªØ´ÙŠÙŠØ¯\",\n+    \"Ù…Ø¬ÙˆÙ‡Ø±Ø§Øª ÙˆØ³Ø§Ø¹Ø§Øª\",\n+    \"Ù‡Ø¯Ø§ÙŠØ§ ÙˆØªØ­Ù\",\n+    \"Ø£Ø·ÙØ§Ù„ ÙˆÙ…ÙˆØ§Ù„ÙŠØ¯\",\n+    \"Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø£Ù„ÙŠÙØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª\",\n+    \"Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆØ¢Ù„Ø§Øª Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©\",\n+    \"Ø®Ø¯Ù…Ø§Øª Ù…Ù‡Ù†ÙŠØ©\",\n+    \"Ø®Ø¯Ù…Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n+    \"Ø®Ø¯Ù…Ø§Øª ØªÙˆØµÙŠÙ„\",\n+    \"Ø®Ø¯Ù…Ø§Øª ØªÙ†Ø¸ÙŠÙ\",\n+    \"Ø®Ø¯Ù…Ø§Øª ØµÙŠØ§Ù†Ø©\",\n+    \"Ù…ÙˆØ§Ø¯ ØºØ°Ø§Ø¦ÙŠØ© Ø¹Ø¶ÙˆÙŠØ©\",\n+    \"Ø­Ø±Ù ÙŠØ¯ÙˆÙŠØ© ÙˆÙÙ†ÙˆÙ†\",\n+    \"Ø£Ù‚Ù…Ø´Ø© ÙˆØ®ÙŠØ§Ø·Ø©\",\n+    \"Ø¹Ø·ÙˆØ± ÙˆÙ…ÙˆØ§Ø¯ ØªØ¬Ù…ÙŠÙ„\",\n+    \"Ø£Ø®Ø±Ù‰\",\n+  ];\n+\n+  // Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 6 ÙØ¦Ø§Øª)\n+  final RxList<String> selectedShopCategories = <String>[].obs;\n+  final int maxCategoriesAllowed = 6;\n+\n+  // --- Loading State ---\n+  final RxBool isLoading = false.obs;\n+\n+  @override\n+  void onInit() {\n+    super.onInit();\n+\n+    // Initialize iOS-specific storage handler\n+    if (Platform.isIOS) {\n+      _iosStorageHandler = IOSFirebaseStorageHandler(_storage);\n+    }\n+\n+    // Ø¬Ù„Ø¨ SellerAuthController ÙˆØ§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ sellerType\n+    try {\n+      final SellerAuthController authController =\n+          Get.find<SellerAuthController>();\n+      _sellerTypeFromAuth = authController.sellerType;\n+      if (_sellerTypeFromAuth != null) {\n+        debugPrint(\n+          \"SellerRegistrationController: ØªÙ… Ø¬Ù„Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù…Ù† AuthController: $_sellerTypeFromAuth\",\n+        );\n+      } else {\n+        debugPrint(\n+          \"SellerRegistrationController: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ sellerType ÙÙŠ AuthController. Ù‚Ø¯ ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø¹ÙˆØ¯Ø© ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹.\",\n+        );\n+        // ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù„ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø°Ø§ ÙƒØ§Ù† sellerType Ø¶Ø±ÙˆØ±ÙŠÙ‹Ø§ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† null\n+        // Ù…Ø«Ø§Ù„: Get.offAll(() => SellerTypeSelectionScreen()); Ø£Ùˆ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£\n+      }\n+    } catch (e) {\n+      debugPrint(\n+        \"SellerRegistrationController: Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ SellerAuthController Ø£Ùˆ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ sellerType: $e\",\n+      );\n+      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ø±Ø¨Ù…Ø§ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø©\n+    }\n+  }\n+\n+  @override\n+  void onClose() {\n+    sellerNameController.dispose();\n+    shopNameController.dispose();\n+    shopPhoneNumberController.dispose();\n+    shopDescriptionController.dispose();\n+    mapController?.dispose();\n+    otpController.dispose();\n+    super.onClose();\n+  }\n+\n+  void removeImage({required bool isProfileImage}) {\n+    if (isProfileImage) {\n+      sellerProfileImageFile.value = null;\n+    } else {\n+      shopFrontImageFile.value = null;\n+    }\n+    update(); // For GetBuilder if used, or just rely on Obx for reactive updates\n+  }\n+\n+  Future<void> initiatePhoneVerificationAndCollectData() async {\n+    debugPrint(\"ğŸš€ initiatePhoneVerificationAndCollectData called\");\n+    debugPrint(\"Form validation starting...\");\n+\n+    if (!formKey.currentState!.validate()) {\n+      debugPrint(\"âŒ Form validation failed\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"âœ… Form validation passed\");\n+\n+    // --- Add all your previous validations ---\n+    debugPrint(\"Checking profile image...\");\n+    if (sellerProfileImageFile.value == null) {\n+      debugPrint(\"âŒ No profile image selected\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ø´Ø®ØµÙŠØ©.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"âœ… Profile image validation passed\");\n+\n+    debugPrint(\"Checking shop front image...\");\n+    if (shopFrontImageFile.value == null) {\n+      debugPrint(\"âŒ No shop front image selected\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø­Ù„.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"âœ… Shop front image validation passed\");\n+\n+    debugPrint(\"Checking shop location...\");\n+    if (shopLocation.value == null) {\n+      debugPrint(\"âŒ No shop location selected\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ù„.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"âœ… Shop location validation passed\");\n+\n+    debugPrint(\"Checking shop category...\");\n+    if (selectedShopCategories.isEmpty) {\n+      debugPrint(\"âŒ No shop categories selected\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙØ¦Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„Ù„Ù…ØªØ¬Ø±.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\n+      \"âœ… Shop categories validation passed: ${selectedShopCategories.length} categories selected\",\n+    );\n+\n+    // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† _sellerTypeFromAuth ÙØ§Ø±ØºÙ‹Ø§ Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© (Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¥Ù„Ø²Ø§Ù…ÙŠÙ‹Ø§)\n+    debugPrint(\"Checking seller type...\");\n+    if (_sellerTypeFromAuth == null || _sellerTypeFromAuth!.isEmpty) {\n+      debugPrint(\"âŒ No seller type selected\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¬ÙˆØ¹ ÙˆØ§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹.\",\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"âœ… Seller type validation passed: $_sellerTypeFromAuth\");\n+\n+    debugPrint(\"Checking working hours...\");\n+    bool workingHoursValid = true;\n+    String firstInvalidDay = \"\";\n+    workingHours.forEach((key, value) {\n+      if ((value['isOpen'] == true) &&\n+          (value['opensAt'] == null || value['closesAt'] == null)) {\n+        workingHoursValid = false;\n+        firstInvalidDay = value['name_ar'] as String;\n+        return;\n+      }\n+    });\n+    if (!workingHoursValid) {\n+      debugPrint(\"âŒ Working hours validation failed for day: $firstInvalidDay\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ÙØªØ­ ÙˆØ§Ù„Ø¥ØºÙ„Ø§Ù‚ Ù„Ù„ÙŠÙˆÙ… Ø§Ù„Ù…ÙØªÙˆØ­: $firstInvalidDay.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"âœ… Working hours validation passed\");\n+\n+    String rawPhoneNumber = shopPhoneNumberController.text.trim();\n+    rawPhoneNumber = rawPhoneNumber.replaceAll(RegExp(r'\\s+'), '');\n+    if (rawPhoneNumber.startsWith('0')) {\n+      rawPhoneNumber = rawPhoneNumber.substring(1);\n+    }\n+    const String countryCode = \"+964\";\n+    final String formattedPhoneNumber = \"$countryCode$rawPhoneNumber\";\n+    debugPrint(\"Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ: ${shopPhoneNumberController.text}\");\n+    debugPrint(\n+      \"Ø§Ù„Ø±Ù‚Ù… Ø¨Ø¹Ø¯ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„ØµÙØ± ÙˆØ¥Ø¶Ø§ÙØ© Ø±Ù…Ø² Ø§Ù„Ø¯ÙˆÙ„Ø©: $formattedPhoneNumber\",\n+    );\n+\n+    final RegExp iraqiPhoneNumberRegExp = RegExp(r'^\\+9647[3-9]\\d{8}$');\n+    debugPrint(\"Checking phone number validation: $formattedPhoneNumber\");\n+    if (!iraqiPhoneNumberRegExp.hasMatch(formattedPhoneNumber)) {\n+      debugPrint(\"Phone number validation failed for: $formattedPhoneNumber\");\n+      Get.snackbar(\n+        \"Ø±Ù‚Ù… Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­\",\n+        \"Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¹Ø±Ø§Ù‚ÙŠ ØµØ­ÙŠØ­.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"Phone number validation passed\");\n+\n+    // ---- Set loading states ----\n+    debugPrint(\"Setting loading states...\");\n+    isOtpSending.value = true;\n+    isLoading.value = true;\n+    update();\n+    debugPrint(\"Loading states set successfully\");\n+\n+    try {\n+      debugPrint(\"Preparing temp data for submission...\");\n+      _tempSellerProfileImageFile = sellerProfileImageFile.value;\n+      _tempShopFrontImageFile = shopFrontImageFile.value;\n+      _tempSellerDataForSubmission = {\n+        \"sellerName\": sellerNameController.text.trim(),\n+        \"shopName\": shopNameController.text.trim(),\n+        \"shopPhoneNumber\": shopPhoneNumberController.text.trim(),\n+        \"shopDescription\": shopDescriptionController.text.trim(),\n+        \"location\": GeoPoint(\n+          shopLocation.value!.latitude,\n+          shopLocation.value!.longitude,\n+        ),\n+        \"shopAddressText\": shopAddressText.value,\n+        \"shopCategories\": selectedShopCategories.toList(),\n+        \"workingHours\": Map<String, Map<String, dynamic>>.from(workingHours),\n+        \"streetAddress\": streetAddressController.text.trim(),\n+      };\n+      debugPrint(\"Temp data prepared successfully\");\n+\n+      debugPrint(\n+        \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n+      );\n+      debugPrint(\"FirebaseAuth instance: $_auth\");\n+\n+      // ØªÙØ¹ÙŠÙ„ reCAPTCHA Ù„Ù„Ù€ iOS ØµØ±Ø§Ø­Ø©\n+      if (Platform.isIOS) {\n+        debugPrint(\"Setting up reCAPTCHA for iOS...\");\n+        try {\n+          // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±\n+          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n+\n+          await _auth.setSettings(\n+            appVerificationDisabledForTesting:\n+                isTestNumber, // Ù„Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ ÙÙ‚Ø·\n+            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA Ù„Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙÙ‚Ø·\n+          );\n+\n+          debugPrint(\"âœ… Firebase Auth settings configured for iOS\");\n+          debugPrint(\"ğŸ“± Test number mode: $isTestNumber\");\n+\n+          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚\n+          await Future.delayed(const Duration(milliseconds: 500));\n+        } catch (e) {\n+          debugPrint(\"âš ï¸ Error setting Firebase Auth settings: $e\");\n+          // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª reCAPTCHAØŒ Ø¬Ø±Ø¨ Ø¨Ø¯ÙˆÙ†Ù‡Ø§\n+          debugPrint(\"ğŸ”„ Trying without forced reCAPTCHA...\");\n+        }\n+      }\n+\n+      // Ø¥Ø¶Ø§ÙØ© timeout Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ù…Ù„ Ø§Ù„Ù€ callbacks\n+      Timer callbackTimeoutTimer = Timer(const Duration(seconds: 30), () {\n+        if (isOtpSending.value || isLoading.value) {\n+          debugPrint(\"âš ï¸ Callback timeout - reCAPTCHA may not have appeared\");\n+          debugPrint(\"âš ï¸ This usually means Firebase Console settings issue\");\n+          isOtpSending.value = false;\n+          isLoading.value = false;\n+          isOtpVerifying.value = false;\n+          update();\n+          Get.snackbar(\n+            \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚\",\n+            \"Ù„Ù… ØªØ¸Ù‡Ø± ØµÙØ­Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Firebase Ø£Ùˆ Ø¬Ø±Ø¨ Ø±Ù‚Ù…Ø§Ù‹ Ø¢Ø®Ø±.\",\n+            backgroundColor: Colors.orange.shade400,\n+            colorText: Colors.white,\n+            snackPosition: SnackPosition.BOTTOM,\n+            duration: const Duration(seconds: 5),\n+          );\n+        }\n+      });\n+\n+      await _auth.verifyPhoneNumber(\n+        phoneNumber: formattedPhoneNumber,\n+        forceResendingToken: resendToken.value,\n+        verificationCompleted: (PhoneAuthCredential credential) async {\n+          debugPrint(\"ğŸ‰ VERIFICATION COMPLETED CALLBACK TRIGGERED\");\n+          debugPrint(\n+            \"Phone auto-verified. Credential SMS code (if available): ${credential.smsCode}\",\n+          );\n+\n+          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n+          callbackTimeoutTimer.cancel();\n+\n+          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©\n+          isOtpSending.value = false;\n+          isLoading.value = true;\n+          isOtpVerifying.value = true;\n+          update();\n+\n+          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ UI Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¹Ù„Ù‰ iOS\n+          if (Platform.isIOS) {\n+            await Future.delayed(const Duration(milliseconds: 100));\n+          }\n+\n+          await _finalizeSellerRegistration(isAutoVerified: true);\n+        },\n+        verificationFailed: (FirebaseAuthException e) {\n+          debugPrint(\"âŒ VERIFICATION FAILED CALLBACK TRIGGERED\");\n+          debugPrint(\"Phone verification failed: ${e.code} - ${e.message}\");\n+          debugPrint(\"Full error: ${e.toString()}\");\n+\n+          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n+          callbackTimeoutTimer.cancel();\n+\n+          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª\n+          isOtpSending.value = false;\n+          isLoading.value = false;\n+          isOtpVerifying.value = false;\n+          update();\n+\n+          String errorMessage = \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ.\";\n+          if (e.code == 'invalid-phone-number') {\n+            errorMessage =\n+                \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ $formattedPhoneNumber Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ§Ù„Ø­.\";\n+          } else if (e.code == 'too-many-requests') {\n+            errorMessage =\n+                \"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.\";\n+          } else if (e.code == 'network-request-failed') {\n+            errorMessage =\n+                \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\";\n+          }\n+          Get.snackbar(\n+            \"Ø®Ø·Ø£\",\n+            errorMessage,\n+            backgroundColor: Colors.red.shade400,\n+            colorText: Colors.white,\n+            snackPosition: SnackPosition.BOTTOM,\n+          );\n+        },\n+        codeSent: (String verId, int? resendTok) async {\n+          debugPrint(\"ğŸ“± CODE SENT CALLBACK TRIGGERED\");\n+          debugPrint(\n+            \"OTP code sent. Verification ID: $verId, Resend Token: $resendTok\",\n+          );\n+\n+          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n+          callbackTimeoutTimer.cancel();\n+\n+          isOtpSending.value = false; // OTP sending part is done\n+          // isLoading remains true as we are waiting for OTP input\n+          update();\n+\n+          verificationId.value = verId;\n+          resendToken.value = resendTok;\n+\n+          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ø¹Ù„Ù‰ iOS Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ UI Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n+          if (Platform.isIOS) {\n+            await Future.delayed(const Duration(milliseconds: 200));\n+          }\n+\n+          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ØªÙ†Ù‚Ù„ ÙŠØ­Ø¯Ø« Ø¹Ù„Ù‰ Ø§Ù„Ù€ main thread\n+          WidgetsBinding.instance.addPostFrameCallback((_) {\n+            debugPrint(\"Navigating to OTP verification screen...\");\n+            Get.to(() => OtpVerificationScreen());\n+          });\n+        },\n+        codeAutoRetrievalTimeout: (String verId) {\n+          debugPrint(\"â° CODE AUTO RETRIEVAL TIMEOUT CALLBACK TRIGGERED\");\n+          debugPrint(\"OTP auto-retrieval timed out. Verification ID: $verId\");\n+          verificationId.value = verId;\n+          // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† isOtpSending ÙÙŠ Ø­Ø§Ù„ timeout Ø¹Ù„Ù‰ iOS\n+          if (Platform.isIOS) {\n+            isOtpSending.value = false;\n+            update();\n+          }\n+        },\n+        timeout:\n+            Platform.isIOS\n+                ? const Duration(seconds: 60) // Ù…Ø¯Ø© Ø£Ù‚ØµØ± Ø¹Ù„Ù‰ iOS\n+                : const Duration(seconds: 120), // Ù…Ø¯Ø© Ø£Ø·ÙˆÙ„ Ø¹Ù„Ù‰ Android\n+      );\n+      debugPrint(\"âœ… verifyPhoneNumber call completed successfully\");\n+    } catch (e) {\n+      debugPrint(\"ğŸš¨ EXCEPTION CAUGHT IN verifyPhoneNumber\");\n+      debugPrint(\"Exception type: ${e.runtimeType}\");\n+      debugPrint(\"Exception details: $e\");\n+\n+      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£\n+      isOtpSending.value = false;\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      update();\n+\n+      String errorMessage = \"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ.\";\n+\n+      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…Ø­Ø¯Ø¯Ø©\n+      if (e.toString().contains('network')) {\n+        errorMessage = \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.\";\n+      } else if (e.toString().contains('too-many-requests')) {\n+        errorMessage = \"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.\";\n+      }\n+\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        errorMessage,\n+        backgroundColor: Colors.red.shade500,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<void> verifyOtpAndFinalize(String otpCode) async {\n+    if (otpCode.isEmpty || otpCode.length < 6) {\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² OTP Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 6 Ø£Ø±Ù‚Ø§Ù….\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+\n+    isOtpVerifying.value = true;\n+    isLoading.value =\n+        true; // isLoading should ideally be true from the previous step\n+    update();\n+\n+    try {\n+      PhoneAuthCredential credential = PhoneAuthProvider.credential(\n+        verificationId: verificationId.value,\n+        smsCode: otpCode,\n+      );\n+\n+      // **** Ø®Ø·ÙˆØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ù€ Credential Ù‡Ù†Ø§ ****\n+      final User? currentUser = _auth.currentUser;\n+      if (currentUser == null) {\n+        throw FirebaseAuthException(\n+          code: 'no-current-user',\n+          message: 'No user is currently signed in.',\n+        );\n+      }\n+\n+      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ø¨Ø· Ø§Ù„Ù€ Credential Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† OTP\n+      try {\n+        await currentUser.linkWithCredential(credential);\n+        debugPrint(\"Phone credential linked successfully.\");\n+      } catch (linkError) {\n+        if (linkError is FirebaseAuthException &&\n+            linkError.code == 'provider-already-linked') {\n+          debugPrint(\n+            \"Phone provider already linked, verifying OTP directly...\",\n+          );\n+          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø²ÙˆØ¯ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù†ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© OTP ÙÙ‚Ø·\n+          await _auth.signInWithCredential(credential);\n+          debugPrint(\n+            \"OTP verified successfully with existing linked provider.\",\n+          );\n+        } else {\n+          rethrow; // Ø¥Ø¹Ø§Ø¯Ø© Ø·Ø±Ø­ Ø£ÙŠ Ø®Ø·Ø£ Ø¢Ø®Ø±\n+        }\n+      }\n+\n+      // Ø¥Ù„ØºØ§Ø¡ safety timeout Ù„Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù†Ø¬Ø­Øª\n+      _cancelSafetyTimeout();\n+\n+      // Ø¥Ø°Ø§ Ù†Ø¬Ø­ Ø§Ù„Ø±Ø¨Ø· Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n+      await _finalizeSellerRegistration(isOtpNowVerified: true);\n+    } on FirebaseAuthException catch (e) {\n+      isOtpVerifying.value = false;\n+      isLoading.value = false;\n+      update();\n+      debugPrint(\n+        \"FirebaseAuthException during OTP verification: ${e.code} - ${e.message}\",\n+      );\n+      String errorMessage = \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù…Ø² OTP.\";\n+      if (e.code == 'invalid-verification-code' ||\n+          e.code == 'invalid-credential') {\n+        errorMessage = \"Ø±Ù…Ø² OTP Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ­ÙŠØ­.\";\n+      } else if (e.code == 'session-expired') {\n+        errorMessage = \"Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø¬Ù„Ø³Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ Ø±Ù…Ø² Ø¬Ø¯ÙŠØ¯.\";\n+      } else if (e.code == 'credential-already-in-use') {\n+        // Ù‡Ø°Ù‡ Ø­Ø§Ù„Ø© Ø®Ø§ØµØ©: Ø§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ø­Ø³Ø§Ø¨ Ø¢Ø®Ø±. Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ù†ÙØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ Ù†Ø¬Ø§Ø­Ù‹Ø§.\n+        // Ù‡Ù†Ø§ØŒ Ù†ÙØªØ±Ø¶ Ø£Ù†Ù†Ø§ Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø©ØŒ ÙˆØ§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø· Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙÙ‡Ø°Ø§ Ø¬ÙŠØ¯.\n+        // ÙˆÙ„ÙƒÙ† Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø®ØªÙ„ÙØŒ ÙÙ‡Ø°Ù‡ Ù…Ø´ÙƒÙ„Ø©.\n+        // Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø³Ø§Ø·Ø©ØŒ Ø³Ù†Ø¹ØªØ¨Ø±Ù‡Ø§ Ø®Ø·Ø£ Ø¹Ø§Ù… Ø§Ù„Ø¢Ù†ØŒ ÙˆÙ„ÙƒÙ† ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ† Ù‡Ø°Ø§.\n+        // Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù†Ù‡ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙŠÙ…ÙƒÙ† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©.\n+        // Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£Ø¨Ø³Ø· Ù‡Ùˆ Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ ÙƒØ®Ø·Ø£ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ØªØ£ÙƒØ¯Ù‹Ø§ Ù…Ù† ÙƒÙŠÙÙŠØ© Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.\n+        // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ _finalizeSellerRegistration Ù‡Ù†Ø§ Ø£ÙŠØ¶Ù‹Ø§.\n+        // For now, treat as a specific error message or proceed if logic allows\n+        debugPrint(\n+          \"Credential already in use. Assuming for this user is okay or needs specific handling.\",\n+        );\n+        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­\n+        // await _finalizeSellerRegistration(isOtpNowVerified: true);\n+        // Get.snackbar(\"Ù…Ø¹Ù„ÙˆÙ…Ø©\", \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.\", snackPosition: SnackPosition.BOTTOM);\n+        // return;\n+        errorMessage =\n+            \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ø­Ø³Ø§Ø¨ÙƒØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù….\";\n+      } else if (e.code == 'no-current-user') {\n+        errorMessage =\n+            \"Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.\";\n+        // ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØµÙØ­Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„\n+      }\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        errorMessage,\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    } catch (e) {\n+      isOtpVerifying.value = false;\n+      isLoading.value = false;\n+      update();\n+      debugPrint(\"Generic error verifying OTP: $e\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù…Ø².\",\n+        backgroundColor: Colors.red.shade500,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<void> _finalizeSellerRegistration({\n+    bool isAutoVerified = false,\n+    bool isOtpNowVerified = false,\n+  }) async {\n+    debugPrint(\"ğŸ”§ _finalizeSellerRegistration called\");\n+    debugPrint(\n+      \"ğŸ”§ isAutoVerified: $isAutoVerified, isOtpNowVerified: $isOtpNowVerified\",\n+    );\n+\n+    // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙˆÙ„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¢Ù† (Ù…Ù† verifyOtpAndFinalize)ØŒ ÙÙ„Ø§ ØªØªØ§Ø¨Ø¹\n+    if (!isAutoVerified && !isOtpNowVerified) {\n+      debugPrint(\"âŒ Neither auto verified nor OTP verified - stopping\");\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ.\",\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      return;\n+    }\n+\n+    debugPrint(\n+      \"âœ… Phone verification confirmed, proceeding with registration...\",\n+    );\n+\n+    // Set loading states for this final part\n+    isOtpVerifying.value = true;\n+    isLoading.value = true;\n+    update();\n+\n+    try {\n+      final User? currentUser = _auth.currentUser;\n+      if (currentUser == null) {\n+        Get.snackbar(\n+          \"Ø®Ø·Ø£\",\n+          \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø§Ù„ÙŠ. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n+          backgroundColor: Colors.red.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+        );\n+        isLoading.value = false;\n+        isOtpVerifying.value = false;\n+        // Navigate to login or welcome screen\n+        return;\n+      }\n+\n+      String? sellerProfileImageUrl;\n+      String? shopFrontImageUrl;\n+\n+      // iOS-specific: Wait for Firebase to be fully ready\n+      if (Platform.isIOS) {\n+        debugPrint(\n+          \"ğŸ”§ iOS detected - waiting for Firebase Storage to be ready...\",\n+        );\n+        await Future.delayed(Duration(milliseconds: 3000));\n+\n+        // Verify Firebase Storage is accessible\n+        try {\n+          _storage.ref().child('test_connection');\n+          debugPrint(\"âœ… Firebase Storage connection test passed\");\n+        } catch (e) {\n+          debugPrint(\"âš ï¸ Firebase Storage connection test failed: $e\");\n+        }\n+      }\n+\n+      if (_tempSellerProfileImageFile != null) {\n+        debugPrint(\"ğŸ–¼ï¸ Uploading seller profile image...\");\n+        if (Platform.isIOS) {\n+          sellerProfileImageUrl = await _iosStorageHandler.uploadFile(\n+            _tempSellerProfileImageFile!,\n+            'seller_profile_images/${currentUser.uid}',\n+          );\n+        } else {\n+          sellerProfileImageUrl = await _uploadFile(\n+            _tempSellerProfileImageFile!,\n+            'seller_profile_images/${currentUser.uid}',\n+          );\n+        }\n+      }\n+      if (_tempShopFrontImageFile != null) {\n+        debugPrint(\"ğŸª Uploading shop front image...\");\n+        if (Platform.isIOS) {\n+          shopFrontImageUrl = await _iosStorageHandler.uploadFile(\n+            _tempShopFrontImageFile!,\n+            'shop_front_images/${currentUser.uid}',\n+          );\n+        } else {\n+          shopFrontImageUrl = await _uploadFile(\n+            _tempShopFrontImageFile!,\n+            'shop_front_images/${currentUser.uid}',\n+          );\n+        }\n+      }\n+\n+      if (_tempSellerProfileImageFile != null &&\n+          sellerProfileImageUrl == null) {\n+        throw Exception(\"Failed to upload seller profile image.\");\n+      }\n+      if (_tempShopFrontImageFile != null && shopFrontImageUrl == null) {\n+        throw Exception(\"Failed to upload shop front image.\");\n+      }\n+\n+      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM Token Ø¨Ø´ÙƒÙ„ Ø§Ø­ØªØ±Ø§ÙÙŠ\n+      final String? fcmToken = await _getFCMTokenSafely();\n+\n+      // Ø§Ø³ØªØ®Ø¯Ø§Ù… SellerModel Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n+      final SellerModel sellerToSave = SellerModel(\n+        uid: currentUser.uid,\n+        sellerName:\n+            _tempSellerDataForSubmission?['sellerName'] as String? ?? '',\n+        sellerProfileImageUrl: sellerProfileImageUrl,\n+        shopName: _tempSellerDataForSubmission?['shopName'] as String? ?? '',\n+        shopFrontImageUrl: shopFrontImageUrl,\n+        shopPhoneNumber:\n+            _tempSellerDataForSubmission?['shopPhoneNumber'] as String? ?? '',\n+        shopDescription:\n+            _tempSellerDataForSubmission?['shopDescription'] as String?,\n+        location:\n+            _tempSellerDataForSubmission?['location'] as GeoPoint? ??\n+            const GeoPoint(\n+              0,\n+              0,\n+            ), // ØªÙ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† location Ù‡Ùˆ GeoPoint ÙÙŠ _tempSellerDataForSubmission\n+        shopAddressText:\n+            _tempSellerDataForSubmission?['shopAddressText'] as String?,\n+        shopCategory:\n+            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'Ø£Ø®Ø±Ù‰',\n+        workingHours: Map<String, dynamic>.from(\n+          _tempSellerDataForSubmission?['workingHours'] ?? {},\n+        ),\n+        // Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªØ§Ù„ÙŠØ© Ø§Ø®ØªÙŠØ§Ø±ÙŠØ© ÙÙŠ SellerModel ÙˆØ³ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡Ø§ Ø¥Ù„Ù‰ null Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ _tempSellerDataForSubmission\n+        commercialRegistrationNumber:\n+            _tempSellerDataForSubmission?['commercialRegistrationNumber']\n+                as String?,\n+        websiteUrl: _tempSellerDataForSubmission?['websiteUrl'] as String?,\n+        socialMediaLinks:\n+            _tempSellerDataForSubmission?['socialMediaLinks']\n+                as Map<String, String>?,\n+\n+        isProfileComplete: true, // ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n+        isApprovedByAdmin: false, // ÙŠØ­ØªØ§Ø¬ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø´Ø±Ù Ø¨Ø´ÙƒÙ„ Ø§ÙØªØ±Ø§Ø¶ÙŠ\n+        isActiveBySeller: true, // Ù†Ø´Ø· Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§\n+        isPhoneNumberVerified: true, // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n+        averageRating: 0.0,\n+        numberOfRatings: 0,\n+        sellerType: _sellerTypeFromAuth, // Ù…Ù† SellerAuthController\n+        registrationCompleted: true, // Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n+        createdAt:\n+            Timestamp.now(), // Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ FieldValue.serverTimestamp() Ø£Ø¯Ù†Ø§Ù‡\n+        updatedAt:\n+            null, // SellerModel.toMap() Ø³ÙŠØ¹ÙŠÙ† FieldValue.serverTimestamp() Ù„Ù‡Ø°Ø§\n+      );\n+\n+      Map<String, dynamic> sellerDataToSave = sellerToSave.toMap();\n+\n+      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø®Ø§Ø¯Ù… ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ SellerModel\n+      sellerDataToSave['createdAt'] = FieldValue.serverTimestamp();\n+      sellerDataToSave['updatedAt'] =\n+          FieldValue.serverTimestamp(); // Ù„Ù„ØªØ£ÙƒÙŠØ¯ Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† SellerModel.toMap Ù„Ø§ ÙŠÙØ¹Ù„ Ø°Ù„Ùƒ\n+\n+      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªÙŠ Ù„ÙŠØ³Øª Ø¬Ø²Ø¡Ù‹Ø§ Ù…Ù† SellerModel ÙˆÙ„ÙƒÙ†Ù‡Ø§ Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Firestore\n+      sellerDataToSave['email'] = currentUser.email;\n+\n+      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ø­ÙØ¸ FCM Token\n+      if (fcmToken != null && fcmToken.isNotEmpty) {\n+        sellerDataToSave['fcmToken'] = fcmToken;\n+        sellerDataToSave['fcmTokenUpdatedAt'] = FieldValue.serverTimestamp();\n+        debugPrint(\n+          \"âœ… FCM Token will be saved: ${fcmToken.substring(0, 30)}...\",\n+        );\n+      } else {\n+        debugPrint(\n+          \"âš ï¸ No FCM Token available - saving without notification capability\",\n+        );\n+        // Ù„Ø§ Ù†Ø­ÙØ¸ fcmToken Ø¥Ø°Ø§ ÙƒØ§Ù† null Ù„ØªØ¬Ù†Ø¨ overwrite Ø£ÙŠ token Ù…ÙˆØ¬ÙˆØ¯\n+        sellerDataToSave['fcmTokenStatus'] = 'failed_to_retrieve';\n+        sellerDataToSave['fcmTokenFailedAt'] = FieldValue.serverTimestamp();\n+\n+        // Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n+        debugPrint(\"ğŸ“… Scheduling FCM token retry for later...\");\n+      }\n+\n+      debugPrint(\"ğŸ’¾ Saving seller data to Firestore...\");\n+      debugPrint(\"ğŸ’¾ Document ID: ${currentUser.uid}\");\n+      debugPrint(\"ğŸ’¾ Collection: ${FirebaseX.collectionSeller}\");\n+\n+      await _firestore\n+          .collection(FirebaseX.collectionSeller)\n+          .doc(currentUser.uid)\n+          .set(sellerDataToSave, SetOptions(merge: true));\n+\n+      debugPrint(\"âœ… Seller data saved successfully to Firestore!\");\n+\n+      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      update();\n+\n+      debugPrint(\"ğŸ‰ Registration completed successfully!\");\n+\n+      // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ FCM tokenØŒ Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\n+      if (fcmToken == null || fcmToken.isEmpty) {\n+        retryFCMTokenLater();\n+      }\n+\n+      Get.snackbar(\n+        \"Ù†Ø¬Ø§Ø­\",\n+        \"ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!\",\n+        backgroundColor: Colors.green.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+\n+      // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ø¹Ù„Ù‰ iOS Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n+      if (Platform.isIOS) {\n+        await Future.delayed(const Duration(milliseconds: 500));\n+      }\n+\n+      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªÙ†Ù‚Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ main thread\n+      WidgetsBinding.instance.addPostFrameCallback((_) {\n+        Get.offAll(\n+          () => SellerMainScreen(),\n+        ); // Navigate to seller dashboard or main screen\n+      });\n+    } catch (e) {\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      update();\n+      debugPrint(\"Error finalizing seller registration: $e\");\n+      String errorMessage = \"ÙØ´Ù„ Ø¥ÙƒÙ…Ø§Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ³Ø¬ÙŠÙ„.\";\n+      if (e is FirebaseException &&\n+          e.code == 'invalid-credential' &&\n+          isAutoVerified) {\n+        errorMessage =\n+            \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ. Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ù…Ø² ÙŠØ¯ÙˆÙŠÙ‹Ø§.\";\n+        // Optionally, you could re-route to OTP screen if auto-verification was the only path here\n+        // Get.to(() => OtpVerificationScreen()); // Might need to handle this case more gracefully\n+      } else if (e is FirebaseException &&\n+          e.code == 'invalid-verification-code') {\n+        errorMessage = \"Ø±Ù…Ø² OTP Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ­ÙŠØ­.\";\n+      } else if (e is FirebaseException && e.code == 'session-expired') {\n+        errorMessage = \"Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø¬Ù„Ø³Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ Ø±Ù…Ø² Ø¬Ø¯ÙŠØ¯.\";\n+      }\n+\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"$errorMessage ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<String?> _uploadFile(File file, String path) async {\n+    try {\n+      debugPrint(\"ğŸ”§ Starting file upload to: $path\");\n+      debugPrint(\"ğŸ”§ File exists: ${await file.exists()}\");\n+      debugPrint(\"ğŸ”§ File size: ${await file.length()} bytes\");\n+\n+      // Verify Firebase Storage is properly initialized\n+      if (Firebase.apps.isEmpty) {\n+        throw Exception(\"Firebase not initialized\");\n+      }\n+\n+      final ref = _storage.ref().child(path);\n+      debugPrint(\"ğŸ”§ Storage reference created: ${ref.fullPath}\");\n+\n+      // iOS-specific: Add metadata to help with upload\n+      final metadata = SettableMetadata(\n+        contentType: 'image/jpeg',\n+        customMetadata: {\n+          'uploaded_by': 'seller_registration',\n+          'platform': Platform.isIOS ? 'ios' : 'android',\n+        },\n+      );\n+\n+      final uploadTask = ref.putFile(file, metadata);\n+\n+      // Monitor upload progress\n+      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n+        final progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n+        debugPrint(\"ğŸ”§ Upload progress: ${progress.toStringAsFixed(1)}%\");\n+      });\n+\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"âœ… File uploaded successfully: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"âŒ Error uploading file ($path): $e\");\n+\n+      // iOS-specific error handling\n+      if (Platform.isIOS && e.toString().contains('object-not-found')) {\n+        debugPrint(\n+          \"ğŸ”§ iOS Storage issue detected - retrying with different approach\",\n+        );\n+        return await _uploadFileWithRetry(file, path);\n+      }\n+\n+      return null;\n+    }\n+  }\n+\n+  Future<String?> _uploadFileWithRetry(File file, String path) async {\n+    try {\n+      // Wait a bit longer on iOS\n+      await Future.delayed(Duration(milliseconds: 1500));\n+\n+      // Try with a different path structure for iOS\n+      final timestamp = DateTime.now().millisecondsSinceEpoch;\n+      final newPath = '${path.replaceAll('/', '_')}_$timestamp';\n+\n+      debugPrint(\"ğŸ”§ Retrying upload with path: $newPath\");\n+\n+      final ref = _storage.ref().child(newPath);\n+      final uploadTask = ref.putFile(file);\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"âœ… Retry upload successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"âŒ Retry upload also failed: $e\");\n+      return null;\n+    }\n+  }\n+\n+  Future<void> pickImage(\n+    ImageSource source, {\n+    required bool isProfileImage,\n+  }) async {\n+    try {\n+      final XFile? pickedFile = await _picker.pickImage(\n+        source: source,\n+        imageQuality: 70,\n+        maxWidth: 1024,\n+      );\n+      if (pickedFile != null) {\n+        if (isProfileImage) {\n+          sellerProfileImageFile.value = File(pickedFile.path);\n+        } else {\n+          shopFrontImageFile.value = File(pickedFile.path);\n+        }\n+        update(); // For GetBuilder if used\n+      }\n+    } catch (e) {\n+      Get.snackbar(\"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©\", \"ÙØ´Ù„ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØµÙˆØ±Ø©: $e\");\n+    }\n+  }\n+\n+  // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©\n+  void toggleCategorySelection(String category) {\n+    if (selectedShopCategories.contains(category)) {\n+      selectedShopCategories.remove(category);\n+    } else {\n+      if (selectedShopCategories.length < maxCategoriesAllowed) {\n+        selectedShopCategories.add(category);\n+      } else {\n+        Get.snackbar(\n+          \"ØªØ­Ø°ÙŠØ±\",\n+          \"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ Ø£Ù‚ØµÙ‰ $maxCategoriesAllowed ÙØ¦Ø§Øª ÙÙ‚Ø·\",\n+          backgroundColor: Colors.orange.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+        );\n+      }\n+    }\n+  }\n+\n+  // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©\n+  bool isCategorySelected(String category) {\n+    return selectedShopCategories.contains(category);\n+  }\n+\n+  // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n+  int get selectedCategoriesCount => selectedShopCategories.length;\n+\n+  // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Øµ Ø¹Ø±Ø¶ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n+  String get selectedCategoriesDisplay {\n+    if (selectedShopCategories.isEmpty) {\n+      return 'Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠ ÙØ¦Ø©';\n+    } else if (selectedShopCategories.length == 1) {\n+      return selectedShopCategories.first;\n+    } else {\n+      return '${selectedShopCategories.length} ÙØ¦Ø§Øª Ù…Ø®ØªØ§Ø±Ø©';\n+    }\n+  }\n+\n+  void toggleDayOpen(String dayKey) {\n+    if (workingHours[dayKey] != null) {\n+      bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n+      workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n+\n+      if (!workingHours[dayKey]!['isOpen']) {\n+        // If day is being closed\n+        workingHours[dayKey]!['opensAt'] = null;\n+        workingHours[dayKey]!['closesAt'] = null;\n+        if (expandedDayPanel.value == dayKey) {\n+          // Close expansion panel if it was this day\n+          expandedDayPanel.value = null;\n+        }\n+      } else {\n+        // If day is being opened\n+        workingHours[dayKey]!['opensAt'] =\n+            _lastAppliedOpensAt.value ?? \"09:00 AM\";\n+        workingHours[dayKey]!['closesAt'] =\n+            _lastAppliedClosesAt.value ?? \"05:00 PM\";\n+        // Optionally, open this panel when day is toggled on if not already open by user interaction\n+        // expandedDayPanel.value = dayKey;\n+      }\n+      workingHours.refresh();\n+    }\n+  }\n+\n+  bool canApplyToOthers(String dayKey) {\n+    final dayData = workingHours[dayKey];\n+    if (dayData == null || !(dayData['isOpen'] == true)) return false;\n+    return dayData['opensAt'] != null && dayData['closesAt'] != null;\n+  }\n+\n+  void offerToApplyTimesToOtherDays(\n+    BuildContext context,\n+    String sourceDayKey,\n+    String opensAtToApply,\n+    String closesAtToApply,\n+  ) {\n+    Get.dialog(\n+      AlertDialog(\n+        title: const Text(\"ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§ØªØŸ\"),\n+        content: Text(\n+          \"Ù‡Ù„ ØªØ±ØºØ¨ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‚Øª Ø§Ù„ÙØªØ­ ($opensAtToApply) ÙˆÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ($closesAtToApply) Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø®Ø±Ù‰ Ø§Ù„ØªÙŠ ØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡Ø§ ÙƒÙ…ÙØªÙˆØ­Ø© ÙˆÙ„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ‚Ø§Øª Ù„Ù‡Ø§ Ø¨Ø¹Ø¯ Ø£Ùˆ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…ÙØªÙˆØ­Ø©ØŸ\",\n+        ),\n+        actionsAlignment: MainAxisAlignment.spaceEvenly,\n+        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),\n+        actions: [\n+          TextButton(child: const Text(\"Ø¥Ù„ØºØ§Ø¡\"), onPressed: () => Get.back()),\n+          ElevatedButton(\n+            child: const Text(\"Ù„Ù„Ø£ÙŠØ§Ù… Ø§Ù„ÙØ§Ø±ØºØ© ÙÙ‚Ø·\"),\n+            onPressed: () {\n+              Get.back();\n+              applyTimesToOtherOpenDays(\n+                sourceDayKey,\n+                opensAtToApply,\n+                closesAtToApply,\n+                applyToAllOpen: false,\n+              );\n+            },\n+          ),\n+          ElevatedButton(\n+            child: const Text(\"Ù†Ø¹Ù…ØŒ Ù„Ù„ÙƒÙ„ (Ø§Ù„Ù…ÙØªÙˆØ­)\"),\n+            onPressed: () {\n+              Get.back();\n+              applyTimesToOtherOpenDays(\n+                sourceDayKey,\n+                opensAtToApply,\n+                closesAtToApply,\n+                applyToAllOpen: true,\n+              );\n+            },\n+          ),\n+        ],\n+      ),\n+      barrierDismissible: true,\n+    );\n+  }\n+\n+  void applyTimesToOtherOpenDays(\n+    String sourceDayKey,\n+    String opensAtToApply,\n+    String closesAtToApply, {\n+    required bool applyToAllOpen,\n+  }) {\n+    bool timesApplied = false;\n+    workingHours.forEach((key, value) {\n+      if (key != sourceDayKey && (value['isOpen'] == true)) {\n+        bool apply = false;\n+        if (applyToAllOpen) {\n+          apply = true;\n+        } else {\n+          // Apply to empty open days only\n+          if (value['opensAt'] == null || value['closesAt'] == null) {\n+            apply = true;\n+          }\n+        }\n+        if (apply) {\n+          value['opensAt'] = opensAtToApply;\n+          value['closesAt'] = closesAtToApply;\n+          timesApplied = true;\n+        }\n+      }\n+    });\n+    if (timesApplied) {\n+      _lastAppliedOpensAt.value =\n+          opensAtToApply; // Update template if changes were made\n+      _lastAppliedClosesAt.value = closesAtToApply;\n+      workingHours.refresh();\n+      Get.snackbar(\n+        \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«\",\n+        \"ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.\",\n+        snackPosition: SnackPosition.BOTTOM,\n+        backgroundColor: Colors.green.shade400,\n+        colorText: Colors.white,\n+      );\n+    } else {\n+      Get.snackbar(\n+        \"Ù„Ù… ÙŠØªØºÙŠØ± Ø´ÙŠØ¡\",\n+        \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠØ§Ù… Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø¹Ù„ÙŠÙ‡Ø§ Ø­Ø³Ø¨ Ø§Ø®ØªÙŠØ§Ø±Ùƒ.\",\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<void> selectTime(\n+    BuildContext context,\n+    String dayKey,\n+    bool isOpeningTime,\n+  ) async {\n+    final Map<String, dynamic>? dayData = workingHours[dayKey];\n+    final String? opensAtString = dayData?['opensAt'] as String?;\n+    final String? closesAtString = dayData?['closesAt'] as String?;\n+\n+    String? timeToParse;\n+    if (isOpeningTime) {\n+      timeToParse = opensAtString;\n+    } else {\n+      timeToParse = closesAtString;\n+    }\n+\n+    TimeOfDay? initialTime = _parseTime(timeToParse) ?? TimeOfDay.now();\n+\n+    final TimeOfDay? pickedTime = await showTimePicker(\n+      context: context,\n+      initialTime: initialTime,\n+      builder: (context, child) {\n+        return Theme(\n+          data: ThemeData.light().copyWith(\n+            colorScheme: ColorScheme.light(\n+              primary: Get.theme.primaryColor, // header background color\n+              onPrimary: Colors.white, // header text color\n+              onSurface: Colors.black, // body text color\n+            ),\n+            timePickerTheme: TimePickerThemeData(\n+              dialHandColor: Get.theme.primaryColor,\n+            ),\n+            textButtonTheme: TextButtonThemeData(\n+              style: TextButton.styleFrom(\n+                foregroundColor: Get.theme.primaryColor, // button text color\n+              ),\n+            ),\n+          ),\n+          child: child!,\n+        );\n+      },\n+    );\n+\n+    if (pickedTime != null) {\n+      final formattedTime = formatTimeOfDay(pickedTime);\n+      final currentOpensAt = _parseTime(workingHours[dayKey]?['opensAt']);\n+      final currentClosesAt = _parseTime(workingHours[dayKey]?['closesAt']);\n+\n+      if (isOpeningTime) {\n+        if (currentClosesAt != null &&\n+            _isTimeBeforeOrEqual(\n+              pickedTime,\n+              currentClosesAt,\n+              isOpening: true,\n+              isClosing: false,\n+            )) {\n+          workingHours[dayKey]!['opensAt'] = formattedTime;\n+          _lastAppliedOpensAt.value = formattedTime;\n+        } else if (currentClosesAt != null) {\n+          Get.snackbar(\n+            \"ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­\",\n+            \"ÙˆÙ‚Øª Ø§Ù„ÙØªØ­ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚.\",\n+            snackPosition: SnackPosition.BOTTOM,\n+            backgroundColor: Colors.orange.shade300,\n+          );\n+          return;\n+        } else {\n+          // No closing time set yet, allow setting opening time\n+          workingHours[dayKey]!['opensAt'] = formattedTime;\n+          _lastAppliedOpensAt.value = formattedTime;\n+        }\n+      } else {\n+        // isClosingTime\n+        if (currentOpensAt != null &&\n+            _isTimeBeforeOrEqual(\n+              currentOpensAt,\n+              pickedTime,\n+              isOpening: false,\n+              isClosing: true,\n+            )) {\n+          workingHours[dayKey]!['closesAt'] = formattedTime;\n+          _lastAppliedClosesAt.value = formattedTime;\n+        } else if (currentOpensAt != null) {\n+          Get.snackbar(\n+            \"ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­\",\n+            \"ÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø¹Ø¯ ÙˆÙ‚Øª Ø§Ù„ÙØªØ­.\",\n+            snackPosition: SnackPosition.BOTTOM,\n+            backgroundColor: Colors.orange.shade300,\n+          );\n+          return;\n+        } else {\n+          // No opening time set yet, allow setting closing time\n+          workingHours[dayKey]!['closesAt'] = formattedTime;\n+          _lastAppliedClosesAt.value = formattedTime;\n+        }\n+      }\n+      workingHours.refresh();\n+    }\n+  }\n+\n+  bool _isTimeBeforeOrEqual(\n+    TimeOfDay time1,\n+    TimeOfDay time2, {\n+    required bool isOpening,\n+    required bool isClosing,\n+  }) {\n+    final time1Minutes = time1.hour * 60 + time1.minute;\n+    final time2Minutes = time2.hour * 60 + time2.minute;\n+    if (isOpening) {\n+      // time1 is opensAt, time2 is closesAt\n+      return time1Minutes < time2Minutes;\n+    } else {\n+      // time1 is opensAt, time2 is closesAt\n+      return time1Minutes < time2Minutes;\n+    }\n+  }\n+\n+  String formatTimeOfDay(TimeOfDay tod) {\n+    final now = DateTime.now();\n+    final dt = DateTime(now.year, now.month, now.day, tod.hour, tod.minute);\n+    final format = DateFormat.jm(); // e.g., 5:08 PM\n+    return format.format(dt);\n+  }\n+\n+  TimeOfDay? _parseTime(String? timeString) {\n+    if (timeString == null) return null;\n+    try {\n+      final format =\n+          DateFormat.jm(); // Needs to match the format used in formatTimeOfDay\n+      final dt = format.parse(timeString);\n+      return TimeOfDay.fromDateTime(dt);\n+    } catch (e) {\n+      debugPrint(\"Error parsing time: $e\");\n+      return null;\n+    }\n+  }\n+\n+  // --- Location Methods ---\n+  final TextEditingController streetAddressController = TextEditingController();\n+\n+  void onMapCreated(GoogleMapController controller) {\n+    mapController = controller;\n+  }\n+\n+  Future<void> openLocationPickerScreen(BuildContext context) async {\n+    final LatLng? result = await Get.to<LatLng>(\n+      () => LocationPickerScreen(initialLocation: shopLocation.value),\n+    );\n+    if (result != null) {\n+      shopLocation.value = result;\n+      await _getAddressFromLatLng(result);\n+      // Optionally move camera on the small map if it's visible and controller is available\n+      mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n+    }\n+  }\n+\n+  Future<void> _getAddressFromLatLng(LatLng latLng) async {\n+    try {\n+      List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n+        latLng.latitude,\n+        latLng.longitude,\n+      );\n+      if (placemarks.isNotEmpty) {\n+        final p = placemarks[0];\n+        // Construct a more detailed or relevant address string\n+        shopAddressText.value =\n+            \"${p.name}, ${p.locality}, ${p.subAdministrativeArea}, ${p.administrativeArea}\"\n+                .replaceAll(\"null,\", \"\")\n+                .trim()\n+                .replaceAll(RegExp(r'^, |,$'), '');\n+        if (streetAddressController.text.isEmpty &&\n+            p.street != null &&\n+            p.street!.isNotEmpty) {\n+          streetAddressController.text = p.street!;\n+        }\n+      } else {\n+        shopAddressText.value = \"ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n+      }\n+    } catch (e) {\n+      debugPrint(\"Error getting address: $e\");\n+      shopAddressText.value = \"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n+    }\n+  }\n+\n+  Future<void> tryMoveToCurrentLocation() async {\n+    isLoading.value = true; // Indicate loading for location fetch\n+    update();\n+    try {\n+      Position currentPosition = await _determinePosition();\n+      LatLng newLatLng = LatLng(\n+        currentPosition.latitude,\n+        currentPosition.longitude,\n+      );\n+      shopLocation.value = newLatLng;\n+      await _getAddressFromLatLng(newLatLng);\n+      mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n+    } catch (e) {\n+      Get.snackbar(\n+        \"Ø®Ø·Ø£\",\n+        \"ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${e.toString()}\",\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    } finally {\n+      isLoading.value = false;\n+      update();\n+    }\n+  }\n+\n+  Future<Position> _determinePosition() async {\n+    bool serviceEnabled;\n+    LocationPermission permission;\n+\n+    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n+    if (!serviceEnabled) {\n+      // Attempt to open location settings\n+      await Geolocator.openLocationSettings();\n+      return Future.error('Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø·Ù„Ø©. ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„Ù‡Ø§.');\n+    }\n+\n+    permission = await Geolocator.checkPermission();\n+    if (permission == LocationPermission.denied) {\n+      permission = await Geolocator.requestPermission();\n+      if (permission == LocationPermission.denied) {\n+        return Future.error('ØªÙ… Ø±ÙØ¶ Ø£Ø°ÙˆÙ†Ø§Øª ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹.');\n+      }\n+    }\n+\n+    if (permission == LocationPermission.deniedForever) {\n+      return Future.error(\n+        'Ø£Ø°ÙˆÙ†Ø§Øª ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø±ÙÙˆØ¶Ø© Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª. ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„Ù‡Ø§ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.',\n+      );\n+    }\n+    currentPositionAccuracy.value =\n+        (await Geolocator.getCurrentPosition()).accuracy;\n+\n+    return await Geolocator.getCurrentPosition(\n+      desiredAccuracy: LocationAccuracy.high,\n+    );\n+  }\n+\n+  void submitRegistration(BuildContext context) {\n+    debugPrint(\"ğŸ”¥ submitRegistration called\");\n+\n+    // This method will now call initiatePhoneVerificationAndCollectData\n+    // as OTP verification is mandatory.\n+\n+    // Ø¥Ø¶Ø§ÙØ© Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù…Ù† Ø§Ù„ØªØ¬Ù…ÙŠØ¯\n+    _startSafetyTimeout();\n+\n+    debugPrint(\"About to call initiatePhoneVerificationAndCollectData...\");\n+    initiatePhoneVerificationAndCollectData();\n+    debugPrint(\"initiatePhoneVerificationAndCollectData call completed\");\n+  }\n+\n+  // Ø¢Ù„ÙŠØ© Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¬Ù…ÙŠØ¯ Ø¹Ù„Ù‰ iOS\n+  Timer? _safetyTimer;\n+\n+  void _startSafetyTimeout() {\n+    _safetyTimer = Timer(Duration(seconds: Platform.isIOS ? 60 : 90), () {\n+      if ((isLoading.value || isOtpSending.value) && !isOtpVerifying.value) {\n+        debugPrint(\"Safety timeout triggered - resetting loading states\");\n+        isLoading.value = false;\n+        isOtpSending.value = false;\n+        isOtpVerifying.value = false;\n+        update();\n+        Get.snackbar(\n+          \"Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ù‡Ù„Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©\",\n+          \"ØªÙ… Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ù„Ø¹Ù…Ù„ÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n+          backgroundColor: Colors.orange.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+        );\n+      }\n+    });\n+  }\n+\n+  void _cancelSafetyTimeout() {\n+    _safetyTimer?.cancel();\n+    _safetyTimer = null;\n+  }\n+\n+  /// Ø¯Ø§Ù„Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM Token Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡\n+  Future<String?> _getFCMTokenSafely() async {\n+    debugPrint(\"ğŸ”‘ Starting FCM token retrieval process...\");\n+\n+    try {\n+      // 1. Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹\n+      debugPrint(\"ğŸ“± Requesting Firebase Messaging permissions...\");\n+      NotificationSettings settings = await _firebaseMessaging\n+          .requestPermission(\n+            alert: true,\n+            announcement: false,\n+            badge: true,\n+            carPlay: false,\n+            criticalAlert: false,\n+            provisional: false,\n+            sound: true,\n+          );\n+\n+      debugPrint(\"ğŸ”” Permission status: ${settings.authorizationStatus}\");\n+\n+      if (settings.authorizationStatus == AuthorizationStatus.denied) {\n+        debugPrint(\"âŒ Notification permissions denied\");\n+        return null;\n+      }\n+\n+      // 2. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªØ¸Ø§Ø± APNS\n+      debugPrint(\n+        \"ğŸš€ Attempting direct FCM token retrieval (bypass APNS dependency)...\",\n+      );\n+\n+      String? fcmToken;\n+      int directAttempts = 0;\n+      const maxDirectAttempts = 3;\n+\n+      while (fcmToken == null && directAttempts < maxDirectAttempts) {\n+        directAttempts++;\n+        debugPrint(\"ğŸ”„ Direct FCM attempt $directAttempts/$maxDirectAttempts\");\n+\n+        try {\n+          // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªØ¸Ø§Ø± APNS\n+          fcmToken = await _firebaseMessaging.getToken().timeout(\n+            Duration(seconds: 20 + (10 * directAttempts)),\n+            onTimeout: () => null,\n+          );\n+\n+          if (fcmToken != null && fcmToken.isNotEmpty) {\n+            debugPrint(\"âœ… Direct FCM Token received successfully!\");\n+            debugPrint(\"ğŸ”‘ Token preview: ${fcmToken.substring(0, 50)}...\");\n+            await _cacheFCMToken(fcmToken);\n+            return fcmToken;\n+          }\n+        } catch (e) {\n+          debugPrint(\"âš ï¸ Direct FCM attempt $directAttempts failed: $e\");\n+          // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…Ø´ÙƒÙ„Ø© APNSØŒ ØªØ§Ø¨Ø¹\n+          if (!e.toString().toLowerCase().contains('apns')) {\n+            await Future.delayed(Duration(seconds: directAttempts * 2));\n+            continue;\n+          }\n+        }\n+\n+        // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù‡Ù†Ø§ØŒ ÙØ§Ù„Ù…Ø´ÙƒÙ„Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ APNS\n+        break;\n+      }\n+\n+      // 3. Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ Ø¬Ø±Ø¨ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ© Ù…Ø¹ APNS\n+      if (fcmToken == null && Platform.isIOS) {\n+        debugPrint(\"ğŸ Fallback to APNS-dependent approach...\");\n+\n+        // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ù† native code\n+        debugPrint(\"ğŸ“² Triggering native notification registration...\");\n+\n+        // Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù†Ø¸Ø§Ù…\n+        await Future.delayed(const Duration(seconds: 5));\n+\n+        // Ù…Ø­Ø§ÙˆÙ„Ø© APNS Ù…Ø­Ø¯ÙˆØ¯Ø©\n+        String? apnsToken;\n+        for (int attempt = 1; attempt <= 3; attempt++) {\n+          debugPrint(\"ğŸ”„ APNS attempt $attempt/3\");\n+\n+          try {\n+            await Future.delayed(Duration(seconds: attempt * 3));\n+            apnsToken = await _firebaseMessaging.getAPNSToken();\n+            if (apnsToken != null) {\n+              debugPrint(\n+                \"âœ… APNS Token received: ${apnsToken.substring(0, 20)}...\",\n+              );\n+              break;\n+            }\n+          } catch (e) {\n+            debugPrint(\"âš ï¸ APNS attempt $attempt failed: $e\");\n+          }\n+        }\n+\n+        // 4. Ù…Ø­Ø§ÙˆÙ„Ø© FCM Ù…Ø±Ø© Ø£Ø®ÙŠØ±Ø©\n+        if (apnsToken != null) {\n+          debugPrint(\"ğŸ”‘ Final FCM token attempt with APNS...\");\n+\n+          try {\n+            fcmToken = await _firebaseMessaging.getToken().timeout(\n+              const Duration(seconds: 30),\n+              onTimeout: () => null,\n+            );\n+\n+            if (fcmToken != null && fcmToken.isNotEmpty) {\n+              debugPrint(\"âœ… FCM Token received after APNS setup!\");\n+              await _cacheFCMToken(fcmToken);\n+              return fcmToken;\n+            }\n+          } catch (e) {\n+            debugPrint(\"âš ï¸ Final FCM attempt failed: $e\");\n+          }\n+        }\n+      }\n+\n+      // 5. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ù…Ù† cache\n+      debugPrint(\"â™»ï¸ Trying cached token...\");\n+      String? cachedToken = await _getCachedFCMToken();\n+\n+      if (cachedToken != null) {\n+        debugPrint(\"âœ… Using cached FCM token\");\n+        return cachedToken;\n+      }\n+\n+      // 6. Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ„ Ø´ÙŠØ¡ØŒ Ø¥Ù†Ø´Ø§Ø¡ placeholder token Ù„Ù„ØªØ·ÙˆÙŠØ±\n+      if (Platform.isIOS) {\n+        debugPrint(\"ğŸ› ï¸ Creating development placeholder token...\");\n+        String placeholderToken = await _createDevelopmentToken();\n+        if (placeholderToken.isNotEmpty) {\n+          debugPrint(\n+            \"ğŸ”§ Using development token: ${placeholderToken.substring(0, 30)}...\",\n+          );\n+          await _cacheFCMToken(placeholderToken);\n+          return placeholderToken;\n+        }\n+      }\n+\n+      debugPrint(\"âŒ All FCM token retrieval methods failed\");\n+      return null;\n+    } catch (e) {\n+      debugPrint(\"ğŸš¨ Fatal error in FCM token retrieval: $e\");\n+      debugPrint(\"ğŸ“Š Error details: ${e.toString()}\");\n+\n+      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®ÙŠØ±Ø© Ù…Ø¹ cached token\n+      String? cachedToken = await _getCachedFCMToken();\n+      if (cachedToken != null) {\n+        debugPrint(\"â™»ï¸ Emergency fallback to cached token\");\n+        return cachedToken;\n+      }\n+\n+      return null;\n+    }\n+  }\n+\n+  /// Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ·ÙˆÙŠØ± Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙØ´Ù„ APNS\n+  Future<String> _createDevelopmentToken() async {\n+    try {\n+      final User? currentUser = _auth.currentUser;\n+      final String deviceId =\n+          currentUser?.uid ?? DateTime.now().millisecondsSinceEpoch.toString();\n+      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();\n+\n+      // Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª ÙØ±ÙŠØ¯ Ù„Ù„Ø¬Ù‡Ø§Ø²\n+      String developmentToken = \"dev_token_ios_${deviceId}_$timestamp\";\n+\n+      debugPrint(\"ğŸ”§ Generated development token for testing\");\n+      return developmentToken;\n+    } catch (e) {\n+      debugPrint(\"âš ï¸ Failed to create development token: $e\");\n+      return \"\";\n+    }\n+  }\n+\n+  /// Ø­ÙØ¸ FCM token ÙÙŠ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©\n+  Future<void> _cacheFCMToken(String token) async {\n+    try {\n+      final box = GetStorage();\n+      await box.write('cached_fcm_token', token);\n+      await box.write(\n+        'fcm_token_timestamp',\n+        DateTime.now().millisecondsSinceEpoch,\n+      );\n+      debugPrint(\"ğŸ’¾ FCM token cached successfully\");\n+    } catch (e) {\n+      debugPrint(\"âš ï¸ Failed to cache FCM token: $e\");\n+    }\n+  }\n+\n+  /// Ø§Ø³ØªØ±Ø¯Ø§Ø¯ FCM token Ù…Ù† Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©\n+  Future<String?> _getCachedFCMToken() async {\n+    try {\n+      final box = GetStorage();\n+      String? cachedToken = box.read('cached_fcm_token');\n+      int? timestamp = box.read('fcm_token_timestamp');\n+\n+      if (cachedToken != null && timestamp != null) {\n+        // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ù…Ø± Ø§Ù„Ù€ token (ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 7 Ø£ÙŠØ§Ù…)\n+        DateTime tokenDate = DateTime.fromMillisecondsSinceEpoch(timestamp);\n+        Duration age = DateTime.now().difference(tokenDate);\n+\n+        if (age.inDays < 7) {\n+          debugPrint(\n+            \"â™»ï¸ Found valid cached FCM token (age: ${age.inHours} hours)\",\n+          );\n+          return cachedToken;\n+        } else {\n+          debugPrint(\n+            \"â° Cached FCM token is too old (${age.inDays} days), ignoring\",\n+          );\n+        }\n+      }\n+\n+      return null;\n+    } catch (e) {\n+      debugPrint(\"âš ï¸ Failed to retrieve cached FCM token: $e\");\n+      return null;\n+    }\n+  }\n+\n+  /// ØªØ­Ø¯ÙŠØ« FCM Token ÙÙŠ Firestore Ù„Ø§Ø­Ù‚Ø§Ù‹ (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù…Ù† Ù…ÙƒØ§Ù† Ø¢Ø®Ø±)\n+  Future<void> updateFCMTokenInFirestore() async {\n+    try {\n+      final User? currentUser = _auth.currentUser;\n+      if (currentUser == null) {\n+        debugPrint(\"âš ï¸ No current user to update FCM token for\");\n+        return;\n+      }\n+\n+      debugPrint(\"ğŸ”„ Attempting to update FCM token in Firestore...\");\n+      final String? fcmToken = await _getFCMTokenSafely();\n+\n+      if (fcmToken != null && fcmToken.isNotEmpty) {\n+        await _firestore\n+            .collection(FirebaseX.collectionSeller)\n+            .doc(currentUser.uid)\n+            .update({\n+              'fcmToken': fcmToken,\n+              'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n+              'fcmTokenStatus': 'active',\n+            });\n+\n+        debugPrint(\"âœ… FCM Token updated successfully in Firestore\");\n+        Get.snackbar(\n+          \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«\",\n+          \"ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø±Ù Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­\",\n+          backgroundColor: Colors.green.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+          duration: const Duration(seconds: 2),\n+        );\n+      } else {\n+        debugPrint(\"âŒ Failed to get FCM token for update\");\n+      }\n+    } catch (e) {\n+      debugPrint(\"ğŸš¨ Error updating FCM token in Firestore: $e\");\n+    }\n+  }\n+\n+  /// Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù‘Ù†Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯ Ø£ÙØ¶Ù„ Ù„Ù€ iOS\n+  Future<String?> _getIOSOptimizedFCMToken() async {\n+    debugPrint(\"ğŸ Starting iOS-optimized FCM token retrieval...\");\n+\n+    try {\n+      // 1. Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø¸Ø§Ù…\n+      await Future.delayed(const Duration(seconds: 5));\n+\n+      // 2. Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ù€ remote notifications ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…Ø³Ø¬Ù„Ø§Ù‹\n+      debugPrint(\"ğŸ“± Ensuring iOS remote notification registration...\");\n+\n+      // 3. Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n+      NotificationSettings settings = await _firebaseMessaging\n+          .requestPermission(\n+            alert: true,\n+            announcement: false,\n+            badge: true,\n+            carPlay: false,\n+            criticalAlert: false,\n+            provisional: false,\n+            sound: true,\n+          );\n+\n+      if (settings.authorizationStatus != AuthorizationStatus.authorized) {\n+        debugPrint(\n+          \"âŒ iOS Notifications not authorized: ${settings.authorizationStatus}\",\n+        );\n+        return null;\n+      }\n+\n+      // 4. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ø¹ Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„\n+      for (int attempt = 1; attempt <= 3; attempt++) {\n+        debugPrint(\"ğŸ”‘ iOS FCM token attempt $attempt/3\");\n+\n+        try {\n+          // Ø§Ù†ØªØ¸Ø§Ø± Ù…ØªØ²Ø§ÙŠØ¯ Ù…Ø¹ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©\n+          await Future.delayed(Duration(seconds: 3 * attempt));\n+\n+          String? token = await _firebaseMessaging.getToken().timeout(\n+            Duration(seconds: 60 + (10 * attempt)), // Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„ Ù…Ø¹ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©\n+          );\n+\n+          if (token != null && token.isNotEmpty) {\n+            debugPrint(\"âœ… iOS FCM token received on attempt $attempt!\");\n+            return token;\n+          }\n+        } catch (e) {\n+          debugPrint(\"âš ï¸ iOS FCM attempt $attempt failed: $e\");\n+          if (e.toString().toLowerCase().contains('apns')) {\n+            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø®Ø·Ø£ APNSØŒ Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„\n+            await Future.delayed(Duration(seconds: 5 * attempt));\n+          }\n+        }\n+      }\n+\n+      return null;\n+    } catch (e) {\n+      debugPrint(\"ğŸš¨ iOS FCM token retrieval failed: $e\");\n+      return null;\n+    }\n+  }\n+\n+  /// Ù…Ø³Ø§Ø¹Ø¯ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n+  void retryFCMTokenLater() {\n+    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ 30 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰\n+    Timer(const Duration(seconds: 30), () {\n+      debugPrint(\"ğŸ”„ Retrying FCM token retrieval after 30 seconds...\");\n+      updateFCMTokenInFirestore();\n+    });\n+\n+    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø®Ø§ØµØ© Ø¨Ù€ iOS Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©\n+    if (Platform.isIOS) {\n+      Timer(const Duration(minutes: 1), () async {\n+        debugPrint(\"ğŸ iOS-specific FCM token retry after 1 minute...\");\n+        final token = await _getIOSOptimizedFCMToken();\n+        if (token != null) {\n+          try {\n+            final User? currentUser = _auth.currentUser;\n+            if (currentUser != null) {\n+              await _firestore\n+                  .collection(FirebaseX.collectionSeller)\n+                  .doc(currentUser.uid)\n+                  .update({\n+                    'fcmToken': token,\n+                    'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n+                    'fcmTokenStatus': 'active',\n+                  });\n+              debugPrint(\"âœ… iOS FCM Token updated successfully in retry!\");\n+            }\n+          } catch (e) {\n+            debugPrint(\"âŒ Failed to update iOS FCM token in retry: $e\");\n+          }\n+        }\n+      });\n+    }\n+\n+    // Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ† Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ø£ÙˆÙ„Ù‰\n+    Timer(const Duration(minutes: 2), () {\n+      debugPrint(\"ğŸ”„ Second retry attempt for FCM token after 2 minutes...\");\n+      updateFCMTokenInFirestore();\n+    });\n+\n+    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®ÙŠØ±Ø© Ø¨Ø¹Ø¯ 5 Ø¯Ù‚Ø§Ø¦Ù‚\n+    Timer(const Duration(minutes: 5), () {\n+      debugPrint(\"ğŸ”„ Final retry attempt for FCM token after 5 minutes...\");\n+      updateFCMTokenInFirestore();\n+    });\n+  }\n+}\n+\n+/// iOS-specific Firebase Storage handler to fix image upload issues\n+class IOSFirebaseStorageHandler {\n+  final FirebaseStorage _storage;\n+\n+  IOSFirebaseStorageHandler(this._storage);\n+\n+  Future<String?> uploadFile(File file, String path) async {\n+    try {\n+      debugPrint(\"ğŸ iOS Storage Handler: Starting upload to: $path\");\n+\n+      // Wait longer for Firebase to be fully ready on iOS\n+      await Future.delayed(Duration(milliseconds: 5000));\n+\n+      // Verify Firebase is properly initialized\n+      if (Firebase.apps.isEmpty) {\n+        throw Exception(\"Firebase not initialized\");\n+      }\n+\n+      // Test Firebase Storage connection first\n+      try {\n+        _storage.ref().child(\n+          \"connection_test_${DateTime.now().millisecondsSinceEpoch}\",\n+        );\n+        debugPrint(\"ğŸ Testing Firebase Storage connection...\");\n+        // Just create a reference, don't upload\n+        debugPrint(\"âœ… Firebase Storage connection test passed\");\n+      } catch (e) {\n+        debugPrint(\"âŒ Firebase Storage connection test failed: $e\");\n+        throw Exception(\"Firebase Storage not accessible: $e\");\n+      }\n+\n+      // Verify file exists and is readable\n+      if (!await file.exists()) {\n+        throw Exception(\"File does not exist at path: ${file.path}\");\n+      }\n+\n+      final fileSize = await file.length();\n+      debugPrint(\"ğŸ iOS Storage Handler: File size: $fileSize bytes\");\n+\n+      if (fileSize == 0) {\n+        throw Exception(\"File is empty\");\n+      }\n+\n+      // Use simple path first - try without modifications\n+      debugPrint(\"ğŸ iOS Storage Handler: Trying direct upload to: $path\");\n+\n+      final ref = _storage.ref().child(path);\n+\n+      // Set proper metadata for iOS\n+      final metadata = SettableMetadata(\n+        contentType: _getContentType(file.path),\n+        customMetadata: {\n+          'uploaded_by': 'ios_seller_registration',\n+          'original_path': path,\n+          'upload_timestamp': DateTime.now().millisecondsSinceEpoch.toString(),\n+        },\n+      );\n+\n+      debugPrint(\"ğŸ iOS Storage Handler: Creating upload task...\");\n+      final uploadTask = ref.putFile(file, metadata);\n+\n+      // Monitor progress\n+      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n+        if (snapshot.totalBytes > 0) {\n+          final progress =\n+              snapshot.bytesTransferred / snapshot.totalBytes * 100;\n+          debugPrint(\"ğŸ iOS Upload progress: ${progress.toStringAsFixed(1)}%\");\n+        }\n+      });\n+\n+      debugPrint(\"ğŸ iOS Storage Handler: Waiting for upload completion...\");\n+      final snapshot = await uploadTask.whenComplete(() {});\n+\n+      debugPrint(\"ğŸ iOS Storage Handler: Getting download URL...\");\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"âœ… iOS Upload successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"âŒ iOS Storage Handler error: $e\");\n+\n+      // Try alternative upload method for iOS\n+      return await _alternativeUploadMethod(file, path);\n+    }\n+  }\n+\n+  Future<String?> _alternativeUploadMethod(File file, String path) async {\n+    // Try multiple alternative approaches for iOS\n+\n+    // Method 1: putData instead of putFile\n+    try {\n+      debugPrint(\"ğŸ”„ iOS Alternative Method 1: Using putData...\");\n+      await Future.delayed(Duration(milliseconds: 3000));\n+\n+      final bytes = await file.readAsBytes();\n+      debugPrint(\"ğŸ”„ iOS Read ${bytes.length} bytes from file\");\n+\n+      final ref = _storage.ref().child(path);\n+      final uploadTask = ref.putData(\n+        bytes,\n+        SettableMetadata(\n+          contentType: _getContentType(file.path),\n+          customMetadata: {\n+            'uploaded_by': 'ios_alternative_putdata',\n+            'original_path': path,\n+          },\n+        ),\n+      );\n+\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"âœ… iOS Alternative Method 1 successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"âŒ iOS Alternative Method 1 failed: $e\");\n+    }\n+\n+    // Method 2: Different path structure\n+    try {\n+      debugPrint(\"ğŸ”„ iOS Alternative Method 2: Different path structure...\");\n+      await Future.delayed(Duration(milliseconds: 3000));\n+\n+      final timestamp = DateTime.now().millisecondsSinceEpoch;\n+      final altPath = \"mobile_uploads/${path.replaceAll('/', '_')}_$timestamp\";\n+\n+      debugPrint(\"ğŸ”„ iOS Alternative path: $altPath\");\n+\n+      final bytes = await file.readAsBytes();\n+      final ref = _storage.ref().child(altPath);\n+\n+      final uploadTask = ref.putData(\n+        bytes,\n+        SettableMetadata(\n+          contentType: _getContentType(file.path),\n+          customMetadata: {\n+            'uploaded_by': 'ios_alternative_path',\n+            'original_path': path,\n+          },\n+        ),\n+      );\n+\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"âœ… iOS Alternative Method 2 successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"âŒ iOS Alternative Method 2 failed: $e\");\n+    }\n+\n+    // Method 3: Very simple path\n+    try {\n+      debugPrint(\"ğŸ”„ iOS Alternative Method 3: Simple upload...\");\n+      await Future.delayed(Duration(milliseconds: 5000));\n+\n+      final simplePath = \"uploads/${DateTime.now().millisecondsSinceEpoch}\";\n+      debugPrint(\"ğŸ”„ iOS Simple path: $simplePath\");\n+\n+      final bytes = await file.readAsBytes();\n+      final ref = _storage.ref().child(simplePath);\n+\n+      final uploadTask = ref.putData(bytes);\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"âœ… iOS Alternative Method 3 successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"âŒ iOS Alternative Method 3 failed: $e\");\n+    }\n+\n+    debugPrint(\"âŒ All iOS alternative upload methods failed\");\n+    return null;\n+  }\n+\n+  String _getContentType(String filePath) {\n+    final extension = filePath.toLowerCase().split('.').last;\n+    switch (extension) {\n+      case 'jpg':\n+      case 'jpeg':\n+        return 'image/jpeg';\n+      case 'png':\n+        return 'image/png';\n+      case 'gif':\n+        return 'image/gif';\n+      case 'webp':\n+        return 'image/webp';\n+      default:\n+        return 'image/jpeg'; // Default fallback\n+    }\n+  }\n+}\n"
                },
                {
                    "date": 1752570376950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -815,10 +815,12 @@\n               0,\n             ), // ØªÙ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† location Ù‡Ùˆ GeoPoint ÙÙŠ _tempSellerDataForSubmission\n         shopAddressText:\n             _tempSellerDataForSubmission?['shopAddressText'] as String?,\n-        shopCategory:\n-            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'Ø£Ø®Ø±Ù‰',\n+        shopCategories:\n+            (_tempSellerDataForSubmission?['shopCategories'] as List<dynamic>?)\n+                ?.cast<String>() ??\n+            ['Ø£Ø®Ø±Ù‰'],\n         workingHours: Map<String, dynamic>.from(\n           _tempSellerDataForSubmission?['workingHours'] ?? {},\n         ),\n         // Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªØ§Ù„ÙŠØ© Ø§Ø®ØªÙŠØ§Ø±ÙŠØ© ÙÙŠ SellerModel ÙˆØ³ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡Ø§ Ø¥Ù„Ù‰ null Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ _tempSellerDataForSubmission\n@@ -2045,2052 +2047,4 @@\n         return 'image/jpeg'; // Default fallback\n     }\n   }\n }\n-import 'dart:io';\n-import 'dart:async';\n-import 'package:cloud_firestore/cloud_firestore.dart';\n-import 'package:codora/%D8%A7%D9%84%D9%83%D9%88%D8%AF%20%D8%A7%D9%84%D8%AE%D8%A7%D8%B5%20%D8%A8%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%20%D8%A7%D9%84%D8%A8%D8%A7%D8%A6%D8%B9/seller_app_auth/controllers/seller_auth_controller.dart';\n-import 'package:firebase_auth/firebase_auth.dart';\n-import 'package:firebase_storage/firebase_storage.dart';\n-import 'package:firebase_messaging/firebase_messaging.dart';\n-import 'package:firebase_core/firebase_core.dart';\n-import 'package:flutter/material.dart';\n-import 'package:geolocator/geolocator.dart';\n-import 'package:get/get.dart';\n-import 'package:get_storage/get_storage.dart';\n-import 'package:google_maps_flutter/google_maps_flutter.dart';\n-import 'package:image_picker/image_picker.dart';\n-import 'package:intl/intl.dart'; // For DateFormat\n-import 'package:geocoding/geocoding.dart' as geo;\n-\n-import '../../../XXX/xxx_firebase.dart';\n-import '../../../Model/SellerModel.dart';\n-import '../../ui/seller_main_screen.dart';\n-import '../ui/OtpVerificationScreen.dart';\n-import '../ui/LocationPickerScreen.dart';\n-\n-class SellerRegistrationController extends GetxController {\n-  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n-  RxDouble currentPositionAccuracy = 0.0.obs;\n-\n-  // --- Firebase Instances ---\n-  final FirebaseAuth _auth = FirebaseAuth.instance;\n-  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n-  final FirebaseStorage _storage = FirebaseStorage.instance;\n-  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n-  final RxString verificationId = ''.obs; // To store Firebase's verification ID\n-\n-  // iOS-specific Firebase Storage handler\n-  late IOSFirebaseStorageHandler _iosStorageHandler;\n-\n-  // ==========================================================================\n-  // ==========================================================================\n-  // ==========================================================================\n-\n-  // Ù„Ø¥Ø¶Ø§ÙØ© Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹\n-  String? _sellerTypeFromAuth; // Ø³ÙŠØªÙ… Ø¬Ù„Ø¨ Ù‡Ø°Ø§ Ù…Ù† SellerAuthController\n-\n-  final Rxn<int> resendToken = Rxn<int>(null); // For resending OTP\n-  final TextEditingController otpController = TextEditingController();\n-  final RxBool isOtpSending = false.obs; // Loading state for OTP sending\n-  final RxBool isOtpVerifying = false.obs; // Loading state for OTP verification\n-  Map<String, dynamic>? _tempSellerDataForSubmission;\n-  File? _tempSellerProfileImageFile;\n-  File? _tempShopFrontImageFile;\n-\n-  // --- Text Editing Controllers ---\n-  final TextEditingController sellerNameController = TextEditingController();\n-  final TextEditingController shopNameController = TextEditingController();\n-  final TextEditingController shopPhoneNumberController =\n-      TextEditingController();\n-  final TextEditingController shopDescriptionController =\n-      TextEditingController();\n-  // Add more controllers for other text fields like commercial reg no., etc.\n-\n-  // --- Image Pickers ---\n-  final ImagePicker _picker = ImagePicker();\n-  final Rxn<File> sellerProfileImageFile = Rxn<File>(null);\n-  final Rxn<File> shopFrontImageFile = Rxn<File>(null);\n-\n-  // --- Location ---\n-  final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n-  final RxString shopAddressText = ''.obs;\n-  GoogleMapController? mapController;\n-\n-  // --- Working Hours ---\n-  final List<String> dayKeys = [\n-    \"sunday_en\",\n-    \"monday_en\",\n-    \"tuesday_en\",\n-    \"wednesday_en\",\n-    \"thursday_en\",\n-    \"friday_en\",\n-    \"saturday_en\",\n-  ];\n-  final RxnString expandedDayPanel = RxnString(null); // For ExpansionPanelList\n-\n-  final RxMap<String, Map<String, dynamic>> workingHours =\n-      <String, Map<String, dynamic>>{\n-        \"sunday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø£Ø­Ø¯\",\n-        },\n-        \"monday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø§Ø«Ù†ÙŠÙ†\",\n-        },\n-        \"tuesday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡\",\n-        },\n-        \"wednesday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡\",\n-        },\n-        \"thursday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø®Ù…ÙŠØ³\",\n-        },\n-        \"friday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø¬Ù…Ø¹Ø©\",\n-        },\n-        \"saturday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"Ø§Ù„Ø³Ø¨Øª\",\n-        },\n-      }.obs;\n-  final RxnString _lastAppliedOpensAt = RxnString(null);\n-  final RxnString _lastAppliedClosesAt = RxnString(null);\n-  // --- Main Categories ---\n-  // Ù‚Ø§Ø¦Ù…Ø© Ø´Ø§Ù…Ù„Ø© Ø¨Ø¬Ù…ÙŠØ¹ ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ§Ø¬Ø± Ø§Ù„Ù…Ù…ÙƒÙ†Ø©\n-  final List<String> shopCategories = [\n-    \"Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ§Øª ÙˆÙ…Ø¹Ø¯Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n-    \"Ù…Ù„Ø§Ø¨Ø³ ÙˆØ£Ø²ÙŠØ§Ø¡\",\n-    \"Ø£Ø­Ø°ÙŠØ© ÙˆØ­Ù‚Ø§Ø¦Ø¨\",\n-    \"Ø·Ø¹Ø§Ù… ÙˆÙ…Ø´Ø±ÙˆØ¨Ø§Øª\",\n-    \"Ù…Ù†ØªØ¬Ø§Øª ØµØ­ÙŠØ© ÙˆØªØ¬Ù…ÙŠÙ„\",\n-    \"Ø£Ø¯ÙˆÙŠØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª Ø·Ø¨ÙŠØ©\",\n-    \"ÙƒØªØ¨ ÙˆÙ…ÙˆØ§Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠØ©\",\n-    \"Ø£Ù„Ø¹Ø§Ø¨ ÙˆØªØ±ÙÙŠÙ‡\",\n-    \"Ø±ÙŠØ§Ø¶Ø© ÙˆÙ„ÙŠØ§Ù‚Ø©\",\n-    \"Ø£Ø¯ÙˆØ§Øª Ù…Ù†Ø²Ù„ÙŠØ© ÙˆÙ…Ø·Ø¨Ø®\",\n-    \"Ø£Ø«Ø§Ø« ÙˆØ¯ÙŠÙƒÙˆØ±\",\n-    \"Ø­Ø¯Ø§Ø¦Ù‚ ÙˆÙ†Ø¨Ø§ØªØ§Øª\",\n-    \"Ø³ÙŠØ§Ø±Ø§Øª ÙˆÙ‚Ø·Ø¹ ØºÙŠØ§Ø±\",\n-    \"Ø£Ø¯ÙˆØ§Øª ÙˆØ¹Ø¯Ø¯ ÙŠØ¯ÙˆÙŠØ©\",\n-    \"Ù…ÙˆØ§Ø¯ Ø¨Ù†Ø§Ø¡ ÙˆØªØ´ÙŠÙŠØ¯\",\n-    \"Ù…Ø¬ÙˆÙ‡Ø±Ø§Øª ÙˆØ³Ø§Ø¹Ø§Øª\",\n-    \"Ù‡Ø¯Ø§ÙŠØ§ ÙˆØªØ­Ù\",\n-    \"Ø£Ø·ÙØ§Ù„ ÙˆÙ…ÙˆØ§Ù„ÙŠØ¯\",\n-    \"Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø£Ù„ÙŠÙØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª\",\n-    \"Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆØ¢Ù„Ø§Øª Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©\",\n-    \"Ø®Ø¯Ù…Ø§Øª Ù…Ù‡Ù†ÙŠØ©\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØªÙˆØµÙŠÙ„\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØªÙ†Ø¸ÙŠÙ\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØµÙŠØ§Ù†Ø©\",\n-    \"Ù…ÙˆØ§Ø¯ ØºØ°Ø§Ø¦ÙŠØ© Ø¹Ø¶ÙˆÙŠØ©\",\n-    \"Ø­Ø±Ù ÙŠØ¯ÙˆÙŠØ© ÙˆÙÙ†ÙˆÙ†\",\n-    \"Ø£Ù‚Ù…Ø´Ø© ÙˆØ®ÙŠØ§Ø·Ø©\",\n-    \"Ø¹Ø·ÙˆØ± ÙˆÙ…ÙˆØ§Ø¯ ØªØ¬Ù…ÙŠÙ„\",\n-    \"Ø£Ø®Ø±Ù‰\",\n-  ];\n-\n-  // Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 6 ÙØ¦Ø§Øª)\n-  final RxList<String> selectedShopCategories = <String>[].obs;\n-  final int maxCategoriesAllowed = 6;\n-\n-  // --- Loading State ---\n-  final RxBool isLoading = false.obs;\n-\n-  @override\n-  void onInit() {\n-    super.onInit();\n-\n-    // Initialize iOS-specific storage handler\n-    if (Platform.isIOS) {\n-      _iosStorageHandler = IOSFirebaseStorageHandler(_storage);\n-    }\n-\n-    // Ø¬Ù„Ø¨ SellerAuthController ÙˆØ§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ sellerType\n-    try {\n-      final SellerAuthController authController =\n-          Get.find<SellerAuthController>();\n-      _sellerTypeFromAuth = authController.sellerType;\n-      if (_sellerTypeFromAuth != null) {\n-        debugPrint(\n-          \"SellerRegistrationController: ØªÙ… Ø¬Ù„Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù…Ù† AuthController: $_sellerTypeFromAuth\",\n-        );\n-      } else {\n-        debugPrint(\n-          \"SellerRegistrationController: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ sellerType ÙÙŠ AuthController. Ù‚Ø¯ ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø¹ÙˆØ¯Ø© ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹.\",\n-        );\n-        // ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù„ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø°Ø§ ÙƒØ§Ù† sellerType Ø¶Ø±ÙˆØ±ÙŠÙ‹Ø§ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† null\n-        // Ù…Ø«Ø§Ù„: Get.offAll(() => SellerTypeSelectionScreen()); Ø£Ùˆ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£\n-      }\n-    } catch (e) {\n-      debugPrint(\n-        \"SellerRegistrationController: Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ SellerAuthController Ø£Ùˆ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ sellerType: $e\",\n-      );\n-      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ø±Ø¨Ù…Ø§ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø©\n-    }\n-  }\n-\n-  @override\n-  void onClose() {\n-    sellerNameController.dispose();\n-    shopNameController.dispose();\n-    shopPhoneNumberController.dispose();\n-    shopDescriptionController.dispose();\n-    mapController?.dispose();\n-    otpController.dispose();\n-    super.onClose();\n-  }\n-\n-  void removeImage({required bool isProfileImage}) {\n-    if (isProfileImage) {\n-      sellerProfileImageFile.value = null;\n-    } else {\n-      shopFrontImageFile.value = null;\n-    }\n-    update(); // For GetBuilder if used, or just rely on Obx for reactive updates\n-  }\n-\n-  Future<void> initiatePhoneVerificationAndCollectData() async {\n-    debugPrint(\"ğŸš€ initiatePhoneVerificationAndCollectData called\");\n-    debugPrint(\"Form validation starting...\");\n-\n-    if (!formKey.currentState!.validate()) {\n-      debugPrint(\"âŒ Form validation failed\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"âœ… Form validation passed\");\n-\n-    // --- Add all your previous validations ---\n-    debugPrint(\"Checking profile image...\");\n-    if (sellerProfileImageFile.value == null) {\n-      debugPrint(\"âŒ No profile image selected\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ø´Ø®ØµÙŠØ©.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"âœ… Profile image validation passed\");\n-\n-    debugPrint(\"Checking shop front image...\");\n-    if (shopFrontImageFile.value == null) {\n-      debugPrint(\"âŒ No shop front image selected\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø­Ù„.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"âœ… Shop front image validation passed\");\n-\n-    debugPrint(\"Checking shop location...\");\n-    if (shopLocation.value == null) {\n-      debugPrint(\"âŒ No shop location selected\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ù„.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"âœ… Shop location validation passed\");\n-\n-    debugPrint(\"Checking shop category...\");\n-    if (selectedShopCategories.isEmpty) {\n-      debugPrint(\"âŒ No shop categories selected\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙØ¦Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„Ù„Ù…ØªØ¬Ø±.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\n-      \"âœ… Shop categories validation passed: ${selectedShopCategories.length} categories selected\",\n-    );\n-\n-    // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† _sellerTypeFromAuth ÙØ§Ø±ØºÙ‹Ø§ Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© (Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¥Ù„Ø²Ø§Ù…ÙŠÙ‹Ø§)\n-    debugPrint(\"Checking seller type...\");\n-    if (_sellerTypeFromAuth == null || _sellerTypeFromAuth!.isEmpty) {\n-      debugPrint(\"âŒ No seller type selected\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¬ÙˆØ¹ ÙˆØ§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹.\",\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"âœ… Seller type validation passed: $_sellerTypeFromAuth\");\n-\n-    debugPrint(\"Checking working hours...\");\n-    bool workingHoursValid = true;\n-    String firstInvalidDay = \"\";\n-    workingHours.forEach((key, value) {\n-      if ((value['isOpen'] == true) &&\n-          (value['opensAt'] == null || value['closesAt'] == null)) {\n-        workingHoursValid = false;\n-        firstInvalidDay = value['name_ar'] as String;\n-        return;\n-      }\n-    });\n-    if (!workingHoursValid) {\n-      debugPrint(\"âŒ Working hours validation failed for day: $firstInvalidDay\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ÙØªØ­ ÙˆØ§Ù„Ø¥ØºÙ„Ø§Ù‚ Ù„Ù„ÙŠÙˆÙ… Ø§Ù„Ù…ÙØªÙˆØ­: $firstInvalidDay.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"âœ… Working hours validation passed\");\n-\n-    String rawPhoneNumber = shopPhoneNumberController.text.trim();\n-    rawPhoneNumber = rawPhoneNumber.replaceAll(RegExp(r'\\s+'), '');\n-    if (rawPhoneNumber.startsWith('0')) {\n-      rawPhoneNumber = rawPhoneNumber.substring(1);\n-    }\n-    const String countryCode = \"+964\";\n-    final String formattedPhoneNumber = \"$countryCode$rawPhoneNumber\";\n-    debugPrint(\"Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ: ${shopPhoneNumberController.text}\");\n-    debugPrint(\n-      \"Ø§Ù„Ø±Ù‚Ù… Ø¨Ø¹Ø¯ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„ØµÙØ± ÙˆØ¥Ø¶Ø§ÙØ© Ø±Ù…Ø² Ø§Ù„Ø¯ÙˆÙ„Ø©: $formattedPhoneNumber\",\n-    );\n-\n-    final RegExp iraqiPhoneNumberRegExp = RegExp(r'^\\+9647[3-9]\\d{8}$');\n-    debugPrint(\"Checking phone number validation: $formattedPhoneNumber\");\n-    if (!iraqiPhoneNumberRegExp.hasMatch(formattedPhoneNumber)) {\n-      debugPrint(\"Phone number validation failed for: $formattedPhoneNumber\");\n-      Get.snackbar(\n-        \"Ø±Ù‚Ù… Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­\",\n-        \"Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¹Ø±Ø§Ù‚ÙŠ ØµØ­ÙŠØ­.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"Phone number validation passed\");\n-\n-    // ---- Set loading states ----\n-    debugPrint(\"Setting loading states...\");\n-    isOtpSending.value = true;\n-    isLoading.value = true;\n-    update();\n-    debugPrint(\"Loading states set successfully\");\n-\n-    try {\n-      debugPrint(\"Preparing temp data for submission...\");\n-      _tempSellerProfileImageFile = sellerProfileImageFile.value;\n-      _tempShopFrontImageFile = shopFrontImageFile.value;\n-      _tempSellerDataForSubmission = {\n-        \"sellerName\": sellerNameController.text.trim(),\n-        \"shopName\": shopNameController.text.trim(),\n-        \"shopPhoneNumber\": shopPhoneNumberController.text.trim(),\n-        \"shopDescription\": shopDescriptionController.text.trim(),\n-        \"location\": GeoPoint(\n-          shopLocation.value!.latitude,\n-          shopLocation.value!.longitude,\n-        ),\n-        \"shopAddressText\": shopAddressText.value,\n-        \"shopCategories\": selectedShopCategories.toList(),\n-        \"workingHours\": Map<String, Map<String, dynamic>>.from(workingHours),\n-        \"streetAddress\": streetAddressController.text.trim(),\n-      };\n-      debugPrint(\"Temp data prepared successfully\");\n-\n-      debugPrint(\n-        \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n-      );\n-      debugPrint(\"FirebaseAuth instance: $_auth\");\n-\n-      // ØªÙØ¹ÙŠÙ„ reCAPTCHA Ù„Ù„Ù€ iOS ØµØ±Ø§Ø­Ø©\n-      if (Platform.isIOS) {\n-        debugPrint(\"Setting up reCAPTCHA for iOS...\");\n-        try {\n-          // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±\n-          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n-\n-          await _auth.setSettings(\n-            appVerificationDisabledForTesting:\n-                isTestNumber, // Ù„Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ ÙÙ‚Ø·\n-            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA Ù„Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙÙ‚Ø·\n-          );\n-\n-          debugPrint(\"âœ… Firebase Auth settings configured for iOS\");\n-          debugPrint(\"ğŸ“± Test number mode: $isTestNumber\");\n-\n-          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚\n-          await Future.delayed(const Duration(milliseconds: 500));\n-        } catch (e) {\n-          debugPrint(\"âš ï¸ Error setting Firebase Auth settings: $e\");\n-          // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª reCAPTCHAØŒ Ø¬Ø±Ø¨ Ø¨Ø¯ÙˆÙ†Ù‡Ø§\n-          debugPrint(\"ğŸ”„ Trying without forced reCAPTCHA...\");\n-        }\n-      }\n-\n-      // Ø¥Ø¶Ø§ÙØ© timeout Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ù…Ù„ Ø§Ù„Ù€ callbacks\n-      Timer callbackTimeoutTimer = Timer(const Duration(seconds: 30), () {\n-        if (isOtpSending.value || isLoading.value) {\n-          debugPrint(\"âš ï¸ Callback timeout - reCAPTCHA may not have appeared\");\n-          debugPrint(\"âš ï¸ This usually means Firebase Console settings issue\");\n-          isOtpSending.value = false;\n-          isLoading.value = false;\n-          isOtpVerifying.value = false;\n-          update();\n-          Get.snackbar(\n-            \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚\",\n-            \"Ù„Ù… ØªØ¸Ù‡Ø± ØµÙØ­Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Firebase Ø£Ùˆ Ø¬Ø±Ø¨ Ø±Ù‚Ù…Ø§Ù‹ Ø¢Ø®Ø±.\",\n-            backgroundColor: Colors.orange.shade400,\n-            colorText: Colors.white,\n-            snackPosition: SnackPosition.BOTTOM,\n-            duration: const Duration(seconds: 5),\n-          );\n-        }\n-      });\n-\n-      await _auth.verifyPhoneNumber(\n-        phoneNumber: formattedPhoneNumber,\n-        forceResendingToken: resendToken.value,\n-        verificationCompleted: (PhoneAuthCredential credential) async {\n-          debugPrint(\"ğŸ‰ VERIFICATION COMPLETED CALLBACK TRIGGERED\");\n-          debugPrint(\n-            \"Phone auto-verified. Credential SMS code (if available): ${credential.smsCode}\",\n-          );\n-\n-          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n-          callbackTimeoutTimer.cancel();\n-\n-          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©\n-          isOtpSending.value = false;\n-          isLoading.value = true;\n-          isOtpVerifying.value = true;\n-          update();\n-\n-          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ UI Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¹Ù„Ù‰ iOS\n-          if (Platform.isIOS) {\n-            await Future.delayed(const Duration(milliseconds: 100));\n-          }\n-\n-          await _finalizeSellerRegistration(isAutoVerified: true);\n-        },\n-        verificationFailed: (FirebaseAuthException e) {\n-          debugPrint(\"âŒ VERIFICATION FAILED CALLBACK TRIGGERED\");\n-          debugPrint(\"Phone verification failed: ${e.code} - ${e.message}\");\n-          debugPrint(\"Full error: ${e.toString()}\");\n-\n-          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n-          callbackTimeoutTimer.cancel();\n-\n-          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª\n-          isOtpSending.value = false;\n-          isLoading.value = false;\n-          isOtpVerifying.value = false;\n-          update();\n-\n-          String errorMessage = \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ.\";\n-          if (e.code == 'invalid-phone-number') {\n-            errorMessage =\n-                \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ $formattedPhoneNumber Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ§Ù„Ø­.\";\n-          } else if (e.code == 'too-many-requests') {\n-            errorMessage =\n-                \"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.\";\n-          } else if (e.code == 'network-request-failed') {\n-            errorMessage =\n-                \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\";\n-          }\n-          Get.snackbar(\n-            \"Ø®Ø·Ø£\",\n-            errorMessage,\n-            backgroundColor: Colors.red.shade400,\n-            colorText: Colors.white,\n-            snackPosition: SnackPosition.BOTTOM,\n-          );\n-        },\n-        codeSent: (String verId, int? resendTok) async {\n-          debugPrint(\"ğŸ“± CODE SENT CALLBACK TRIGGERED\");\n-          debugPrint(\n-            \"OTP code sent. Verification ID: $verId, Resend Token: $resendTok\",\n-          );\n-\n-          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n-          callbackTimeoutTimer.cancel();\n-\n-          isOtpSending.value = false; // OTP sending part is done\n-          // isLoading remains true as we are waiting for OTP input\n-          update();\n-\n-          verificationId.value = verId;\n-          resendToken.value = resendTok;\n-\n-          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ø¹Ù„Ù‰ iOS Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ UI Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n-          if (Platform.isIOS) {\n-            await Future.delayed(const Duration(milliseconds: 200));\n-          }\n-\n-          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ØªÙ†Ù‚Ù„ ÙŠØ­Ø¯Ø« Ø¹Ù„Ù‰ Ø§Ù„Ù€ main thread\n-          WidgetsBinding.instance.addPostFrameCallback((_) {\n-            debugPrint(\"Navigating to OTP verification screen...\");\n-            Get.to(() => OtpVerificationScreen());\n-          });\n-        },\n-        codeAutoRetrievalTimeout: (String verId) {\n-          debugPrint(\"â° CODE AUTO RETRIEVAL TIMEOUT CALLBACK TRIGGERED\");\n-          debugPrint(\"OTP auto-retrieval timed out. Verification ID: $verId\");\n-          verificationId.value = verId;\n-          // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† isOtpSending ÙÙŠ Ø­Ø§Ù„ timeout Ø¹Ù„Ù‰ iOS\n-          if (Platform.isIOS) {\n-            isOtpSending.value = false;\n-            update();\n-          }\n-        },\n-        timeout:\n-            Platform.isIOS\n-                ? const Duration(seconds: 60) // Ù…Ø¯Ø© Ø£Ù‚ØµØ± Ø¹Ù„Ù‰ iOS\n-                : const Duration(seconds: 120), // Ù…Ø¯Ø© Ø£Ø·ÙˆÙ„ Ø¹Ù„Ù‰ Android\n-      );\n-      debugPrint(\"âœ… verifyPhoneNumber call completed successfully\");\n-    } catch (e) {\n-      debugPrint(\"ğŸš¨ EXCEPTION CAUGHT IN verifyPhoneNumber\");\n-      debugPrint(\"Exception type: ${e.runtimeType}\");\n-      debugPrint(\"Exception details: $e\");\n-\n-      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£\n-      isOtpSending.value = false;\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      update();\n-\n-      String errorMessage = \"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ.\";\n-\n-      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…Ø­Ø¯Ø¯Ø©\n-      if (e.toString().contains('network')) {\n-        errorMessage = \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.\";\n-      } else if (e.toString().contains('too-many-requests')) {\n-        errorMessage = \"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.\";\n-      }\n-\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        errorMessage,\n-        backgroundColor: Colors.red.shade500,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<void> verifyOtpAndFinalize(String otpCode) async {\n-    if (otpCode.isEmpty || otpCode.length < 6) {\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² OTP Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 6 Ø£Ø±Ù‚Ø§Ù….\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-\n-    isOtpVerifying.value = true;\n-    isLoading.value =\n-        true; // isLoading should ideally be true from the previous step\n-    update();\n-\n-    try {\n-      PhoneAuthCredential credential = PhoneAuthProvider.credential(\n-        verificationId: verificationId.value,\n-        smsCode: otpCode,\n-      );\n-\n-      // **** Ø®Ø·ÙˆØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ù€ Credential Ù‡Ù†Ø§ ****\n-      final User? currentUser = _auth.currentUser;\n-      if (currentUser == null) {\n-        throw FirebaseAuthException(\n-          code: 'no-current-user',\n-          message: 'No user is currently signed in.',\n-        );\n-      }\n-\n-      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ø¨Ø· Ø§Ù„Ù€ Credential Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† OTP\n-      try {\n-        await currentUser.linkWithCredential(credential);\n-        debugPrint(\"Phone credential linked successfully.\");\n-      } catch (linkError) {\n-        if (linkError is FirebaseAuthException &&\n-            linkError.code == 'provider-already-linked') {\n-          debugPrint(\n-            \"Phone provider already linked, verifying OTP directly...\",\n-          );\n-          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø²ÙˆØ¯ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù†ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© OTP ÙÙ‚Ø·\n-          await _auth.signInWithCredential(credential);\n-          debugPrint(\n-            \"OTP verified successfully with existing linked provider.\",\n-          );\n-        } else {\n-          rethrow; // Ø¥Ø¹Ø§Ø¯Ø© Ø·Ø±Ø­ Ø£ÙŠ Ø®Ø·Ø£ Ø¢Ø®Ø±\n-        }\n-      }\n-\n-      // Ø¥Ù„ØºØ§Ø¡ safety timeout Ù„Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù†Ø¬Ø­Øª\n-      _cancelSafetyTimeout();\n-\n-      // Ø¥Ø°Ø§ Ù†Ø¬Ø­ Ø§Ù„Ø±Ø¨Ø· Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n-      await _finalizeSellerRegistration(isOtpNowVerified: true);\n-    } on FirebaseAuthException catch (e) {\n-      isOtpVerifying.value = false;\n-      isLoading.value = false;\n-      update();\n-      debugPrint(\n-        \"FirebaseAuthException during OTP verification: ${e.code} - ${e.message}\",\n-      );\n-      String errorMessage = \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù…Ø² OTP.\";\n-      if (e.code == 'invalid-verification-code' ||\n-          e.code == 'invalid-credential') {\n-        errorMessage = \"Ø±Ù…Ø² OTP Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ­ÙŠØ­.\";\n-      } else if (e.code == 'session-expired') {\n-        errorMessage = \"Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø¬Ù„Ø³Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ Ø±Ù…Ø² Ø¬Ø¯ÙŠØ¯.\";\n-      } else if (e.code == 'credential-already-in-use') {\n-        // Ù‡Ø°Ù‡ Ø­Ø§Ù„Ø© Ø®Ø§ØµØ©: Ø§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ø­Ø³Ø§Ø¨ Ø¢Ø®Ø±. Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ù†ÙØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ Ù†Ø¬Ø§Ø­Ù‹Ø§.\n-        // Ù‡Ù†Ø§ØŒ Ù†ÙØªØ±Ø¶ Ø£Ù†Ù†Ø§ Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø©ØŒ ÙˆØ§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø· Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙÙ‡Ø°Ø§ Ø¬ÙŠØ¯.\n-        // ÙˆÙ„ÙƒÙ† Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø®ØªÙ„ÙØŒ ÙÙ‡Ø°Ù‡ Ù…Ø´ÙƒÙ„Ø©.\n-        // Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø³Ø§Ø·Ø©ØŒ Ø³Ù†Ø¹ØªØ¨Ø±Ù‡Ø§ Ø®Ø·Ø£ Ø¹Ø§Ù… Ø§Ù„Ø¢Ù†ØŒ ÙˆÙ„ÙƒÙ† ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ† Ù‡Ø°Ø§.\n-        // Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù†Ù‡ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙŠÙ…ÙƒÙ† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©.\n-        // Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£Ø¨Ø³Ø· Ù‡Ùˆ Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ ÙƒØ®Ø·Ø£ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ØªØ£ÙƒØ¯Ù‹Ø§ Ù…Ù† ÙƒÙŠÙÙŠØ© Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.\n-        // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ _finalizeSellerRegistration Ù‡Ù†Ø§ Ø£ÙŠØ¶Ù‹Ø§.\n-        // For now, treat as a specific error message or proceed if logic allows\n-        debugPrint(\n-          \"Credential already in use. Assuming for this user is okay or needs specific handling.\",\n-        );\n-        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­\n-        // await _finalizeSellerRegistration(isOtpNowVerified: true);\n-        // Get.snackbar(\"Ù…Ø¹Ù„ÙˆÙ…Ø©\", \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.\", snackPosition: SnackPosition.BOTTOM);\n-        // return;\n-        errorMessage =\n-            \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ø­Ø³Ø§Ø¨ÙƒØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù….\";\n-      } else if (e.code == 'no-current-user') {\n-        errorMessage =\n-            \"Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.\";\n-        // ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØµÙØ­Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„\n-      }\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        errorMessage,\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    } catch (e) {\n-      isOtpVerifying.value = false;\n-      isLoading.value = false;\n-      update();\n-      debugPrint(\"Generic error verifying OTP: $e\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù…Ø².\",\n-        backgroundColor: Colors.red.shade500,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<void> _finalizeSellerRegistration({\n-    bool isAutoVerified = false,\n-    bool isOtpNowVerified = false,\n-  }) async {\n-    debugPrint(\"ğŸ”§ _finalizeSellerRegistration called\");\n-    debugPrint(\n-      \"ğŸ”§ isAutoVerified: $isAutoVerified, isOtpNowVerified: $isOtpNowVerified\",\n-    );\n-\n-    // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙˆÙ„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¢Ù† (Ù…Ù† verifyOtpAndFinalize)ØŒ ÙÙ„Ø§ ØªØªØ§Ø¨Ø¹\n-    if (!isAutoVerified && !isOtpNowVerified) {\n-      debugPrint(\"âŒ Neither auto verified nor OTP verified - stopping\");\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ.\",\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      return;\n-    }\n-\n-    debugPrint(\n-      \"âœ… Phone verification confirmed, proceeding with registration...\",\n-    );\n-\n-    // Set loading states for this final part\n-    isOtpVerifying.value = true;\n-    isLoading.value = true;\n-    update();\n-\n-    try {\n-      final User? currentUser = _auth.currentUser;\n-      if (currentUser == null) {\n-        Get.snackbar(\n-          \"Ø®Ø·Ø£\",\n-          \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø§Ù„ÙŠ. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n-          backgroundColor: Colors.red.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-        );\n-        isLoading.value = false;\n-        isOtpVerifying.value = false;\n-        // Navigate to login or welcome screen\n-        return;\n-      }\n-\n-      String? sellerProfileImageUrl;\n-      String? shopFrontImageUrl;\n-\n-      // iOS-specific: Wait for Firebase to be fully ready\n-      if (Platform.isIOS) {\n-        debugPrint(\n-          \"ğŸ”§ iOS detected - waiting for Firebase Storage to be ready...\",\n-        );\n-        await Future.delayed(Duration(milliseconds: 3000));\n-\n-        // Verify Firebase Storage is accessible\n-        try {\n-          _storage.ref().child('test_connection');\n-          debugPrint(\"âœ… Firebase Storage connection test passed\");\n-        } catch (e) {\n-          debugPrint(\"âš ï¸ Firebase Storage connection test failed: $e\");\n-        }\n-      }\n-\n-      if (_tempSellerProfileImageFile != null) {\n-        debugPrint(\"ğŸ–¼ï¸ Uploading seller profile image...\");\n-        if (Platform.isIOS) {\n-          sellerProfileImageUrl = await _iosStorageHandler.uploadFile(\n-            _tempSellerProfileImageFile!,\n-            'seller_profile_images/${currentUser.uid}',\n-          );\n-        } else {\n-          sellerProfileImageUrl = await _uploadFile(\n-            _tempSellerProfileImageFile!,\n-            'seller_profile_images/${currentUser.uid}',\n-          );\n-        }\n-      }\n-      if (_tempShopFrontImageFile != null) {\n-        debugPrint(\"ğŸª Uploading shop front image...\");\n-        if (Platform.isIOS) {\n-          shopFrontImageUrl = await _iosStorageHandler.uploadFile(\n-            _tempShopFrontImageFile!,\n-            'shop_front_images/${currentUser.uid}',\n-          );\n-        } else {\n-          shopFrontImageUrl = await _uploadFile(\n-            _tempShopFrontImageFile!,\n-            'shop_front_images/${currentUser.uid}',\n-          );\n-        }\n-      }\n-\n-      if (_tempSellerProfileImageFile != null &&\n-          sellerProfileImageUrl == null) {\n-        throw Exception(\"Failed to upload seller profile image.\");\n-      }\n-      if (_tempShopFrontImageFile != null && shopFrontImageUrl == null) {\n-        throw Exception(\"Failed to upload shop front image.\");\n-      }\n-\n-      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM Token Ø¨Ø´ÙƒÙ„ Ø§Ø­ØªØ±Ø§ÙÙŠ\n-      final String? fcmToken = await _getFCMTokenSafely();\n-\n-      // Ø§Ø³ØªØ®Ø¯Ø§Ù… SellerModel Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n-      final SellerModel sellerToSave = SellerModel(\n-        uid: currentUser.uid,\n-        sellerName:\n-            _tempSellerDataForSubmission?['sellerName'] as String? ?? '',\n-        sellerProfileImageUrl: sellerProfileImageUrl,\n-        shopName: _tempSellerDataForSubmission?['shopName'] as String? ?? '',\n-        shopFrontImageUrl: shopFrontImageUrl,\n-        shopPhoneNumber:\n-            _tempSellerDataForSubmission?['shopPhoneNumber'] as String? ?? '',\n-        shopDescription:\n-            _tempSellerDataForSubmission?['shopDescription'] as String?,\n-        location:\n-            _tempSellerDataForSubmission?['location'] as GeoPoint? ??\n-            const GeoPoint(\n-              0,\n-              0,\n-            ), // ØªÙ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† location Ù‡Ùˆ GeoPoint ÙÙŠ _tempSellerDataForSubmission\n-        shopAddressText:\n-            _tempSellerDataForSubmission?['shopAddressText'] as String?,\n-        shopCategory:\n-            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'Ø£Ø®Ø±Ù‰',\n-        workingHours: Map<String, dynamic>.from(\n-          _tempSellerDataForSubmission?['workingHours'] ?? {},\n-        ),\n-        // Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªØ§Ù„ÙŠØ© Ø§Ø®ØªÙŠØ§Ø±ÙŠØ© ÙÙŠ SellerModel ÙˆØ³ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡Ø§ Ø¥Ù„Ù‰ null Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ _tempSellerDataForSubmission\n-        commercialRegistrationNumber:\n-            _tempSellerDataForSubmission?['commercialRegistrationNumber']\n-                as String?,\n-        websiteUrl: _tempSellerDataForSubmission?['websiteUrl'] as String?,\n-        socialMediaLinks:\n-            _tempSellerDataForSubmission?['socialMediaLinks']\n-                as Map<String, String>?,\n-\n-        isProfileComplete: true, // ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n-        isApprovedByAdmin: false, // ÙŠØ­ØªØ§Ø¬ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø´Ø±Ù Ø¨Ø´ÙƒÙ„ Ø§ÙØªØ±Ø§Ø¶ÙŠ\n-        isActiveBySeller: true, // Ù†Ø´Ø· Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§\n-        isPhoneNumberVerified: true, // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n-        averageRating: 0.0,\n-        numberOfRatings: 0,\n-        sellerType: _sellerTypeFromAuth, // Ù…Ù† SellerAuthController\n-        registrationCompleted: true, // Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n-        createdAt:\n-            Timestamp.now(), // Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ FieldValue.serverTimestamp() Ø£Ø¯Ù†Ø§Ù‡\n-        updatedAt:\n-            null, // SellerModel.toMap() Ø³ÙŠØ¹ÙŠÙ† FieldValue.serverTimestamp() Ù„Ù‡Ø°Ø§\n-      );\n-\n-      Map<String, dynamic> sellerDataToSave = sellerToSave.toMap();\n-\n-      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø®Ø§Ø¯Ù… ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ SellerModel\n-      sellerDataToSave['createdAt'] = FieldValue.serverTimestamp();\n-      sellerDataToSave['updatedAt'] =\n-          FieldValue.serverTimestamp(); // Ù„Ù„ØªØ£ÙƒÙŠØ¯ Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† SellerModel.toMap Ù„Ø§ ÙŠÙØ¹Ù„ Ø°Ù„Ùƒ\n-\n-      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªÙŠ Ù„ÙŠØ³Øª Ø¬Ø²Ø¡Ù‹Ø§ Ù…Ù† SellerModel ÙˆÙ„ÙƒÙ†Ù‡Ø§ Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Firestore\n-      sellerDataToSave['email'] = currentUser.email;\n-\n-      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ø­ÙØ¸ FCM Token\n-      if (fcmToken != null && fcmToken.isNotEmpty) {\n-        sellerDataToSave['fcmToken'] = fcmToken;\n-        sellerDataToSave['fcmTokenUpdatedAt'] = FieldValue.serverTimestamp();\n-        debugPrint(\n-          \"âœ… FCM Token will be saved: ${fcmToken.substring(0, 30)}...\",\n-        );\n-      } else {\n-        debugPrint(\n-          \"âš ï¸ No FCM Token available - saving without notification capability\",\n-        );\n-        // Ù„Ø§ Ù†Ø­ÙØ¸ fcmToken Ø¥Ø°Ø§ ÙƒØ§Ù† null Ù„ØªØ¬Ù†Ø¨ overwrite Ø£ÙŠ token Ù…ÙˆØ¬ÙˆØ¯\n-        sellerDataToSave['fcmTokenStatus'] = 'failed_to_retrieve';\n-        sellerDataToSave['fcmTokenFailedAt'] = FieldValue.serverTimestamp();\n-\n-        // Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n-        debugPrint(\"ğŸ“… Scheduling FCM token retry for later...\");\n-      }\n-\n-      debugPrint(\"ğŸ’¾ Saving seller data to Firestore...\");\n-      debugPrint(\"ğŸ’¾ Document ID: ${currentUser.uid}\");\n-      debugPrint(\"ğŸ’¾ Collection: ${FirebaseX.collectionSeller}\");\n-\n-      await _firestore\n-          .collection(FirebaseX.collectionSeller)\n-          .doc(currentUser.uid)\n-          .set(sellerDataToSave, SetOptions(merge: true));\n-\n-      debugPrint(\"âœ… Seller data saved successfully to Firestore!\");\n-\n-      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      update();\n-\n-      debugPrint(\"ğŸ‰ Registration completed successfully!\");\n-\n-      // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ FCM tokenØŒ Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\n-      if (fcmToken == null || fcmToken.isEmpty) {\n-        retryFCMTokenLater();\n-      }\n-\n-      Get.snackbar(\n-        \"Ù†Ø¬Ø§Ø­\",\n-        \"ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!\",\n-        backgroundColor: Colors.green.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-\n-      // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ø¹Ù„Ù‰ iOS Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n-      if (Platform.isIOS) {\n-        await Future.delayed(const Duration(milliseconds: 500));\n-      }\n-\n-      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªÙ†Ù‚Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ main thread\n-      WidgetsBinding.instance.addPostFrameCallback((_) {\n-        Get.offAll(\n-          () => SellerMainScreen(),\n-        ); // Navigate to seller dashboard or main screen\n-      });\n-    } catch (e) {\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      update();\n-      debugPrint(\"Error finalizing seller registration: $e\");\n-      String errorMessage = \"ÙØ´Ù„ Ø¥ÙƒÙ…Ø§Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ³Ø¬ÙŠÙ„.\";\n-      if (e is FirebaseException &&\n-          e.code == 'invalid-credential' &&\n-          isAutoVerified) {\n-        errorMessage =\n-            \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ. Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ù…Ø² ÙŠØ¯ÙˆÙŠÙ‹Ø§.\";\n-        // Optionally, you could re-route to OTP screen if auto-verification was the only path here\n-        // Get.to(() => OtpVerificationScreen()); // Might need to handle this case more gracefully\n-      } else if (e is FirebaseException &&\n-          e.code == 'invalid-verification-code') {\n-        errorMessage = \"Ø±Ù…Ø² OTP Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ­ÙŠØ­.\";\n-      } else if (e is FirebaseException && e.code == 'session-expired') {\n-        errorMessage = \"Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø¬Ù„Ø³Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ Ø±Ù…Ø² Ø¬Ø¯ÙŠØ¯.\";\n-      }\n-\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"$errorMessage ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<String?> _uploadFile(File file, String path) async {\n-    try {\n-      debugPrint(\"ğŸ”§ Starting file upload to: $path\");\n-      debugPrint(\"ğŸ”§ File exists: ${await file.exists()}\");\n-      debugPrint(\"ğŸ”§ File size: ${await file.length()} bytes\");\n-\n-      // Verify Firebase Storage is properly initialized\n-      if (Firebase.apps.isEmpty) {\n-        throw Exception(\"Firebase not initialized\");\n-      }\n-\n-      final ref = _storage.ref().child(path);\n-      debugPrint(\"ğŸ”§ Storage reference created: ${ref.fullPath}\");\n-\n-      // iOS-specific: Add metadata to help with upload\n-      final metadata = SettableMetadata(\n-        contentType: 'image/jpeg',\n-        customMetadata: {\n-          'uploaded_by': 'seller_registration',\n-          'platform': Platform.isIOS ? 'ios' : 'android',\n-        },\n-      );\n-\n-      final uploadTask = ref.putFile(file, metadata);\n-\n-      // Monitor upload progress\n-      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n-        final progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n-        debugPrint(\"ğŸ”§ Upload progress: ${progress.toStringAsFixed(1)}%\");\n-      });\n-\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"âœ… File uploaded successfully: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"âŒ Error uploading file ($path): $e\");\n-\n-      // iOS-specific error handling\n-      if (Platform.isIOS && e.toString().contains('object-not-found')) {\n-        debugPrint(\n-          \"ğŸ”§ iOS Storage issue detected - retrying with different approach\",\n-        );\n-        return await _uploadFileWithRetry(file, path);\n-      }\n-\n-      return null;\n-    }\n-  }\n-\n-  Future<String?> _uploadFileWithRetry(File file, String path) async {\n-    try {\n-      // Wait a bit longer on iOS\n-      await Future.delayed(Duration(milliseconds: 1500));\n-\n-      // Try with a different path structure for iOS\n-      final timestamp = DateTime.now().millisecondsSinceEpoch;\n-      final newPath = '${path.replaceAll('/', '_')}_$timestamp';\n-\n-      debugPrint(\"ğŸ”§ Retrying upload with path: $newPath\");\n-\n-      final ref = _storage.ref().child(newPath);\n-      final uploadTask = ref.putFile(file);\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"âœ… Retry upload successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"âŒ Retry upload also failed: $e\");\n-      return null;\n-    }\n-  }\n-\n-  Future<void> pickImage(\n-    ImageSource source, {\n-    required bool isProfileImage,\n-  }) async {\n-    try {\n-      final XFile? pickedFile = await _picker.pickImage(\n-        source: source,\n-        imageQuality: 70,\n-        maxWidth: 1024,\n-      );\n-      if (pickedFile != null) {\n-        if (isProfileImage) {\n-          sellerProfileImageFile.value = File(pickedFile.path);\n-        } else {\n-          shopFrontImageFile.value = File(pickedFile.path);\n-        }\n-        update(); // For GetBuilder if used\n-      }\n-    } catch (e) {\n-      Get.snackbar(\"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©\", \"ÙØ´Ù„ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØµÙˆØ±Ø©: $e\");\n-    }\n-  }\n-\n-  // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©\n-  void toggleCategorySelection(String category) {\n-    if (selectedShopCategories.contains(category)) {\n-      selectedShopCategories.remove(category);\n-    } else {\n-      if (selectedShopCategories.length < maxCategoriesAllowed) {\n-        selectedShopCategories.add(category);\n-      } else {\n-        Get.snackbar(\n-          \"ØªØ­Ø°ÙŠØ±\",\n-          \"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ Ø£Ù‚ØµÙ‰ $maxCategoriesAllowed ÙØ¦Ø§Øª ÙÙ‚Ø·\",\n-          backgroundColor: Colors.orange.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-        );\n-      }\n-    }\n-  }\n-\n-  // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©\n-  bool isCategorySelected(String category) {\n-    return selectedShopCategories.contains(category);\n-  }\n-\n-  // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n-  int get selectedCategoriesCount => selectedShopCategories.length;\n-\n-  // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Øµ Ø¹Ø±Ø¶ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n-  String get selectedCategoriesDisplay {\n-    if (selectedShopCategories.isEmpty) {\n-      return 'Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠ ÙØ¦Ø©';\n-    } else if (selectedShopCategories.length == 1) {\n-      return selectedShopCategories.first;\n-    } else {\n-      return '${selectedShopCategories.length} ÙØ¦Ø§Øª Ù…Ø®ØªØ§Ø±Ø©';\n-    }\n-  }\n-\n-  void toggleDayOpen(String dayKey) {\n-    if (workingHours[dayKey] != null) {\n-      bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n-      workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n-\n-      if (!workingHours[dayKey]!['isOpen']) {\n-        // If day is being closed\n-        workingHours[dayKey]!['opensAt'] = null;\n-        workingHours[dayKey]!['closesAt'] = null;\n-        if (expandedDayPanel.value == dayKey) {\n-          // Close expansion panel if it was this day\n-          expandedDayPanel.value = null;\n-        }\n-      } else {\n-        // If day is being opened\n-        workingHours[dayKey]!['opensAt'] =\n-            _lastAppliedOpensAt.value ?? \"09:00 AM\";\n-        workingHours[dayKey]!['closesAt'] =\n-            _lastAppliedClosesAt.value ?? \"05:00 PM\";\n-        // Optionally, open this panel when day is toggled on if not already open by user interaction\n-        // expandedDayPanel.value = dayKey;\n-      }\n-      workingHours.refresh();\n-    }\n-  }\n-\n-  bool canApplyToOthers(String dayKey) {\n-    final dayData = workingHours[dayKey];\n-    if (dayData == null || !(dayData['isOpen'] == true)) return false;\n-    return dayData['opensAt'] != null && dayData['closesAt'] != null;\n-  }\n-\n-  void offerToApplyTimesToOtherDays(\n-    BuildContext context,\n-    String sourceDayKey,\n-    String opensAtToApply,\n-    String closesAtToApply,\n-  ) {\n-    Get.dialog(\n-      AlertDialog(\n-        title: const Text(\"ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§ØªØŸ\"),\n-        content: Text(\n-          \"Ù‡Ù„ ØªØ±ØºØ¨ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‚Øª Ø§Ù„ÙØªØ­ ($opensAtToApply) ÙˆÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ($closesAtToApply) Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø®Ø±Ù‰ Ø§Ù„ØªÙŠ ØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡Ø§ ÙƒÙ…ÙØªÙˆØ­Ø© ÙˆÙ„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ‚Ø§Øª Ù„Ù‡Ø§ Ø¨Ø¹Ø¯ Ø£Ùˆ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…ÙØªÙˆØ­Ø©ØŸ\",\n-        ),\n-        actionsAlignment: MainAxisAlignment.spaceEvenly,\n-        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),\n-        actions: [\n-          TextButton(child: const Text(\"Ø¥Ù„ØºØ§Ø¡\"), onPressed: () => Get.back()),\n-          ElevatedButton(\n-            child: const Text(\"Ù„Ù„Ø£ÙŠØ§Ù… Ø§Ù„ÙØ§Ø±ØºØ© ÙÙ‚Ø·\"),\n-            onPressed: () {\n-              Get.back();\n-              applyTimesToOtherOpenDays(\n-                sourceDayKey,\n-                opensAtToApply,\n-                closesAtToApply,\n-                applyToAllOpen: false,\n-              );\n-            },\n-          ),\n-          ElevatedButton(\n-            child: const Text(\"Ù†Ø¹Ù…ØŒ Ù„Ù„ÙƒÙ„ (Ø§Ù„Ù…ÙØªÙˆØ­)\"),\n-            onPressed: () {\n-              Get.back();\n-              applyTimesToOtherOpenDays(\n-                sourceDayKey,\n-                opensAtToApply,\n-                closesAtToApply,\n-                applyToAllOpen: true,\n-              );\n-            },\n-          ),\n-        ],\n-      ),\n-      barrierDismissible: true,\n-    );\n-  }\n-\n-  void applyTimesToOtherOpenDays(\n-    String sourceDayKey,\n-    String opensAtToApply,\n-    String closesAtToApply, {\n-    required bool applyToAllOpen,\n-  }) {\n-    bool timesApplied = false;\n-    workingHours.forEach((key, value) {\n-      if (key != sourceDayKey && (value['isOpen'] == true)) {\n-        bool apply = false;\n-        if (applyToAllOpen) {\n-          apply = true;\n-        } else {\n-          // Apply to empty open days only\n-          if (value['opensAt'] == null || value['closesAt'] == null) {\n-            apply = true;\n-          }\n-        }\n-        if (apply) {\n-          value['opensAt'] = opensAtToApply;\n-          value['closesAt'] = closesAtToApply;\n-          timesApplied = true;\n-        }\n-      }\n-    });\n-    if (timesApplied) {\n-      _lastAppliedOpensAt.value =\n-          opensAtToApply; // Update template if changes were made\n-      _lastAppliedClosesAt.value = closesAtToApply;\n-      workingHours.refresh();\n-      Get.snackbar(\n-        \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«\",\n-        \"ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.\",\n-        snackPosition: SnackPosition.BOTTOM,\n-        backgroundColor: Colors.green.shade400,\n-        colorText: Colors.white,\n-      );\n-    } else {\n-      Get.snackbar(\n-        \"Ù„Ù… ÙŠØªØºÙŠØ± Ø´ÙŠØ¡\",\n-        \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠØ§Ù… Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø¹Ù„ÙŠÙ‡Ø§ Ø­Ø³Ø¨ Ø§Ø®ØªÙŠØ§Ø±Ùƒ.\",\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<void> selectTime(\n-    BuildContext context,\n-    String dayKey,\n-    bool isOpeningTime,\n-  ) async {\n-    final Map<String, dynamic>? dayData = workingHours[dayKey];\n-    final String? opensAtString = dayData?['opensAt'] as String?;\n-    final String? closesAtString = dayData?['closesAt'] as String?;\n-\n-    String? timeToParse;\n-    if (isOpeningTime) {\n-      timeToParse = opensAtString;\n-    } else {\n-      timeToParse = closesAtString;\n-    }\n-\n-    TimeOfDay? initialTime = _parseTime(timeToParse) ?? TimeOfDay.now();\n-\n-    final TimeOfDay? pickedTime = await showTimePicker(\n-      context: context,\n-      initialTime: initialTime,\n-      builder: (context, child) {\n-        return Theme(\n-          data: ThemeData.light().copyWith(\n-            colorScheme: ColorScheme.light(\n-              primary: Get.theme.primaryColor, // header background color\n-              onPrimary: Colors.white, // header text color\n-              onSurface: Colors.black, // body text color\n-            ),\n-            timePickerTheme: TimePickerThemeData(\n-              dialHandColor: Get.theme.primaryColor,\n-            ),\n-            textButtonTheme: TextButtonThemeData(\n-              style: TextButton.styleFrom(\n-                foregroundColor: Get.theme.primaryColor, // button text color\n-              ),\n-            ),\n-          ),\n-          child: child!,\n-        );\n-      },\n-    );\n-\n-    if (pickedTime != null) {\n-      final formattedTime = formatTimeOfDay(pickedTime);\n-      final currentOpensAt = _parseTime(workingHours[dayKey]?['opensAt']);\n-      final currentClosesAt = _parseTime(workingHours[dayKey]?['closesAt']);\n-\n-      if (isOpeningTime) {\n-        if (currentClosesAt != null &&\n-            _isTimeBeforeOrEqual(\n-              pickedTime,\n-              currentClosesAt,\n-              isOpening: true,\n-              isClosing: false,\n-            )) {\n-          workingHours[dayKey]!['opensAt'] = formattedTime;\n-          _lastAppliedOpensAt.value = formattedTime;\n-        } else if (currentClosesAt != null) {\n-          Get.snackbar(\n-            \"ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­\",\n-            \"ÙˆÙ‚Øª Ø§Ù„ÙØªØ­ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚.\",\n-            snackPosition: SnackPosition.BOTTOM,\n-            backgroundColor: Colors.orange.shade300,\n-          );\n-          return;\n-        } else {\n-          // No closing time set yet, allow setting opening time\n-          workingHours[dayKey]!['opensAt'] = formattedTime;\n-          _lastAppliedOpensAt.value = formattedTime;\n-        }\n-      } else {\n-        // isClosingTime\n-        if (currentOpensAt != null &&\n-            _isTimeBeforeOrEqual(\n-              currentOpensAt,\n-              pickedTime,\n-              isOpening: false,\n-              isClosing: true,\n-            )) {\n-          workingHours[dayKey]!['closesAt'] = formattedTime;\n-          _lastAppliedClosesAt.value = formattedTime;\n-        } else if (currentOpensAt != null) {\n-          Get.snackbar(\n-            \"ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­\",\n-            \"ÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø¹Ø¯ ÙˆÙ‚Øª Ø§Ù„ÙØªØ­.\",\n-            snackPosition: SnackPosition.BOTTOM,\n-            backgroundColor: Colors.orange.shade300,\n-          );\n-          return;\n-        } else {\n-          // No opening time set yet, allow setting closing time\n-          workingHours[dayKey]!['closesAt'] = formattedTime;\n-          _lastAppliedClosesAt.value = formattedTime;\n-        }\n-      }\n-      workingHours.refresh();\n-    }\n-  }\n-\n-  bool _isTimeBeforeOrEqual(\n-    TimeOfDay time1,\n-    TimeOfDay time2, {\n-    required bool isOpening,\n-    required bool isClosing,\n-  }) {\n-    final time1Minutes = time1.hour * 60 + time1.minute;\n-    final time2Minutes = time2.hour * 60 + time2.minute;\n-    if (isOpening) {\n-      // time1 is opensAt, time2 is closesAt\n-      return time1Minutes < time2Minutes;\n-    } else {\n-      // time1 is opensAt, time2 is closesAt\n-      return time1Minutes < time2Minutes;\n-    }\n-  }\n-\n-  String formatTimeOfDay(TimeOfDay tod) {\n-    final now = DateTime.now();\n-    final dt = DateTime(now.year, now.month, now.day, tod.hour, tod.minute);\n-    final format = DateFormat.jm(); // e.g., 5:08 PM\n-    return format.format(dt);\n-  }\n-\n-  TimeOfDay? _parseTime(String? timeString) {\n-    if (timeString == null) return null;\n-    try {\n-      final format =\n-          DateFormat.jm(); // Needs to match the format used in formatTimeOfDay\n-      final dt = format.parse(timeString);\n-      return TimeOfDay.fromDateTime(dt);\n-    } catch (e) {\n-      debugPrint(\"Error parsing time: $e\");\n-      return null;\n-    }\n-  }\n-\n-  // --- Location Methods ---\n-  final TextEditingController streetAddressController = TextEditingController();\n-\n-  void onMapCreated(GoogleMapController controller) {\n-    mapController = controller;\n-  }\n-\n-  Future<void> openLocationPickerScreen(BuildContext context) async {\n-    final LatLng? result = await Get.to<LatLng>(\n-      () => LocationPickerScreen(initialLocation: shopLocation.value),\n-    );\n-    if (result != null) {\n-      shopLocation.value = result;\n-      await _getAddressFromLatLng(result);\n-      // Optionally move camera on the small map if it's visible and controller is available\n-      mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n-    }\n-  }\n-\n-  Future<void> _getAddressFromLatLng(LatLng latLng) async {\n-    try {\n-      List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n-        latLng.latitude,\n-        latLng.longitude,\n-      );\n-      if (placemarks.isNotEmpty) {\n-        final p = placemarks[0];\n-        // Construct a more detailed or relevant address string\n-        shopAddressText.value =\n-            \"${p.name}, ${p.locality}, ${p.subAdministrativeArea}, ${p.administrativeArea}\"\n-                .replaceAll(\"null,\", \"\")\n-                .trim()\n-                .replaceAll(RegExp(r'^, |,$'), '');\n-        if (streetAddressController.text.isEmpty &&\n-            p.street != null &&\n-            p.street!.isNotEmpty) {\n-          streetAddressController.text = p.street!;\n-        }\n-      } else {\n-        shopAddressText.value = \"ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n-      }\n-    } catch (e) {\n-      debugPrint(\"Error getting address: $e\");\n-      shopAddressText.value = \"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n-    }\n-  }\n-\n-  Future<void> tryMoveToCurrentLocation() async {\n-    isLoading.value = true; // Indicate loading for location fetch\n-    update();\n-    try {\n-      Position currentPosition = await _determinePosition();\n-      LatLng newLatLng = LatLng(\n-        currentPosition.latitude,\n-        currentPosition.longitude,\n-      );\n-      shopLocation.value = newLatLng;\n-      await _getAddressFromLatLng(newLatLng);\n-      mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n-    } catch (e) {\n-      Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n-        \"ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${e.toString()}\",\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    } finally {\n-      isLoading.value = false;\n-      update();\n-    }\n-  }\n-\n-  Future<Position> _determinePosition() async {\n-    bool serviceEnabled;\n-    LocationPermission permission;\n-\n-    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n-    if (!serviceEnabled) {\n-      // Attempt to open location settings\n-      await Geolocator.openLocationSettings();\n-      return Future.error('Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø·Ù„Ø©. ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„Ù‡Ø§.');\n-    }\n-\n-    permission = await Geolocator.checkPermission();\n-    if (permission == LocationPermission.denied) {\n-      permission = await Geolocator.requestPermission();\n-      if (permission == LocationPermission.denied) {\n-        return Future.error('ØªÙ… Ø±ÙØ¶ Ø£Ø°ÙˆÙ†Ø§Øª ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹.');\n-      }\n-    }\n-\n-    if (permission == LocationPermission.deniedForever) {\n-      return Future.error(\n-        'Ø£Ø°ÙˆÙ†Ø§Øª ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø±ÙÙˆØ¶Ø© Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª. ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„Ù‡Ø§ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.',\n-      );\n-    }\n-    currentPositionAccuracy.value =\n-        (await Geolocator.getCurrentPosition()).accuracy;\n-\n-    return await Geolocator.getCurrentPosition(\n-      desiredAccuracy: LocationAccuracy.high,\n-    );\n-  }\n-\n-  void submitRegistration(BuildContext context) {\n-    debugPrint(\"ğŸ”¥ submitRegistration called\");\n-\n-    // This method will now call initiatePhoneVerificationAndCollectData\n-    // as OTP verification is mandatory.\n-\n-    // Ø¥Ø¶Ø§ÙØ© Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù…Ù† Ø§Ù„ØªØ¬Ù…ÙŠØ¯\n-    _startSafetyTimeout();\n-\n-    debugPrint(\"About to call initiatePhoneVerificationAndCollectData...\");\n-    initiatePhoneVerificationAndCollectData();\n-    debugPrint(\"initiatePhoneVerificationAndCollectData call completed\");\n-  }\n-\n-  // Ø¢Ù„ÙŠØ© Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¬Ù…ÙŠØ¯ Ø¹Ù„Ù‰ iOS\n-  Timer? _safetyTimer;\n-\n-  void _startSafetyTimeout() {\n-    _safetyTimer = Timer(Duration(seconds: Platform.isIOS ? 60 : 90), () {\n-      if ((isLoading.value || isOtpSending.value) && !isOtpVerifying.value) {\n-        debugPrint(\"Safety timeout triggered - resetting loading states\");\n-        isLoading.value = false;\n-        isOtpSending.value = false;\n-        isOtpVerifying.value = false;\n-        update();\n-        Get.snackbar(\n-          \"Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ù‡Ù„Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©\",\n-          \"ØªÙ… Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ù„Ø¹Ù…Ù„ÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n-          backgroundColor: Colors.orange.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-        );\n-      }\n-    });\n-  }\n-\n-  void _cancelSafetyTimeout() {\n-    _safetyTimer?.cancel();\n-    _safetyTimer = null;\n-  }\n-\n-  /// Ø¯Ø§Ù„Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM Token Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡\n-  Future<String?> _getFCMTokenSafely() async {\n-    debugPrint(\"ğŸ”‘ Starting FCM token retrieval process...\");\n-\n-    try {\n-      // 1. Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹\n-      debugPrint(\"ğŸ“± Requesting Firebase Messaging permissions...\");\n-      NotificationSettings settings = await _firebaseMessaging\n-          .requestPermission(\n-            alert: true,\n-            announcement: false,\n-            badge: true,\n-            carPlay: false,\n-            criticalAlert: false,\n-            provisional: false,\n-            sound: true,\n-          );\n-\n-      debugPrint(\"ğŸ”” Permission status: ${settings.authorizationStatus}\");\n-\n-      if (settings.authorizationStatus == AuthorizationStatus.denied) {\n-        debugPrint(\"âŒ Notification permissions denied\");\n-        return null;\n-      }\n-\n-      // 2. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªØ¸Ø§Ø± APNS\n-      debugPrint(\n-        \"ğŸš€ Attempting direct FCM token retrieval (bypass APNS dependency)...\",\n-      );\n-\n-      String? fcmToken;\n-      int directAttempts = 0;\n-      const maxDirectAttempts = 3;\n-\n-      while (fcmToken == null && directAttempts < maxDirectAttempts) {\n-        directAttempts++;\n-        debugPrint(\"ğŸ”„ Direct FCM attempt $directAttempts/$maxDirectAttempts\");\n-\n-        try {\n-          // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªØ¸Ø§Ø± APNS\n-          fcmToken = await _firebaseMessaging.getToken().timeout(\n-            Duration(seconds: 20 + (10 * directAttempts)),\n-            onTimeout: () => null,\n-          );\n-\n-          if (fcmToken != null && fcmToken.isNotEmpty) {\n-            debugPrint(\"âœ… Direct FCM Token received successfully!\");\n-            debugPrint(\"ğŸ”‘ Token preview: ${fcmToken.substring(0, 50)}...\");\n-            await _cacheFCMToken(fcmToken);\n-            return fcmToken;\n-          }\n-        } catch (e) {\n-          debugPrint(\"âš ï¸ Direct FCM attempt $directAttempts failed: $e\");\n-          // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…Ø´ÙƒÙ„Ø© APNSØŒ ØªØ§Ø¨Ø¹\n-          if (!e.toString().toLowerCase().contains('apns')) {\n-            await Future.delayed(Duration(seconds: directAttempts * 2));\n-            continue;\n-          }\n-        }\n-\n-        // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù‡Ù†Ø§ØŒ ÙØ§Ù„Ù…Ø´ÙƒÙ„Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ APNS\n-        break;\n-      }\n-\n-      // 3. Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ Ø¬Ø±Ø¨ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ© Ù…Ø¹ APNS\n-      if (fcmToken == null && Platform.isIOS) {\n-        debugPrint(\"ğŸ Fallback to APNS-dependent approach...\");\n-\n-        // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ù† native code\n-        debugPrint(\"ğŸ“² Triggering native notification registration...\");\n-\n-        // Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù†Ø¸Ø§Ù…\n-        await Future.delayed(const Duration(seconds: 5));\n-\n-        // Ù…Ø­Ø§ÙˆÙ„Ø© APNS Ù…Ø­Ø¯ÙˆØ¯Ø©\n-        String? apnsToken;\n-        for (int attempt = 1; attempt <= 3; attempt++) {\n-          debugPrint(\"ğŸ”„ APNS attempt $attempt/3\");\n-\n-          try {\n-            await Future.delayed(Duration(seconds: attempt * 3));\n-            apnsToken = await _firebaseMessaging.getAPNSToken();\n-            if (apnsToken != null) {\n-              debugPrint(\n-                \"âœ… APNS Token received: ${apnsToken.substring(0, 20)}...\",\n-              );\n-              break;\n-            }\n-          } catch (e) {\n-            debugPrint(\"âš ï¸ APNS attempt $attempt failed: $e\");\n-          }\n-        }\n-\n-        // 4. Ù…Ø­Ø§ÙˆÙ„Ø© FCM Ù…Ø±Ø© Ø£Ø®ÙŠØ±Ø©\n-        if (apnsToken != null) {\n-          debugPrint(\"ğŸ”‘ Final FCM token attempt with APNS...\");\n-\n-          try {\n-            fcmToken = await _firebaseMessaging.getToken().timeout(\n-              const Duration(seconds: 30),\n-              onTimeout: () => null,\n-            );\n-\n-            if (fcmToken != null && fcmToken.isNotEmpty) {\n-              debugPrint(\"âœ… FCM Token received after APNS setup!\");\n-              await _cacheFCMToken(fcmToken);\n-              return fcmToken;\n-            }\n-          } catch (e) {\n-            debugPrint(\"âš ï¸ Final FCM attempt failed: $e\");\n-          }\n-        }\n-      }\n-\n-      // 5. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ù…Ù† cache\n-      debugPrint(\"â™»ï¸ Trying cached token...\");\n-      String? cachedToken = await _getCachedFCMToken();\n-\n-      if (cachedToken != null) {\n-        debugPrint(\"âœ… Using cached FCM token\");\n-        return cachedToken;\n-      }\n-\n-      // 6. Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ„ Ø´ÙŠØ¡ØŒ Ø¥Ù†Ø´Ø§Ø¡ placeholder token Ù„Ù„ØªØ·ÙˆÙŠØ±\n-      if (Platform.isIOS) {\n-        debugPrint(\"ğŸ› ï¸ Creating development placeholder token...\");\n-        String placeholderToken = await _createDevelopmentToken();\n-        if (placeholderToken.isNotEmpty) {\n-          debugPrint(\n-            \"ğŸ”§ Using development token: ${placeholderToken.substring(0, 30)}...\",\n-          );\n-          await _cacheFCMToken(placeholderToken);\n-          return placeholderToken;\n-        }\n-      }\n-\n-      debugPrint(\"âŒ All FCM token retrieval methods failed\");\n-      return null;\n-    } catch (e) {\n-      debugPrint(\"ğŸš¨ Fatal error in FCM token retrieval: $e\");\n-      debugPrint(\"ğŸ“Š Error details: ${e.toString()}\");\n-\n-      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®ÙŠØ±Ø© Ù…Ø¹ cached token\n-      String? cachedToken = await _getCachedFCMToken();\n-      if (cachedToken != null) {\n-        debugPrint(\"â™»ï¸ Emergency fallback to cached token\");\n-        return cachedToken;\n-      }\n-\n-      return null;\n-    }\n-  }\n-\n-  /// Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ·ÙˆÙŠØ± Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙØ´Ù„ APNS\n-  Future<String> _createDevelopmentToken() async {\n-    try {\n-      final User? currentUser = _auth.currentUser;\n-      final String deviceId =\n-          currentUser?.uid ?? DateTime.now().millisecondsSinceEpoch.toString();\n-      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();\n-\n-      // Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª ÙØ±ÙŠØ¯ Ù„Ù„Ø¬Ù‡Ø§Ø²\n-      String developmentToken = \"dev_token_ios_${deviceId}_$timestamp\";\n-\n-      debugPrint(\"ğŸ”§ Generated development token for testing\");\n-      return developmentToken;\n-    } catch (e) {\n-      debugPrint(\"âš ï¸ Failed to create development token: $e\");\n-      return \"\";\n-    }\n-  }\n-\n-  /// Ø­ÙØ¸ FCM token ÙÙŠ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©\n-  Future<void> _cacheFCMToken(String token) async {\n-    try {\n-      final box = GetStorage();\n-      await box.write('cached_fcm_token', token);\n-      await box.write(\n-        'fcm_token_timestamp',\n-        DateTime.now().millisecondsSinceEpoch,\n-      );\n-      debugPrint(\"ğŸ’¾ FCM token cached successfully\");\n-    } catch (e) {\n-      debugPrint(\"âš ï¸ Failed to cache FCM token: $e\");\n-    }\n-  }\n-\n-  /// Ø§Ø³ØªØ±Ø¯Ø§Ø¯ FCM token Ù…Ù† Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©\n-  Future<String?> _getCachedFCMToken() async {\n-    try {\n-      final box = GetStorage();\n-      String? cachedToken = box.read('cached_fcm_token');\n-      int? timestamp = box.read('fcm_token_timestamp');\n-\n-      if (cachedToken != null && timestamp != null) {\n-        // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ù…Ø± Ø§Ù„Ù€ token (ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 7 Ø£ÙŠØ§Ù…)\n-        DateTime tokenDate = DateTime.fromMillisecondsSinceEpoch(timestamp);\n-        Duration age = DateTime.now().difference(tokenDate);\n-\n-        if (age.inDays < 7) {\n-          debugPrint(\n-            \"â™»ï¸ Found valid cached FCM token (age: ${age.inHours} hours)\",\n-          );\n-          return cachedToken;\n-        } else {\n-          debugPrint(\n-            \"â° Cached FCM token is too old (${age.inDays} days), ignoring\",\n-          );\n-        }\n-      }\n-\n-      return null;\n-    } catch (e) {\n-      debugPrint(\"âš ï¸ Failed to retrieve cached FCM token: $e\");\n-      return null;\n-    }\n-  }\n-\n-  /// ØªØ­Ø¯ÙŠØ« FCM Token ÙÙŠ Firestore Ù„Ø§Ø­Ù‚Ø§Ù‹ (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù…Ù† Ù…ÙƒØ§Ù† Ø¢Ø®Ø±)\n-  Future<void> updateFCMTokenInFirestore() async {\n-    try {\n-      final User? currentUser = _auth.currentUser;\n-      if (currentUser == null) {\n-        debugPrint(\"âš ï¸ No current user to update FCM token for\");\n-        return;\n-      }\n-\n-      debugPrint(\"ğŸ”„ Attempting to update FCM token in Firestore...\");\n-      final String? fcmToken = await _getFCMTokenSafely();\n-\n-      if (fcmToken != null && fcmToken.isNotEmpty) {\n-        await _firestore\n-            .collection(FirebaseX.collectionSeller)\n-            .doc(currentUser.uid)\n-            .update({\n-              'fcmToken': fcmToken,\n-              'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n-              'fcmTokenStatus': 'active',\n-            });\n-\n-        debugPrint(\"âœ… FCM Token updated successfully in Firestore\");\n-        Get.snackbar(\n-          \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«\",\n-          \"ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø±Ù Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­\",\n-          backgroundColor: Colors.green.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-          duration: const Duration(seconds: 2),\n-        );\n-      } else {\n-        debugPrint(\"âŒ Failed to get FCM token for update\");\n-      }\n-    } catch (e) {\n-      debugPrint(\"ğŸš¨ Error updating FCM token in Firestore: $e\");\n-    }\n-  }\n-\n-  /// Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù‘Ù†Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯ Ø£ÙØ¶Ù„ Ù„Ù€ iOS\n-  Future<String?> _getIOSOptimizedFCMToken() async {\n-    debugPrint(\"ğŸ Starting iOS-optimized FCM token retrieval...\");\n-\n-    try {\n-      // 1. Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø¸Ø§Ù…\n-      await Future.delayed(const Duration(seconds: 5));\n-\n-      // 2. Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ù€ remote notifications ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…Ø³Ø¬Ù„Ø§Ù‹\n-      debugPrint(\"ğŸ“± Ensuring iOS remote notification registration...\");\n-\n-      // 3. Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n-      NotificationSettings settings = await _firebaseMessaging\n-          .requestPermission(\n-            alert: true,\n-            announcement: false,\n-            badge: true,\n-            carPlay: false,\n-            criticalAlert: false,\n-            provisional: false,\n-            sound: true,\n-          );\n-\n-      if (settings.authorizationStatus != AuthorizationStatus.authorized) {\n-        debugPrint(\n-          \"âŒ iOS Notifications not authorized: ${settings.authorizationStatus}\",\n-        );\n-        return null;\n-      }\n-\n-      // 4. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ø¹ Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„\n-      for (int attempt = 1; attempt <= 3; attempt++) {\n-        debugPrint(\"ğŸ”‘ iOS FCM token attempt $attempt/3\");\n-\n-        try {\n-          // Ø§Ù†ØªØ¸Ø§Ø± Ù…ØªØ²Ø§ÙŠØ¯ Ù…Ø¹ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©\n-          await Future.delayed(Duration(seconds: 3 * attempt));\n-\n-          String? token = await _firebaseMessaging.getToken().timeout(\n-            Duration(seconds: 60 + (10 * attempt)), // Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„ Ù…Ø¹ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©\n-          );\n-\n-          if (token != null && token.isNotEmpty) {\n-            debugPrint(\"âœ… iOS FCM token received on attempt $attempt!\");\n-            return token;\n-          }\n-        } catch (e) {\n-          debugPrint(\"âš ï¸ iOS FCM attempt $attempt failed: $e\");\n-          if (e.toString().toLowerCase().contains('apns')) {\n-            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø®Ø·Ø£ APNSØŒ Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„\n-            await Future.delayed(Duration(seconds: 5 * attempt));\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (e) {\n-      debugPrint(\"ğŸš¨ iOS FCM token retrieval failed: $e\");\n-      return null;\n-    }\n-  }\n-\n-  /// Ù…Ø³Ø§Ø¹Ø¯ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n-  void retryFCMTokenLater() {\n-    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ 30 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰\n-    Timer(const Duration(seconds: 30), () {\n-      debugPrint(\"ğŸ”„ Retrying FCM token retrieval after 30 seconds...\");\n-      updateFCMTokenInFirestore();\n-    });\n-\n-    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø®Ø§ØµØ© Ø¨Ù€ iOS Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©\n-    if (Platform.isIOS) {\n-      Timer(const Duration(minutes: 1), () async {\n-        debugPrint(\"ğŸ iOS-specific FCM token retry after 1 minute...\");\n-        final token = await _getIOSOptimizedFCMToken();\n-        if (token != null) {\n-          try {\n-            final User? currentUser = _auth.currentUser;\n-            if (currentUser != null) {\n-              await _firestore\n-                  .collection(FirebaseX.collectionSeller)\n-                  .doc(currentUser.uid)\n-                  .update({\n-                    'fcmToken': token,\n-                    'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n-                    'fcmTokenStatus': 'active',\n-                  });\n-              debugPrint(\"âœ… iOS FCM Token updated successfully in retry!\");\n-            }\n-          } catch (e) {\n-            debugPrint(\"âŒ Failed to update iOS FCM token in retry: $e\");\n-          }\n-        }\n-      });\n-    }\n-\n-    // Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ† Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ø£ÙˆÙ„Ù‰\n-    Timer(const Duration(minutes: 2), () {\n-      debugPrint(\"ğŸ”„ Second retry attempt for FCM token after 2 minutes...\");\n-      updateFCMTokenInFirestore();\n-    });\n-\n-    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®ÙŠØ±Ø© Ø¨Ø¹Ø¯ 5 Ø¯Ù‚Ø§Ø¦Ù‚\n-    Timer(const Duration(minutes: 5), () {\n-      debugPrint(\"ğŸ”„ Final retry attempt for FCM token after 5 minutes...\");\n-      updateFCMTokenInFirestore();\n-    });\n-  }\n-}\n-\n-/// iOS-specific Firebase Storage handler to fix image upload issues\n-class IOSFirebaseStorageHandler {\n-  final FirebaseStorage _storage;\n-\n-  IOSFirebaseStorageHandler(this._storage);\n-\n-  Future<String?> uploadFile(File file, String path) async {\n-    try {\n-      debugPrint(\"ğŸ iOS Storage Handler: Starting upload to: $path\");\n-\n-      // Wait longer for Firebase to be fully ready on iOS\n-      await Future.delayed(Duration(milliseconds: 5000));\n-\n-      // Verify Firebase is properly initialized\n-      if (Firebase.apps.isEmpty) {\n-        throw Exception(\"Firebase not initialized\");\n-      }\n-\n-      // Test Firebase Storage connection first\n-      try {\n-        _storage.ref().child(\n-          \"connection_test_${DateTime.now().millisecondsSinceEpoch}\",\n-        );\n-        debugPrint(\"ğŸ Testing Firebase Storage connection...\");\n-        // Just create a reference, don't upload\n-        debugPrint(\"âœ… Firebase Storage connection test passed\");\n-      } catch (e) {\n-        debugPrint(\"âŒ Firebase Storage connection test failed: $e\");\n-        throw Exception(\"Firebase Storage not accessible: $e\");\n-      }\n-\n-      // Verify file exists and is readable\n-      if (!await file.exists()) {\n-        throw Exception(\"File does not exist at path: ${file.path}\");\n-      }\n-\n-      final fileSize = await file.length();\n-      debugPrint(\"ğŸ iOS Storage Handler: File size: $fileSize bytes\");\n-\n-      if (fileSize == 0) {\n-        throw Exception(\"File is empty\");\n-      }\n-\n-      // Use simple path first - try without modifications\n-      debugPrint(\"ğŸ iOS Storage Handler: Trying direct upload to: $path\");\n-\n-      final ref = _storage.ref().child(path);\n-\n-      // Set proper metadata for iOS\n-      final metadata = SettableMetadata(\n-        contentType: _getContentType(file.path),\n-        customMetadata: {\n-          'uploaded_by': 'ios_seller_registration',\n-          'original_path': path,\n-          'upload_timestamp': DateTime.now().millisecondsSinceEpoch.toString(),\n-        },\n-      );\n-\n-      debugPrint(\"ğŸ iOS Storage Handler: Creating upload task...\");\n-      final uploadTask = ref.putFile(file, metadata);\n-\n-      // Monitor progress\n-      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n-        if (snapshot.totalBytes > 0) {\n-          final progress =\n-              snapshot.bytesTransferred / snapshot.totalBytes * 100;\n-          debugPrint(\"ğŸ iOS Upload progress: ${progress.toStringAsFixed(1)}%\");\n-        }\n-      });\n-\n-      debugPrint(\"ğŸ iOS Storage Handler: Waiting for upload completion...\");\n-      final snapshot = await uploadTask.whenComplete(() {});\n-\n-      debugPrint(\"ğŸ iOS Storage Handler: Getting download URL...\");\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"âœ… iOS Upload successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"âŒ iOS Storage Handler error: $e\");\n-\n-      // Try alternative upload method for iOS\n-      return await _alternativeUploadMethod(file, path);\n-    }\n-  }\n-\n-  Future<String?> _alternativeUploadMethod(File file, String path) async {\n-    // Try multiple alternative approaches for iOS\n-\n-    // Method 1: putData instead of putFile\n-    try {\n-      debugPrint(\"ğŸ”„ iOS Alternative Method 1: Using putData...\");\n-      await Future.delayed(Duration(milliseconds: 3000));\n-\n-      final bytes = await file.readAsBytes();\n-      debugPrint(\"ğŸ”„ iOS Read ${bytes.length} bytes from file\");\n-\n-      final ref = _storage.ref().child(path);\n-      final uploadTask = ref.putData(\n-        bytes,\n-        SettableMetadata(\n-          contentType: _getContentType(file.path),\n-          customMetadata: {\n-            'uploaded_by': 'ios_alternative_putdata',\n-            'original_path': path,\n-          },\n-        ),\n-      );\n-\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"âœ… iOS Alternative Method 1 successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"âŒ iOS Alternative Method 1 failed: $e\");\n-    }\n-\n-    // Method 2: Different path structure\n-    try {\n-      debugPrint(\"ğŸ”„ iOS Alternative Method 2: Different path structure...\");\n-      await Future.delayed(Duration(milliseconds: 3000));\n-\n-      final timestamp = DateTime.now().millisecondsSinceEpoch;\n-      final altPath = \"mobile_uploads/${path.replaceAll('/', '_')}_$timestamp\";\n-\n-      debugPrint(\"ğŸ”„ iOS Alternative path: $altPath\");\n-\n-      final bytes = await file.readAsBytes();\n-      final ref = _storage.ref().child(altPath);\n-\n-      final uploadTask = ref.putData(\n-        bytes,\n-        SettableMetadata(\n-          contentType: _getContentType(file.path),\n-          customMetadata: {\n-            'uploaded_by': 'ios_alternative_path',\n-            'original_path': path,\n-          },\n-        ),\n-      );\n-\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"âœ… iOS Alternative Method 2 successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"âŒ iOS Alternative Method 2 failed: $e\");\n-    }\n-\n-    // Method 3: Very simple path\n-    try {\n-      debugPrint(\"ğŸ”„ iOS Alternative Method 3: Simple upload...\");\n-      await Future.delayed(Duration(milliseconds: 5000));\n-\n-      final simplePath = \"uploads/${DateTime.now().millisecondsSinceEpoch}\";\n-      debugPrint(\"ğŸ”„ iOS Simple path: $simplePath\");\n-\n-      final bytes = await file.readAsBytes();\n-      final ref = _storage.ref().child(simplePath);\n-\n-      final uploadTask = ref.putData(bytes);\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"âœ… iOS Alternative Method 3 successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"âŒ iOS Alternative Method 3 failed: $e\");\n-    }\n-\n-    debugPrint(\"âŒ All iOS alternative upload methods failed\");\n-    return null;\n-  }\n-\n-  String _getContentType(String filePath) {\n-    final extension = filePath.toLowerCase().split('.').last;\n-    switch (extension) {\n-      case 'jpg':\n-      case 'jpeg':\n-        return 'image/jpeg';\n-      case 'png':\n-        return 'image/png';\n-      case 'gif':\n-        return 'image/gif';\n-      case 'webp':\n-        return 'image/webp';\n-      default:\n-        return 'image/jpeg'; // Default fallback\n-    }\n-  }\n-}\n"
                },
                {
                    "date": 1752575864935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,8 +66,15 @@\n \n   // --- Location ---\n   final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n   final RxString shopAddressText = ''.obs;\n+  final Rxn<LatLng> tempSelectedLocation = Rxn<LatLng>(\n+    null,\n+  ); // Ù„Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¤Ù‚Øª Ø§Ù„Ù…Ø®ØªØ§Ø±\n+  final RxBool isLocationLoading = false.obs; // Ù„Ø­Ø§Ù„Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆÙ‚Ø¹\n+  final RxBool showLocationConfirmation = false.obs; // Ù„Ø¥Ø¸Ù‡Ø§Ø± ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹\n+  final RxBool firstTimeAutoExpand =\n+      true.obs; // Ù„Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„ØªÙˆØ³ÙŠØ¹ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ø£ÙˆÙ„ Ù…Ø±Ø© ÙÙ‚Ø·\n   GoogleMapController? mapController;\n \n   // --- Working Hours ---\n   final List<String> dayKeys = [\n@@ -128,39 +135,62 @@\n       }.obs;\n   final RxnString _lastAppliedOpensAt = RxnString(null);\n   final RxnString _lastAppliedClosesAt = RxnString(null);\n   // --- Main Categories ---\n-  // Ù‚Ø§Ø¦Ù…Ø© Ø´Ø§Ù…Ù„Ø© Ø¨Ø¬Ù…ÙŠØ¹ ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ§Ø¬Ø± Ø§Ù„Ù…Ù…ÙƒÙ†Ø©\n+  // Ù‚Ø§Ø¦Ù…Ø© Ø´Ø§Ù…Ù„Ø© Ø¨ÙØ¦Ø§Øª Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙ‚Ø· (Ù„Ø§ ØªØªØ¶Ù…Ù† Ø§Ù„Ø®Ø¯Ù…Ø§Øª)\n   final List<String> shopCategories = [\n     \"Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ§Øª ÙˆÙ…Ø¹Ø¯Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n-    \"Ù…Ù„Ø§Ø¨Ø³ ÙˆØ£Ø²ÙŠØ§Ø¡\",\n-    \"Ø£Ø­Ø°ÙŠØ© ÙˆØ­Ù‚Ø§Ø¦Ø¨\",\n-    \"Ø·Ø¹Ø§Ù… ÙˆÙ…Ø´Ø±ÙˆØ¨Ø§Øª\",\n-    \"Ù…Ù†ØªØ¬Ø§Øª ØµØ­ÙŠØ© ÙˆØªØ¬Ù…ÙŠÙ„\",\n+    \"Ù‡ÙˆØ§ØªÙ Ø°ÙƒÙŠØ© ÙˆØ£Ø¬Ù‡Ø²Ø© Ù„ÙˆØ­ÙŠØ©\",\n+    \"Ø­Ø§Ø³ÙˆØ¨ ÙˆÙ„Ø§Ø¨ØªÙˆØ¨\",\n+    \"Ù…Ù„Ø§Ø¨Ø³ Ø±Ø¬Ø§Ù„ÙŠØ©\",\n+    \"Ù…Ù„Ø§Ø¨Ø³ Ù†Ø³Ø§Ø¦ÙŠØ©\",\n+    \"Ù…Ù„Ø§Ø¨Ø³ Ø£Ø·ÙØ§Ù„\",\n+    \"Ø£Ø­Ø°ÙŠØ© Ø±Ø¬Ø§Ù„ÙŠØ©\",\n+    \"Ø£Ø­Ø°ÙŠØ© Ù†Ø³Ø§Ø¦ÙŠØ©\",\n+    \"Ø­Ù‚Ø§Ø¦Ø¨ ÙˆÙ…Ø­Ø§ÙØ¸\",\n+    \"Ù…ÙˆØ§Ø¯ ØºØ°Ø§Ø¦ÙŠØ© ÙˆØ¨Ù‚Ø§Ù„Ø©\",\n+    \"Ø­Ù„ÙˆÙŠØ§Øª ÙˆÙ…Ø¹Ø¬Ù†Ø§Øª\",\n+    \"Ù…Ø´Ø±ÙˆØ¨Ø§Øª ÙˆÙ…Ø±Ø·Ø¨Ø§Øª\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª ØµØ­ÙŠØ© ÙˆÙÙŠØªØ§Ù…ÙŠÙ†Ø§Øª\",\n+    \"Ù…Ø³ØªØ­Ø¶Ø±Ø§Øª ØªØ¬Ù…ÙŠÙ„ ÙˆÙ…ÙƒÙŠØ§Ø¬\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø¹Ù†Ø§ÙŠØ© Ø§Ù„Ø´Ø®ØµÙŠØ©\",\n     \"Ø£Ø¯ÙˆÙŠØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª Ø·Ø¨ÙŠØ©\",\n-    \"ÙƒØªØ¨ ÙˆÙ…ÙˆØ§Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠØ©\",\n-    \"Ø£Ù„Ø¹Ø§Ø¨ ÙˆØªØ±ÙÙŠÙ‡\",\n-    \"Ø±ÙŠØ§Ø¶Ø© ÙˆÙ„ÙŠØ§Ù‚Ø©\",\n+    \"ÙƒØªØ¨ ÙˆÙ…Ø¬Ù„Ø§Øª\",\n+    \"Ù…ÙˆØ§Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠØ© ÙˆÙ‚Ø±Ø·Ø§Ø³ÙŠØ©\",\n+    \"Ø£Ù„Ø¹Ø§Ø¨ Ø£Ø·ÙØ§Ù„\",\n+    \"Ø£Ù„Ø¹Ø§Ø¨ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ©\",\n+    \"Ù…Ø¹Ø¯Ø§Øª Ø±ÙŠØ§Ø¶ÙŠØ©\",\n+    \"Ù…Ù„Ø§Ø¨Ø³ Ø±ÙŠØ§Ø¶ÙŠØ©\",\n     \"Ø£Ø¯ÙˆØ§Øª Ù…Ù†Ø²Ù„ÙŠØ© ÙˆÙ…Ø·Ø¨Ø®\",\n-    \"Ø£Ø«Ø§Ø« ÙˆØ¯ÙŠÙƒÙˆØ±\",\n-    \"Ø­Ø¯Ø§Ø¦Ù‚ ÙˆÙ†Ø¨Ø§ØªØ§Øª\",\n-    \"Ø³ÙŠØ§Ø±Ø§Øª ÙˆÙ‚Ø·Ø¹ ØºÙŠØ§Ø±\",\n+    \"Ø£Ø¬Ù‡Ø²Ø© ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠØ© Ù…Ù†Ø²Ù„ÙŠØ©\",\n+    \"Ø£Ø«Ø§Ø« Ù…Ù†Ø²Ù„ÙŠ\",\n+    \"Ø¯ÙŠÙƒÙˆØ± ÙˆÙ…ÙØ±ÙˆØ´Ø§Øª\",\n+    \"Ù†Ø¨Ø§ØªØ§Øª ÙˆØ²Ù‡ÙˆØ±\",\n+    \"Ø£Ø¯ÙˆØ§Øª Ø­Ø¯Ø§Ø¦Ù‚\",\n+    \"Ù‚Ø·Ø¹ ØºÙŠØ§Ø± Ø³ÙŠØ§Ø±Ø§Øª\",\n+    \"Ø¥ÙƒØ³Ø³ÙˆØ§Ø±Ø§Øª Ø³ÙŠØ§Ø±Ø§Øª\",\n     \"Ø£Ø¯ÙˆØ§Øª ÙˆØ¹Ø¯Ø¯ ÙŠØ¯ÙˆÙŠØ©\",\n+    \"Ù…Ø¹Ø¯Ø§Øª ÙˆØ±Ø´\",\n     \"Ù…ÙˆØ§Ø¯ Ø¨Ù†Ø§Ø¡ ÙˆØªØ´ÙŠÙŠØ¯\",\n-    \"Ù…Ø¬ÙˆÙ‡Ø±Ø§Øª ÙˆØ³Ø§Ø¹Ø§Øª\",\n+    \"Ø¯Ù‡Ø§Ù†Ø§Øª ÙˆÙ…ÙˆØ§Ø¯ Ø§Ù„ØªØ´Ø·ÙŠØ¨\",\n+    \"Ù…Ø¬ÙˆÙ‡Ø±Ø§Øª Ø°Ù‡Ø¨ÙŠØ©\",\n+    \"Ø³Ø§Ø¹Ø§Øª ÙˆØ¥ÙƒØ³Ø³ÙˆØ§Ø±Ø§Øª\",\n     \"Ù‡Ø¯Ø§ÙŠØ§ ÙˆØªØ­Ù\",\n-    \"Ø£Ø·ÙØ§Ù„ ÙˆÙ…ÙˆØ§Ù„ÙŠØ¯\",\n-    \"Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø£Ù„ÙŠÙØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª\",\n-    \"Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆØ¢Ù„Ø§Øª Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©\",\n-    \"Ø®Ø¯Ù…Ø§Øª Ù…Ù‡Ù†ÙŠØ©\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØªÙˆØµÙŠÙ„\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØªÙ†Ø¸ÙŠÙ\",\n-    \"Ø®Ø¯Ù…Ø§Øª ØµÙŠØ§Ù†Ø©\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ø£Ø·ÙØ§Ù„ ÙˆØ§Ù„Ù…ÙˆØ§Ù„ÙŠØ¯\",\n+    \"Ù…Ù„Ø§Ø¨Ø³ ÙˆØ£Ø­Ø°ÙŠØ© Ø£Ø·ÙØ§Ù„\",\n+    \"Ø·Ø¹Ø§Ù… ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø£Ù„ÙŠÙØ©\",\n+    \"Ø¢Ù„Ø§Øª Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©\",\n+    \"Ù…Ø¹Ø¯Ø§Øª ØµÙˆØªÙŠØ©\",\n     \"Ù…ÙˆØ§Ø¯ ØºØ°Ø§Ø¦ÙŠØ© Ø¹Ø¶ÙˆÙŠØ©\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª Ø·Ø¨ÙŠØ¹ÙŠØ© ÙˆØ¹Ø´Ø¨ÙŠØ©\",\n     \"Ø­Ø±Ù ÙŠØ¯ÙˆÙŠØ© ÙˆÙÙ†ÙˆÙ†\",\n-    \"Ø£Ù‚Ù…Ø´Ø© ÙˆØ®ÙŠØ§Ø·Ø©\",\n-    \"Ø¹Ø·ÙˆØ± ÙˆÙ…ÙˆØ§Ø¯ ØªØ¬Ù…ÙŠÙ„\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª ØªØ±Ø§Ø«ÙŠØ©\",\n+    \"Ø£Ù‚Ù…Ø´Ø© ÙˆÙ…ÙˆØ§Ø¯ Ø®ÙŠØ§Ø·Ø©\",\n+    \"Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø®ÙŠØ§Ø·Ø© ÙˆØ§Ù„ØªØ·Ø±ÙŠØ²\",\n+    \"Ø¹Ø·ÙˆØ± ÙˆØ¨Ø®ÙˆØ±\",\n+    \"Ø²ÙŠÙˆØª Ø¹Ø·Ø±ÙŠØ© Ø·Ø¨ÙŠØ¹ÙŠØ©\",\n+    \"Ù…Ù†ØªØ¬Ø§Øª Ø±Ù…Ø¶Ø§Ù†ÙŠØ© ÙˆØ¹ÙŠØ¯\",\n+    \"ØªØ­Ù ÙˆÙ…Ù‚ØªÙ†ÙŠØ§Øª\",\n     \"Ø£Ø®Ø±Ù‰\",\n   ];\n \n   // Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 6 ÙØ¦Ø§Øª)\n@@ -1087,24 +1117,37 @@\n     if (workingHours[dayKey] != null) {\n       bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n       workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n \n+      debugPrint(\n+        \"ğŸ”„ Toggling day $dayKey from $isCurrentlyOpen to ${!isCurrentlyOpen}\",\n+      );\n+\n       if (!workingHours[dayKey]!['isOpen']) {\n         // If day is being closed\n         workingHours[dayKey]!['opensAt'] = null;\n         workingHours[dayKey]!['closesAt'] = null;\n         if (expandedDayPanel.value == dayKey) {\n           // Close expansion panel if it was this day\n           expandedDayPanel.value = null;\n+          debugPrint(\"ğŸ”’ Closing expansion panel for $dayKey\");\n         }\n       } else {\n         // If day is being opened\n         workingHours[dayKey]!['opensAt'] =\n             _lastAppliedOpensAt.value ?? \"09:00 AM\";\n         workingHours[dayKey]!['closesAt'] =\n             _lastAppliedClosesAt.value ?? \"05:00 PM\";\n-        // Optionally, open this panel when day is toggled on if not already open by user interaction\n-        // expandedDayPanel.value = dayKey;\n+\n+        // Ø§Ù„ØªÙˆØ³ÙŠØ¹ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø¹Ù†Ø¯ ØªÙØ¹ÙŠÙ„ Ø£ÙŠ ÙŠÙˆÙ…\n+        expandedDayPanel.value = dayKey;\n+        debugPrint(\"ğŸ”“ Auto-expanding panel for $dayKey\");\n+\n+        // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ· Ù„Ø¶Ù…Ø§Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ UI Ù‚Ø¨Ù„ Ø§Ù„ØªÙˆØ³ÙŠØ¹\n+        Future.delayed(Duration(milliseconds: 100), () {\n+          expandedDayPanel.refresh();\n+          debugPrint(\"ğŸ”„ Refreshed expansion panel state\");\n+        });\n       }\n       workingHours.refresh();\n     }\n   }\n@@ -1350,20 +1393,384 @@\n   void onMapCreated(GoogleMapController controller) {\n     mapController = controller;\n   }\n \n+  /// ÙˆØ¸ÙŠÙØ© Ù…Ø­Ø³Ù†Ø© Ù„ÙØªØ­ Ù…Ù†ØªÙ‚ÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ\n   Future<void> openLocationPickerScreen(BuildContext context) async {\n+    LatLng? initialLocation = shopLocation.value;\n+\n+    // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù…ÙˆÙ‚Ø¹ Ù…Ø­ÙÙˆØ¸ØŒ Ø¬Ø±Ø¨ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ\n+    if (initialLocation == null) {\n+      try {\n+        isLocationLoading.value = true;\n+        Position currentPosition = await _determinePosition();\n+        initialLocation = LatLng(\n+          currentPosition.latitude,\n+          currentPosition.longitude,\n+        );\n+        debugPrint(\n+          \"âœ… Current location obtained: ${initialLocation.latitude}, ${initialLocation.longitude}\",\n+        );\n+      } catch (e) {\n+        debugPrint(\"âš ï¸ Could not get current location: $e\");\n+        // Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙˆÙ‚Ø¹ Ø§ÙØªØ±Ø§Ø¶ÙŠ ÙÙŠ Ø¨ØºØ¯Ø§Ø¯ Ø¥Ø°Ø§ ÙØ´Ù„ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ\n+        initialLocation = const LatLng(33.3152, 44.3661);\n+      } finally {\n+        isLocationLoading.value = false;\n+      }\n+    }\n+\n     final LatLng? result = await Get.to<LatLng>(\n-      () => LocationPickerScreen(initialLocation: shopLocation.value),\n+      () => LocationPickerScreen(initialLocation: initialLocation),\n     );\n+\n     if (result != null) {\n       shopLocation.value = result;\n       await _getAddressFromLatLng(result);\n       // Optionally move camera on the small map if it's visible and controller is available\n       mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n     }\n   }\n \n+  /// ÙˆØ¸ÙŠÙØ© Ù„Ø¥Ø¸Ù‡Ø§Ø± Ù…Ù†ØªÙ‚ÙŠ Ù…ÙˆÙ‚Ø¹ Ù…Ø­Ø³Ù† Ù…Ø¹ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹\n+  Future<void> showEnhancedLocationPicker(BuildContext context) async {\n+    LatLng? initialLocation;\n+\n+    // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù…ÙˆÙ‚Ø¹ Ù…Ø­Ø¯Ø¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹ØŒ Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙƒÙ†Ù‚Ø·Ø© Ø¨Ø¯Ø§ÙŠØ©\n+    if (shopLocation.value != null) {\n+      initialLocation = shopLocation.value!;\n+      tempSelectedLocation.value =\n+          shopLocation.value; // ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¤Ù‚Øª Ù„Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯ Ø³Ø§Ø¨Ù‚Ø§Ù‹\n+      showLocationConfirmation.value = true; // Ø¥Ø¸Ù‡Ø§Ø± ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¨Ø§Ø´Ø±Ø©\n+      debugPrint(\n+        \"ğŸ”„ Starting with previously selected location: ${initialLocation.latitude}, ${initialLocation.longitude}\",\n+      );\n+    } else {\n+      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙƒÙ†Ù‚Ø·Ø© Ø¨Ø¯Ø§ÙŠØ©\n+      try {\n+        isLocationLoading.value = true;\n+        Position position = await _determinePosition();\n+        initialLocation = LatLng(position.latitude, position.longitude);\n+        debugPrint(\n+          \"âœ… Starting with current user location: ${initialLocation.latitude}, ${initialLocation.longitude}\",\n+        );\n+      } catch (e) {\n+        debugPrint(\"âš ï¸ Could not get current location: $e\");\n+        initialLocation = const LatLng(33.3152, 44.3661); // Ø¨ØºØ¯Ø§Ø¯ ÙƒÙ…ÙˆÙ‚Ø¹ Ø§ÙØªØ±Ø§Ø¶ÙŠ\n+      } finally {\n+        isLocationLoading.value = false;\n+      }\n+    }\n+\n+    // Ø¹Ø±Ø¶ dialog Ù…Ø®ØµØµ Ù„Ù„Ø®Ø±ÙŠØ·Ø©\n+    await Get.dialog(\n+      Dialog(\n+        backgroundColor: Colors.transparent,\n+        insetPadding: EdgeInsets.all(10),\n+        child: Container(\n+          height: Get.height * 0.8,\n+          width: Get.width * 0.95,\n+          decoration: BoxDecoration(\n+            color: Colors.white,\n+            borderRadius: BorderRadius.circular(20),\n+          ),\n+          child: Column(\n+            children: [\n+              // Header\n+              Container(\n+                padding: EdgeInsets.all(20),\n+                decoration: BoxDecoration(\n+                  gradient: LinearGradient(\n+                    colors: [Color(0xFF6366F1), Color(0xFF8B5CF6)],\n+                    begin: Alignment.centerLeft,\n+                    end: Alignment.centerRight,\n+                  ),\n+                  borderRadius: BorderRadius.only(\n+                    topLeft: Radius.circular(20),\n+                    topRight: Radius.circular(20),\n+                  ),\n+                ),\n+                child: Row(\n+                  children: [\n+                    Icon(\n+                      Icons.location_on_rounded,\n+                      color: Colors.white,\n+                      size: 24,\n+                    ),\n+                    SizedBox(width: 12),\n+                    Expanded(\n+                      child: Text(\n+                        'Ø§Ø®ØªØ± Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…ØªØ¬Ø±',\n+                        style: TextStyle(\n+                          fontSize: 18,\n+                          fontWeight: FontWeight.bold,\n+                          color: Colors.white,\n+                        ),\n+                      ),\n+                    ),\n+                    GestureDetector(\n+                      onTap: () => Get.back(),\n+                      child: Container(\n+                        padding: EdgeInsets.all(8),\n+                        decoration: BoxDecoration(\n+                          color: Colors.white.withOpacity(0.2),\n+                          shape: BoxShape.circle,\n+                        ),\n+                        child: Icon(\n+                          Icons.close_rounded,\n+                          color: Colors.white,\n+                          size: 20,\n+                        ),\n+                      ),\n+                    ),\n+                  ],\n+                ),\n+              ),\n+\n+              // Instructions\n+              Container(\n+                padding: EdgeInsets.all(16),\n+                color: Color(0xFFF8FAFC),\n+                child: Row(\n+                  children: [\n+                    Icon(\n+                      Icons.info_outline,\n+                      color: Color(0xFF6366F1),\n+                      size: 20,\n+                    ),\n+                    SizedBox(width: 8),\n+                    Expanded(\n+                      child: Text(\n+                        'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…ÙˆÙ‚Ø¹ Ù…ØªØ¬Ø±Ùƒ Ø¨Ø¯Ù‚Ø©',\n+                        style: TextStyle(\n+                          fontSize: 14,\n+                          color: Color(0xFF6B7280),\n+                          fontWeight: FontWeight.w500,\n+                        ),\n+                      ),\n+                    ),\n+                  ],\n+                ),\n+              ),\n+\n+              // Map\n+              Expanded(\n+                child: Obx(\n+                  () => Stack(\n+                    children: [\n+                      GoogleMap(\n+                        initialCameraPosition: CameraPosition(\n+                          target: initialLocation!,\n+                          zoom: 15,\n+                        ),\n+                        onTap: (latLng) {\n+                          tempSelectedLocation.value = latLng;\n+                          showLocationConfirmation.value = true;\n+                          _getAddressFromLatLng(latLng); // Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Øµ\n+                        },\n+                        markers: _buildLocationMarkers(\n+                          initialLocation,\n+                          shopLocation.value == null,\n+                        ),\n+                        myLocationEnabled: true,\n+                        myLocationButtonEnabled: true,\n+                        mapType: MapType.normal,\n+                        compassEnabled: true,\n+                        zoomControlsEnabled: false,\n+                      ),\n+\n+                      // Location confirmation overlay\n+                      if (showLocationConfirmation.value)\n+                        _buildLocationConfirmationOverlay(context),\n+                    ],\n+                  ),\n+                ),\n+              ),\n+            ],\n+          ),\n+        ),\n+      ),\n+      barrierDismissible: false,\n+    );\n+\n+    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© Ø¨Ø¹Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù€ dialog\n+    tempSelectedLocation.value = null;\n+    showLocationConfirmation.value = false;\n+  }\n+\n+  /// Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø©\n+  Set<Marker> _buildLocationMarkers(\n+    LatLng? initialLocation, [\n+    bool showCurrentLocationMarker = true,\n+  ]) {\n+    Set<Marker> markers = {};\n+\n+    // Ù…Ø¤Ø´Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… (ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ù…ÙˆÙ‚Ø¹ Ù…Ø­Ø¯Ø¯ Ù…Ø³Ø¨Ù‚Ø§Ù‹)\n+    if (initialLocation != null && showCurrentLocationMarker) {\n+      markers.add(\n+        Marker(\n+          markerId: MarkerId('current_location'),\n+          position: initialLocation,\n+          icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueBlue),\n+          infoWindow: InfoWindow(\n+            title: 'Ù…ÙˆÙ‚Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ',\n+            snippet: 'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ù„Ø§Ø®ØªÙŠØ§Ø± Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…ØªØ¬Ø±',\n+          ),\n+        ),\n+      );\n+    }\n+\n+    // Ù…Ø¤Ø´Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø¤Ù‚Øª Ø§Ù„Ù…Ø®ØªØ§Ø±\n+    if (tempSelectedLocation.value != null) {\n+      markers.add(\n+        Marker(\n+          markerId: MarkerId('selected_location'),\n+          position: tempSelectedLocation.value!,\n+          icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed),\n+          infoWindow: InfoWindow(\n+            title: 'Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…ØªØ¬Ø± Ø§Ù„Ù…Ø®ØªØ§Ø±',\n+            snippet: 'Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ \"ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹\" Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©',\n+          ),\n+        ),\n+      );\n+    }\n+\n+    return markers;\n+  }\n+\n+  /// Ø¨Ù†Ø§Ø¡ overlay ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹\n+  Widget _buildLocationConfirmationOverlay(BuildContext context) {\n+    return Positioned(\n+      bottom: 20,\n+      left: 20,\n+      right: 20,\n+      child: Container(\n+        padding: EdgeInsets.all(20),\n+        decoration: BoxDecoration(\n+          color: Colors.white,\n+          borderRadius: BorderRadius.circular(16),\n+          boxShadow: [\n+            BoxShadow(\n+              color: Colors.black.withOpacity(0.1),\n+              spreadRadius: 0,\n+              blurRadius: 20,\n+              offset: Offset(0, 4),\n+            ),\n+          ],\n+        ),\n+        child: Column(\n+          mainAxisSize: MainAxisSize.min,\n+          children: [\n+            Row(\n+              children: [\n+                Container(\n+                  padding: EdgeInsets.all(8),\n+                  decoration: BoxDecoration(\n+                    color: Color(0xFF10B981).withOpacity(0.1),\n+                    borderRadius: BorderRadius.circular(8),\n+                  ),\n+                  child: Icon(\n+                    Icons.location_on_rounded,\n+                    color: Color(0xFF10B981),\n+                    size: 20,\n+                  ),\n+                ),\n+                SizedBox(width: 12),\n+                Expanded(\n+                  child: Column(\n+                    crossAxisAlignment: CrossAxisAlignment.start,\n+                    children: [\n+                      Text(\n+                        'Ù…ÙˆÙ‚Ø¹ Ù…Ø®ØªØ§Ø±',\n+                        style: TextStyle(\n+                          fontSize: 16,\n+                          fontWeight: FontWeight.w600,\n+                          color: Color(0xFF1F2937),\n+                        ),\n+                      ),\n+                      Obx(\n+                        () => Text(\n+                          shopAddressText.value.isNotEmpty\n+                              ? shopAddressText.value\n+                              : 'Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†...',\n+                          style: TextStyle(\n+                            fontSize: 12,\n+                            color: Color(0xFF6B7280),\n+                          ),\n+                          maxLines: 2,\n+                          overflow: TextOverflow.ellipsis,\n+                        ),\n+                      ),\n+                    ],\n+                  ),\n+                ),\n+              ],\n+            ),\n+            SizedBox(height: 16),\n+            Row(\n+              children: [\n+                Expanded(\n+                  child: OutlinedButton(\n+                    onPressed: () {\n+                      tempSelectedLocation.value = null;\n+                      showLocationConfirmation.value = false;\n+                    },\n+                    style: OutlinedButton.styleFrom(\n+                      foregroundColor: Color(0xFF6B7280),\n+                      side: BorderSide(color: Color(0xFFE5E7EB)),\n+                      padding: EdgeInsets.symmetric(vertical: 12),\n+                      shape: RoundedRectangleBorder(\n+                        borderRadius: BorderRadius.circular(12),\n+                      ),\n+                    ),\n+                    child: Text('Ø¥Ù„ØºØ§Ø¡'),\n+                  ),\n+                ),\n+                SizedBox(width: 12),\n+                Expanded(\n+                  flex: 2,\n+                  child: ElevatedButton(\n+                    onPressed: () {\n+                      if (tempSelectedLocation.value != null) {\n+                        shopLocation.value = tempSelectedLocation.value;\n+                        Get.back();\n+                        Get.snackbar(\n+                          \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ¯\",\n+                          \"ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…ØªØ¬Ø± Ø¨Ù†Ø¬Ø§Ø­\",\n+                          backgroundColor: Color(0xFF10B981),\n+                          colorText: Colors.white,\n+                          snackPosition: SnackPosition.BOTTOM,\n+                          icon: Icon(Icons.check_circle, color: Colors.white),\n+                        );\n+                      }\n+                    },\n+                    style: ElevatedButton.styleFrom(\n+                      backgroundColor: Color(0xFF10B981),\n+                      foregroundColor: Colors.white,\n+                      padding: EdgeInsets.symmetric(vertical: 12),\n+                      shape: RoundedRectangleBorder(\n+                        borderRadius: BorderRadius.circular(12),\n+                      ),\n+                      elevation: 0,\n+                    ),\n+                    child: Row(\n+                      mainAxisAlignment: MainAxisAlignment.center,\n+                      children: [\n+                        Icon(Icons.check_circle, size: 18),\n+                        SizedBox(width: 8),\n+                        Text('ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹'),\n+                      ],\n+                    ),\n+                  ),\n+                ),\n+              ],\n+            ),\n+          ],\n+        ),\n+      ),\n+    );\n+  }\n+\n   Future<void> _getAddressFromLatLng(LatLng latLng) async {\n     try {\n       List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n         latLng.latitude,\n@@ -1390,10 +1797,11 @@\n       shopAddressText.value = \"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n     }\n   }\n \n+  /// Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…ØªØ¬Ø±\n   Future<void> tryMoveToCurrentLocation() async {\n-    isLoading.value = true; // Indicate loading for location fetch\n+    isLocationLoading.value = true;\n     update();\n     try {\n       Position currentPosition = await _determinePosition();\n       LatLng newLatLng = LatLng(\n@@ -1402,16 +1810,28 @@\n       );\n       shopLocation.value = newLatLng;\n       await _getAddressFromLatLng(newLatLng);\n       mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n+\n+      Get.snackbar(\n+        \"ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹\",\n+        \"ØªÙ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ù†Ø¬Ø§Ø­\",\n+        backgroundColor: Color(0xFF10B981),\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+        icon: Icon(Icons.my_location, color: Colors.white),\n+      );\n     } catch (e) {\n       Get.snackbar(\n-        \"Ø®Ø·Ø£\",\n+        \"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙˆÙ‚Ø¹\",\n         \"ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${e.toString()}\",\n+        backgroundColor: Color(0xFFEF4444),\n+        colorText: Colors.white,\n         snackPosition: SnackPosition.BOTTOM,\n+        icon: Icon(Icons.error_outline, color: Colors.white),\n       );\n     } finally {\n-      isLoading.value = false;\n+      isLocationLoading.value = false;\n       update();\n     }\n   }\n \n"
                },
                {
                    "date": 1752700868696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -867,8 +867,9 @@\n         isActiveBySeller: true, // Ù†Ø´Ø· Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§\n         isPhoneNumberVerified: true, // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n         averageRating: 0.0,\n         numberOfRatings: 0,\n+         trustScore: 50.0 ,\n         sellerType: _sellerTypeFromAuth, // Ù…Ù† SellerAuthController\n         registrationCompleted: true, // Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n         createdAt:\n             Timestamp.now(), // Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ FieldValue.serverTimestamp() Ø£Ø¯Ù†Ø§Ù‡\n@@ -907,8 +908,9 @@\n \n       debugPrint(\"ğŸ’¾ Saving seller data to Firestore...\");\n       debugPrint(\"ğŸ’¾ Document ID: ${currentUser.uid}\");\n       debugPrint(\"ğŸ’¾ Collection: ${FirebaseX.collectionSeller}\");\n+      debugPrint(\"ğŸ† Trust Score: 50.0 (auto-assigned to new seller)\");\n \n       await _firestore\n           .collection(FirebaseX.collectionSeller)\n           .doc(currentUser.uid)\n"
                },
                {
                    "date": 1752837553514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -426,23 +426,20 @@\n         \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n       );\n       debugPrint(\"FirebaseAuth instance: $_auth\");\n \n-      // ØªÙØ¹ÙŠÙ„ reCAPTCHA Ù„Ù„Ù€ iOS ØµØ±Ø§Ø­Ø©\n+      // ØªÙØ¹ÙŠÙ„ reCAPTCHA Ù„Ù„Ù€ iOS Ù„Ù„Ø¬Ù…ÙŠØ¹\n       if (Platform.isIOS) {\n         debugPrint(\"Setting up reCAPTCHA for iOS...\");\n         try {\n-          // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±\n-          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n-\n           await _auth.setSettings(\n             appVerificationDisabledForTesting:\n-                isTestNumber, // Ù„Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ ÙÙ‚Ø·\n-            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA Ù„Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙÙ‚Ø·\n+                false, // Ø¥Ø²Ø§Ù„Ø© Ø¯Ø¹Ù… Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠØ©\n+            forceRecaptchaFlow: true, // reCAPTCHA Ù„Ù„Ø¬Ù…ÙŠØ¹\n           );\n \n           debugPrint(\"âœ… Firebase Auth settings configured for iOS\");\n-          debugPrint(\"ğŸ“± Test number mode: $isTestNumber\");\n+          debugPrint(\"âœ… Firebase Auth settings configured for iOS\");\n \n           // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚\n           await Future.delayed(const Duration(milliseconds: 500));\n         } catch (e) {\n@@ -867,9 +864,9 @@\n         isActiveBySeller: true, // Ù†Ø´Ø· Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§\n         isPhoneNumberVerified: true, // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n         averageRating: 0.0,\n         numberOfRatings: 0,\n-         trustScore: 50.0 ,\n+        trustScore: 50.0,\n         sellerType: _sellerTypeFromAuth, // Ù…Ù† SellerAuthController\n         registrationCompleted: true, // Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n         createdAt:\n             Timestamp.now(), // Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ FieldValue.serverTimestamp() Ø£Ø¯Ù†Ø§Ù‡\n"
                }
            ],
            "date": 1752491126687,
            "name": "Commit-0",
            "content": "import 'dart:io';\nimport 'dart:async';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:codora/%D8%A7%D9%84%D9%83%D9%88%D8%AF%20%D8%A7%D9%84%D8%AE%D8%A7%D8%B5%20%D8%A8%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%20%D8%A7%D9%84%D8%A8%D8%A7%D8%A6%D8%B9/seller_app_auth/controllers/seller_auth_controller.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:flutter/material.dart';\nimport 'package:geolocator/geolocator.dart';\nimport 'package:get/get.dart';\nimport 'package:get_storage/get_storage.dart';\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:intl/intl.dart'; // For DateFormat\nimport 'package:geocoding/geocoding.dart' as geo;\n\nimport '../../../XXX/xxx_firebase.dart';\nimport '../../../Model/SellerModel.dart';\nimport '../../ui/seller_main_screen.dart';\nimport '../ui/OtpVerificationScreen.dart';\nimport '../ui/LocationPickerScreen.dart';\n\nclass SellerRegistrationController extends GetxController {\n  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n  RxDouble currentPositionAccuracy = 0.0.obs;\n\n  // --- Firebase Instances ---\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n  final FirebaseStorage _storage = FirebaseStorage.instance;\n  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n  final RxString verificationId = ''.obs; // To store Firebase's verification ID\n\n  // iOS-specific Firebase Storage handler\n  late IOSFirebaseStorageHandler _iosStorageHandler;\n\n  // ==========================================================================\n  // ==========================================================================\n  // ==========================================================================\n\n  // Ù„Ø¥Ø¶Ø§ÙØ© Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹\n  String? _sellerTypeFromAuth; // Ø³ÙŠØªÙ… Ø¬Ù„Ø¨ Ù‡Ø°Ø§ Ù…Ù† SellerAuthController\n\n  final Rxn<int> resendToken = Rxn<int>(null); // For resending OTP\n  final TextEditingController otpController = TextEditingController();\n  final RxBool isOtpSending = false.obs; // Loading state for OTP sending\n  final RxBool isOtpVerifying = false.obs; // Loading state for OTP verification\n  Map<String, dynamic>? _tempSellerDataForSubmission;\n  File? _tempSellerProfileImageFile;\n  File? _tempShopFrontImageFile;\n\n  // --- Text Editing Controllers ---\n  final TextEditingController sellerNameController = TextEditingController();\n  final TextEditingController shopNameController = TextEditingController();\n  final TextEditingController shopPhoneNumberController =\n      TextEditingController();\n  final TextEditingController shopDescriptionController =\n      TextEditingController();\n  // Add more controllers for other text fields like commercial reg no., etc.\n\n  // --- Image Pickers ---\n  final ImagePicker _picker = ImagePicker();\n  final Rxn<File> sellerProfileImageFile = Rxn<File>(null);\n  final Rxn<File> shopFrontImageFile = Rxn<File>(null);\n\n  // --- Location ---\n  final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n  final RxString shopAddressText = ''.obs;\n  GoogleMapController? mapController;\n\n  // --- Working Hours ---\n  final List<String> dayKeys = [\n    \"sunday_en\",\n    \"monday_en\",\n    \"tuesday_en\",\n    \"wednesday_en\",\n    \"thursday_en\",\n    \"friday_en\",\n    \"saturday_en\",\n  ];\n  final RxnString expandedDayPanel = RxnString(null); // For ExpansionPanelList\n\n  final RxMap<String, Map<String, dynamic>> workingHours =\n      <String, Map<String, dynamic>>{\n        \"sunday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø£Ø­Ø¯\",\n        },\n        \"monday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø§Ø«Ù†ÙŠÙ†\",\n        },\n        \"tuesday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø«Ù„Ø§Ø«Ø§Ø¡\",\n        },\n        \"wednesday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø£Ø±Ø¨Ø¹Ø§Ø¡\",\n        },\n        \"thursday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø®Ù…ÙŠØ³\",\n        },\n        \"friday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø¬Ù…Ø¹Ø©\",\n        },\n        \"saturday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"Ø§Ù„Ø³Ø¨Øª\",\n        },\n      }.obs;\n  final RxnString _lastAppliedOpensAt = RxnString(null);\n  final RxnString _lastAppliedClosesAt = RxnString(null);\n  // --- Main Categories ---\n  // Ù‚Ø§Ø¦Ù…Ø© Ø´Ø§Ù…Ù„Ø© Ø¨Ø¬Ù…ÙŠØ¹ ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ§Ø¬Ø± Ø§Ù„Ù…Ù…ÙƒÙ†Ø©\n  final List<String> shopCategories = [\n    \"Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠØ§Øª ÙˆÙ…Ø¹Ø¯Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n    \"Ù…Ù„Ø§Ø¨Ø³ ÙˆØ£Ø²ÙŠØ§Ø¡\",\n    \"Ø£Ø­Ø°ÙŠØ© ÙˆØ­Ù‚Ø§Ø¦Ø¨\",\n    \"Ø·Ø¹Ø§Ù… ÙˆÙ…Ø´Ø±ÙˆØ¨Ø§Øª\",\n    \"Ù…Ù†ØªØ¬Ø§Øª ØµØ­ÙŠØ© ÙˆØªØ¬Ù…ÙŠÙ„\",\n    \"Ø£Ø¯ÙˆÙŠØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª Ø·Ø¨ÙŠØ©\",\n    \"ÙƒØªØ¨ ÙˆÙ…ÙˆØ§Ø¯ ØªØ¹Ù„ÙŠÙ…ÙŠØ©\",\n    \"Ø£Ù„Ø¹Ø§Ø¨ ÙˆØªØ±ÙÙŠÙ‡\",\n    \"Ø±ÙŠØ§Ø¶Ø© ÙˆÙ„ÙŠØ§Ù‚Ø©\",\n    \"Ø£Ø¯ÙˆØ§Øª Ù…Ù†Ø²Ù„ÙŠØ© ÙˆÙ…Ø·Ø¨Ø®\",\n    \"Ø£Ø«Ø§Ø« ÙˆØ¯ÙŠÙƒÙˆØ±\",\n    \"Ø­Ø¯Ø§Ø¦Ù‚ ÙˆÙ†Ø¨Ø§ØªØ§Øª\",\n    \"Ø³ÙŠØ§Ø±Ø§Øª ÙˆÙ‚Ø·Ø¹ ØºÙŠØ§Ø±\",\n    \"Ø£Ø¯ÙˆØ§Øª ÙˆØ¹Ø¯Ø¯ ÙŠØ¯ÙˆÙŠØ©\",\n    \"Ù…ÙˆØ§Ø¯ Ø¨Ù†Ø§Ø¡ ÙˆØªØ´ÙŠÙŠØ¯\",\n    \"Ù…Ø¬ÙˆÙ‡Ø±Ø§Øª ÙˆØ³Ø§Ø¹Ø§Øª\",\n    \"Ù‡Ø¯Ø§ÙŠØ§ ÙˆØªØ­Ù\",\n    \"Ø£Ø·ÙØ§Ù„ ÙˆÙ…ÙˆØ§Ù„ÙŠØ¯\",\n    \"Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø£Ù„ÙŠÙØ© ÙˆÙ…Ø³ØªÙ„Ø²Ù…Ø§Øª\",\n    \"Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆØ¢Ù„Ø§Øª Ù…ÙˆØ³ÙŠÙ‚ÙŠØ©\",\n    \"Ø®Ø¯Ù…Ø§Øª Ù…Ù‡Ù†ÙŠØ©\",\n    \"Ø®Ø¯Ù…Ø§Øª ØªÙ‚Ù†ÙŠØ©\",\n    \"Ø®Ø¯Ù…Ø§Øª ØªÙˆØµÙŠÙ„\",\n    \"Ø®Ø¯Ù…Ø§Øª ØªÙ†Ø¸ÙŠÙ\",\n    \"Ø®Ø¯Ù…Ø§Øª ØµÙŠØ§Ù†Ø©\",\n    \"Ù…ÙˆØ§Ø¯ ØºØ°Ø§Ø¦ÙŠØ© Ø¹Ø¶ÙˆÙŠØ©\",\n    \"Ø­Ø±Ù ÙŠØ¯ÙˆÙŠØ© ÙˆÙÙ†ÙˆÙ†\",\n    \"Ø£Ù‚Ù…Ø´Ø© ÙˆØ®ÙŠØ§Ø·Ø©\",\n    \"Ø¹Ø·ÙˆØ± ÙˆÙ…ÙˆØ§Ø¯ ØªØ¬Ù…ÙŠÙ„\",\n    \"Ø£Ø®Ø±Ù‰\",\n  ];\n\n  // Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 6 ÙØ¦Ø§Øª)\n  final RxList<String> selectedShopCategories = <String>[].obs;\n  final int maxCategoriesAllowed = 6;\n\n  // --- Loading State ---\n  final RxBool isLoading = false.obs;\n\n  @override\n  void onInit() {\n    super.onInit();\n\n    // Initialize iOS-specific storage handler\n    if (Platform.isIOS) {\n      _iosStorageHandler = IOSFirebaseStorageHandler(_storage);\n    }\n\n    // Ø¬Ù„Ø¨ SellerAuthController ÙˆØ§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ sellerType\n    try {\n      final SellerAuthController authController =\n          Get.find<SellerAuthController>();\n      _sellerTypeFromAuth = authController.sellerType;\n      if (_sellerTypeFromAuth != null) {\n        debugPrint(\n          \"SellerRegistrationController: ØªÙ… Ø¬Ù„Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹ Ù…Ù† AuthController: $_sellerTypeFromAuth\",\n        );\n      } else {\n        debugPrint(\n          \"SellerRegistrationController: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ sellerType ÙÙŠ AuthController. Ù‚Ø¯ ÙŠØ­ØªØ§Ø¬ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„Ù„Ø¹ÙˆØ¯Ø© ÙˆØ§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù†ÙˆØ¹.\",\n        );\n        // ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ Ø¥Ø¶Ø§ÙØ© Ù…Ù†Ø·Ù‚ Ù„ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø°Ø§ ÙƒØ§Ù† sellerType Ø¶Ø±ÙˆØ±ÙŠÙ‹Ø§ ÙˆÙ„Ø§ ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† null\n        // Ù…Ø«Ø§Ù„: Get.offAll(() => SellerTypeSelectionScreen()); Ø£Ùˆ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø®Ø·Ø£\n      }\n    } catch (e) {\n      debugPrint(\n        \"SellerRegistrationController: Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ SellerAuthController Ø£Ùˆ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ sellerType: $e\",\n      );\n      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø®Ø·Ø£ØŒ Ø±Ø¨Ù…Ø§ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø©\n    }\n  }\n\n  @override\n  void onClose() {\n    sellerNameController.dispose();\n    shopNameController.dispose();\n    shopPhoneNumberController.dispose();\n    shopDescriptionController.dispose();\n    mapController?.dispose();\n    otpController.dispose();\n    super.onClose();\n  }\n\n  void removeImage({required bool isProfileImage}) {\n    if (isProfileImage) {\n      sellerProfileImageFile.value = null;\n    } else {\n      shopFrontImageFile.value = null;\n    }\n    update(); // For GetBuilder if used, or just rely on Obx for reactive updates\n  }\n\n  Future<void> initiatePhoneVerificationAndCollectData() async {\n    debugPrint(\"ğŸš€ initiatePhoneVerificationAndCollectData called\");\n    debugPrint(\"Form validation starting...\");\n\n    if (!formKey.currentState!.validate()) {\n      debugPrint(\"âŒ Form validation failed\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"âœ… Form validation passed\");\n\n    // --- Add all your previous validations ---\n    debugPrint(\"Checking profile image...\");\n    if (sellerProfileImageFile.value == null) {\n      debugPrint(\"âŒ No profile image selected\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ø´Ø®ØµÙŠØ©.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"âœ… Profile image validation passed\");\n\n    debugPrint(\"Checking shop front image...\");\n    if (shopFrontImageFile.value == null) {\n      debugPrint(\"âŒ No shop front image selected\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø­Ù„.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"âœ… Shop front image validation passed\");\n\n    debugPrint(\"Checking shop location...\");\n    if (shopLocation.value == null) {\n      debugPrint(\"âŒ No shop location selected\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù…Ø­Ù„.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"âœ… Shop location validation passed\");\n\n    debugPrint(\"Checking shop category...\");\n    if (selectedShopCategories.isEmpty) {\n      debugPrint(\"âŒ No shop categories selected\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ÙØ¦Ø© ÙˆØ§Ø­Ø¯Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ù„Ù„Ù…ØªØ¬Ø±.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\n      \"âœ… Shop categories validation passed: ${selectedShopCategories.length} categories selected\",\n    );\n\n    // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† _sellerTypeFromAuth ÙØ§Ø±ØºÙ‹Ø§ Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© (Ø¥Ø°Ø§ ÙƒØ§Ù† Ø¥Ù„Ø²Ø§Ù…ÙŠÙ‹Ø§)\n    debugPrint(\"Checking seller type...\");\n    if (_sellerTypeFromAuth == null || _sellerTypeFromAuth!.isEmpty) {\n      debugPrint(\"âŒ No seller type selected\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø±Ø¬ÙˆØ¹ ÙˆØ§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹.\",\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"âœ… Seller type validation passed: $_sellerTypeFromAuth\");\n\n    debugPrint(\"Checking working hours...\");\n    bool workingHoursValid = true;\n    String firstInvalidDay = \"\";\n    workingHours.forEach((key, value) {\n      if ((value['isOpen'] == true) &&\n          (value['opensAt'] == null || value['closesAt'] == null)) {\n        workingHoursValid = false;\n        firstInvalidDay = value['name_ar'] as String;\n        return;\n      }\n    });\n    if (!workingHoursValid) {\n      debugPrint(\"âŒ Working hours validation failed for day: $firstInvalidDay\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ÙØªØ­ ÙˆØ§Ù„Ø¥ØºÙ„Ø§Ù‚ Ù„Ù„ÙŠÙˆÙ… Ø§Ù„Ù…ÙØªÙˆØ­: $firstInvalidDay.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"âœ… Working hours validation passed\");\n\n    String rawPhoneNumber = shopPhoneNumberController.text.trim();\n    rawPhoneNumber = rawPhoneNumber.replaceAll(RegExp(r'\\s+'), '');\n    if (rawPhoneNumber.startsWith('0')) {\n      rawPhoneNumber = rawPhoneNumber.substring(1);\n    }\n    const String countryCode = \"+964\";\n    final String formattedPhoneNumber = \"$countryCode$rawPhoneNumber\";\n    debugPrint(\"Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ø¯Ø®Ù„ Ø§Ù„Ø£ØµÙ„ÙŠ: ${shopPhoneNumberController.text}\");\n    debugPrint(\n      \"Ø§Ù„Ø±Ù‚Ù… Ø¨Ø¹Ø¯ Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„ØµÙØ± ÙˆØ¥Ø¶Ø§ÙØ© Ø±Ù…Ø² Ø§Ù„Ø¯ÙˆÙ„Ø©: $formattedPhoneNumber\",\n    );\n\n    final RegExp iraqiPhoneNumberRegExp = RegExp(r'^\\+9647[3-9]\\d{8}$');\n    debugPrint(\"Checking phone number validation: $formattedPhoneNumber\");\n    if (!iraqiPhoneNumberRegExp.hasMatch(formattedPhoneNumber)) {\n      debugPrint(\"Phone number validation failed for: $formattedPhoneNumber\");\n      Get.snackbar(\n        \"Ø±Ù‚Ù… Ù‡Ø§ØªÙ ØºÙŠØ± ØµØ§Ù„Ø­\",\n        \"Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ù‡Ø§ØªÙ Ø¹Ø±Ø§Ù‚ÙŠ ØµØ­ÙŠØ­.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"Phone number validation passed\");\n\n    // ---- Set loading states ----\n    debugPrint(\"Setting loading states...\");\n    isOtpSending.value = true;\n    isLoading.value = true;\n    update();\n    debugPrint(\"Loading states set successfully\");\n\n    try {\n      debugPrint(\"Preparing temp data for submission...\");\n      _tempSellerProfileImageFile = sellerProfileImageFile.value;\n      _tempShopFrontImageFile = shopFrontImageFile.value;\n      _tempSellerDataForSubmission = {\n        \"sellerName\": sellerNameController.text.trim(),\n        \"shopName\": shopNameController.text.trim(),\n        \"shopPhoneNumber\": shopPhoneNumberController.text.trim(),\n        \"shopDescription\": shopDescriptionController.text.trim(),\n        \"location\": GeoPoint(\n          shopLocation.value!.latitude,\n          shopLocation.value!.longitude,\n        ),\n        \"shopAddressText\": shopAddressText.value,\n        \"shopCategories\": selectedShopCategories.toList(),\n        \"workingHours\": Map<String, Map<String, dynamic>>.from(workingHours),\n        \"streetAddress\": streetAddressController.text.trim(),\n      };\n      debugPrint(\"Temp data prepared successfully\");\n\n      debugPrint(\n        \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n      );\n      debugPrint(\"FirebaseAuth instance: $_auth\");\n\n      // ØªÙØ¹ÙŠÙ„ reCAPTCHA Ù„Ù„Ù€ iOS ØµØ±Ø§Ø­Ø©\n      if (Platform.isIOS) {\n        debugPrint(\"Setting up reCAPTCHA for iOS...\");\n        try {\n          // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±\n          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n\n          await _auth.setSettings(\n            appVerificationDisabledForTesting:\n                isTestNumber, // Ù„Ù„Ø±Ù‚Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ ÙÙ‚Ø·\n            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA Ù„Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© ÙÙ‚Ø·\n          );\n\n          debugPrint(\"âœ… Firebase Auth settings configured for iOS\");\n          debugPrint(\"ğŸ“± Test number mode: $isTestNumber\");\n\n          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¨Ø§Ù„ØªØ·Ø¨ÙŠÙ‚\n          await Future.delayed(const Duration(milliseconds: 500));\n        } catch (e) {\n          debugPrint(\"âš ï¸ Error setting Firebase Auth settings: $e\");\n          // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª reCAPTCHAØŒ Ø¬Ø±Ø¨ Ø¨Ø¯ÙˆÙ†Ù‡Ø§\n          debugPrint(\"ğŸ”„ Trying without forced reCAPTCHA...\");\n        }\n      }\n\n      // Ø¥Ø¶Ø§ÙØ© timeout Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ù…Ù„ Ø§Ù„Ù€ callbacks\n      Timer callbackTimeoutTimer = Timer(const Duration(seconds: 30), () {\n        if (isOtpSending.value || isLoading.value) {\n          debugPrint(\"âš ï¸ Callback timeout - reCAPTCHA may not have appeared\");\n          debugPrint(\"âš ï¸ This usually means Firebase Console settings issue\");\n          isOtpSending.value = false;\n          isLoading.value = false;\n          isOtpVerifying.value = false;\n          update();\n          Get.snackbar(\n            \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚\",\n            \"Ù„Ù… ØªØ¸Ù‡Ø± ØµÙØ­Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ØªØ­Ù‚Ù‚ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Firebase Ø£Ùˆ Ø¬Ø±Ø¨ Ø±Ù‚Ù…Ø§Ù‹ Ø¢Ø®Ø±.\",\n            backgroundColor: Colors.orange.shade400,\n            colorText: Colors.white,\n            snackPosition: SnackPosition.BOTTOM,\n            duration: const Duration(seconds: 5),\n          );\n        }\n      });\n\n      await _auth.verifyPhoneNumber(\n        phoneNumber: formattedPhoneNumber,\n        forceResendingToken: resendToken.value,\n        verificationCompleted: (PhoneAuthCredential credential) async {\n          debugPrint(\"ğŸ‰ VERIFICATION COMPLETED CALLBACK TRIGGERED\");\n          debugPrint(\n            \"Phone auto-verified. Credential SMS code (if available): ${credential.smsCode}\",\n          );\n\n          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n          callbackTimeoutTimer.cancel();\n\n          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ù‚Ø¨Ù„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©\n          isOtpSending.value = false;\n          isLoading.value = true;\n          isOtpVerifying.value = true;\n          update();\n\n          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ UI Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¹Ù„Ù‰ iOS\n          if (Platform.isIOS) {\n            await Future.delayed(const Duration(milliseconds: 100));\n          }\n\n          await _finalizeSellerRegistration(isAutoVerified: true);\n        },\n        verificationFailed: (FirebaseAuthException e) {\n          debugPrint(\"âŒ VERIFICATION FAILED CALLBACK TRIGGERED\");\n          debugPrint(\"Phone verification failed: ${e.code} - ${e.message}\");\n          debugPrint(\"Full error: ${e.toString()}\");\n\n          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n          callbackTimeoutTimer.cancel();\n\n          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª\n          isOtpSending.value = false;\n          isLoading.value = false;\n          isOtpVerifying.value = false;\n          update();\n\n          String errorMessage = \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ.\";\n          if (e.code == 'invalid-phone-number') {\n            errorMessage =\n                \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ $formattedPhoneNumber Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ§Ù„Ø­.\";\n          } else if (e.code == 'too-many-requests') {\n            errorMessage =\n                \"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§ Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ù„Ø§Ø­Ù‚Ù‹Ø§.\";\n          } else if (e.code == 'network-request-failed') {\n            errorMessage =\n                \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\";\n          }\n          Get.snackbar(\n            \"Ø®Ø·Ø£\",\n            errorMessage,\n            backgroundColor: Colors.red.shade400,\n            colorText: Colors.white,\n            snackPosition: SnackPosition.BOTTOM,\n          );\n        },\n        codeSent: (String verId, int? resendTok) async {\n          debugPrint(\"ğŸ“± CODE SENT CALLBACK TRIGGERED\");\n          debugPrint(\n            \"OTP code sent. Verification ID: $verId, Resend Token: $resendTok\",\n          );\n\n          // Ø¥Ù„ØºØ§Ø¡ timeout timer\n          callbackTimeoutTimer.cancel();\n\n          isOtpSending.value = false; // OTP sending part is done\n          // isLoading remains true as we are waiting for OTP input\n          update();\n\n          verificationId.value = verId;\n          resendToken.value = resendTok;\n\n          // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ø¹Ù„Ù‰ iOS Ù„Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù€ UI Ø¨Ø§Ù„ØªØ­Ø¯ÙŠØ« Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n          if (Platform.isIOS) {\n            await Future.delayed(const Duration(milliseconds: 200));\n          }\n\n          // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„ØªÙ†Ù‚Ù„ ÙŠØ­Ø¯Ø« Ø¹Ù„Ù‰ Ø§Ù„Ù€ main thread\n          WidgetsBinding.instance.addPostFrameCallback((_) {\n            debugPrint(\"Navigating to OTP verification screen...\");\n            Get.to(() => OtpVerificationScreen());\n          });\n        },\n        codeAutoRetrievalTimeout: (String verId) {\n          debugPrint(\"â° CODE AUTO RETRIEVAL TIMEOUT CALLBACK TRIGGERED\");\n          debugPrint(\"OTP auto-retrieval timed out. Verification ID: $verId\");\n          verificationId.value = verId;\n          // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† isOtpSending ÙÙŠ Ø­Ø§Ù„ timeout Ø¹Ù„Ù‰ iOS\n          if (Platform.isIOS) {\n            isOtpSending.value = false;\n            update();\n          }\n        },\n        timeout:\n            Platform.isIOS\n                ? const Duration(seconds: 60) // Ù…Ø¯Ø© Ø£Ù‚ØµØ± Ø¹Ù„Ù‰ iOS\n                : const Duration(seconds: 120), // Ù…Ø¯Ø© Ø£Ø·ÙˆÙ„ Ø¹Ù„Ù‰ Android\n      );\n      debugPrint(\"âœ… verifyPhoneNumber call completed successfully\");\n    } catch (e) {\n      debugPrint(\"ğŸš¨ EXCEPTION CAUGHT IN verifyPhoneNumber\");\n      debugPrint(\"Exception type: ${e.runtimeType}\");\n      debugPrint(\"Exception details: $e\");\n\n      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø§Ù„Ø§Øª ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£\n      isOtpSending.value = false;\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      update();\n\n      String errorMessage = \"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ.\";\n\n      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…Ø­Ø¯Ø¯Ø©\n      if (e.toString().contains('network')) {\n        errorMessage = \"Ù…Ø´ÙƒÙ„Ø© ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.\";\n      } else if (e.toString().contains('too-many-requests')) {\n        errorMessage = \"ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø¹Ø¯Ø¯ ÙƒØ¨ÙŠØ± Ù…Ù† Ø§Ù„Ø·Ù„Ø¨Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹.\";\n      }\n\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        errorMessage,\n        backgroundColor: Colors.red.shade500,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<void> verifyOtpAndFinalize(String otpCode) async {\n    if (otpCode.isEmpty || otpCode.length < 6) {\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² OTP Ø§Ù„ØµØ­ÙŠØ­ Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 6 Ø£Ø±Ù‚Ø§Ù….\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n\n    isOtpVerifying.value = true;\n    isLoading.value =\n        true; // isLoading should ideally be true from the previous step\n    update();\n\n    try {\n      PhoneAuthCredential credential = PhoneAuthProvider.credential(\n        verificationId: verificationId.value,\n        smsCode: otpCode,\n      );\n\n      // **** Ø®Ø·ÙˆØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù…Ù† Ø§Ù„Ù€ Credential Ù‡Ù†Ø§ ****\n      final User? currentUser = _auth.currentUser;\n      if (currentUser == null) {\n        throw FirebaseAuthException(\n          code: 'no-current-user',\n          message: 'No user is currently signed in.',\n        );\n      }\n\n      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø±Ø¨Ø· Ø§Ù„Ù€ Credential Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† OTP\n      try {\n        await currentUser.linkWithCredential(credential);\n        debugPrint(\"Phone credential linked successfully.\");\n      } catch (linkError) {\n        if (linkError is FirebaseAuthException &&\n            linkError.code == 'provider-already-linked') {\n          debugPrint(\n            \"Phone provider already linked, verifying OTP directly...\",\n          );\n          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø²ÙˆØ¯ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ØŒ Ù†ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© OTP ÙÙ‚Ø·\n          await _auth.signInWithCredential(credential);\n          debugPrint(\n            \"OTP verified successfully with existing linked provider.\",\n          );\n        } else {\n          rethrow; // Ø¥Ø¹Ø§Ø¯Ø© Ø·Ø±Ø­ Ø£ÙŠ Ø®Ø·Ø£ Ø¢Ø®Ø±\n        }\n      }\n\n      // Ø¥Ù„ØºØ§Ø¡ safety timeout Ù„Ø£Ù† Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù†Ø¬Ø­Øª\n      _cancelSafetyTimeout();\n\n      // Ø¥Ø°Ø§ Ù†Ø¬Ø­ Ø§Ù„Ø±Ø¨Ø· Ø£Ùˆ Ø§Ù„ØªØ­Ù‚Ù‚ØŒ Ù‚Ù… Ø¨Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n      await _finalizeSellerRegistration(isOtpNowVerified: true);\n    } on FirebaseAuthException catch (e) {\n      isOtpVerifying.value = false;\n      isLoading.value = false;\n      update();\n      debugPrint(\n        \"FirebaseAuthException during OTP verification: ${e.code} - ${e.message}\",\n      );\n      String errorMessage = \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø±Ù…Ø² OTP.\";\n      if (e.code == 'invalid-verification-code' ||\n          e.code == 'invalid-credential') {\n        errorMessage = \"Ø±Ù…Ø² OTP Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ­ÙŠØ­.\";\n      } else if (e.code == 'session-expired') {\n        errorMessage = \"Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø¬Ù„Ø³Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ Ø±Ù…Ø² Ø¬Ø¯ÙŠØ¯.\";\n      } else if (e.code == 'credential-already-in-use') {\n        // Ù‡Ø°Ù‡ Ø­Ø§Ù„Ø© Ø®Ø§ØµØ©: Ø§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ø­Ø³Ø§Ø¨ Ø¢Ø®Ø±. Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ù†ÙØ³ Ø§Ù„Ø­Ø³Ø§Ø¨ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ Ù†Ø¬Ø§Ø­Ù‹Ø§.\n        // Ù‡Ù†Ø§ØŒ Ù†ÙØªØ±Ø¶ Ø£Ù†Ù†Ø§ Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ù†Ù‚Ø·Ø©ØŒ ÙˆØ§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø· Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙÙ‡Ø°Ø§ Ø¬ÙŠØ¯.\n        // ÙˆÙ„ÙƒÙ† Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø®ØªÙ„ÙØŒ ÙÙ‡Ø°Ù‡ Ù…Ø´ÙƒÙ„Ø©.\n        // Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø³Ø§Ø·Ø©ØŒ Ø³Ù†Ø¹ØªØ¨Ø±Ù‡Ø§ Ø®Ø·Ø£ Ø¹Ø§Ù… Ø§Ù„Ø¢Ù†ØŒ ÙˆÙ„ÙƒÙ† ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ† Ù‡Ø°Ø§.\n        // Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù†Ù‡ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙŠÙ…ÙƒÙ† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©.\n        // Ø§Ù„Ø®ÙŠØ§Ø± Ø§Ù„Ø£Ø¨Ø³Ø· Ù‡Ùˆ Ù…Ø¹Ø§Ù„Ø¬ØªÙ‡ ÙƒØ®Ø·Ø£ Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ØªØ£ÙƒØ¯Ù‹Ø§ Ù…Ù† ÙƒÙŠÙÙŠØ© Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.\n        // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠÙ…ÙƒÙ† Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ _finalizeSellerRegistration Ù‡Ù†Ø§ Ø£ÙŠØ¶Ù‹Ø§.\n        // For now, treat as a specific error message or proceed if logic allows\n        debugPrint(\n          \"Credential already in use. Assuming for this user is okay or needs specific handling.\",\n        );\n        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø±Ù‚Ù… Ù…Ø±ØªØ¨Ø·Ù‹Ø§ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ØŒ Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ØµØ­ÙŠØ­\n        // await _finalizeSellerRegistration(isOtpNowVerified: true);\n        // Get.snackbar(\"Ù…Ø¹Ù„ÙˆÙ…Ø©\", \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù†Ù‡ Ø¨Ø§Ù„ÙØ¹Ù„ Ù„Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.\", snackPosition: SnackPosition.BOTTOM);\n        // return;\n        errorMessage =\n            \"Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ Ù‡Ø°Ø§ Ù…Ø±ØªØ¨Ø· Ø¨Ø§Ù„ÙØ¹Ù„. Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ø­Ø³Ø§Ø¨ÙƒØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø£Ùˆ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø¯Ø¹Ù….\";\n      } else if (e.code == 'no-current-user') {\n        errorMessage =\n            \"Ø§Ù†ØªÙ‡Øª Ø¬Ù„Ø³Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.\";\n        // ÙŠÙ…ÙƒÙ†Ùƒ Ù‡Ù†Ø§ ØªÙˆØ¬ÙŠÙ‡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù„ØµÙØ­Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„\n      }\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        errorMessage,\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    } catch (e) {\n      isOtpVerifying.value = false;\n      isLoading.value = false;\n      update();\n      debugPrint(\"Generic error verifying OTP: $e\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ù…Ø².\",\n        backgroundColor: Colors.red.shade500,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<void> _finalizeSellerRegistration({\n    bool isAutoVerified = false,\n    bool isOtpNowVerified = false,\n  }) async {\n    debugPrint(\"ğŸ”§ _finalizeSellerRegistration called\");\n    debugPrint(\n      \"ğŸ”§ isAutoVerified: $isAutoVerified, isOtpNowVerified: $isOtpNowVerified\",\n    );\n\n    // Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙˆÙ„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¢Ù† (Ù…Ù† verifyOtpAndFinalize)ØŒ ÙÙ„Ø§ ØªØªØ§Ø¨Ø¹\n    if (!isAutoVerified && !isOtpNowVerified) {\n      debugPrint(\"âŒ Neither auto verified nor OTP verified - stopping\");\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"Ù„Ù… ÙŠØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ.\",\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      return;\n    }\n\n    debugPrint(\n      \"âœ… Phone verification confirmed, proceeding with registration...\",\n    );\n\n    // Set loading states for this final part\n    isOtpVerifying.value = true;\n    isLoading.value = true;\n    update();\n\n    try {\n      final User? currentUser = _auth.currentUser;\n      if (currentUser == null) {\n        Get.snackbar(\n          \"Ø®Ø·Ø£\",\n          \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ø­Ø§Ù„ÙŠ. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n          backgroundColor: Colors.red.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n        );\n        isLoading.value = false;\n        isOtpVerifying.value = false;\n        // Navigate to login or welcome screen\n        return;\n      }\n\n      String? sellerProfileImageUrl;\n      String? shopFrontImageUrl;\n\n      // iOS-specific: Wait for Firebase to be fully ready\n      if (Platform.isIOS) {\n        debugPrint(\n          \"ğŸ”§ iOS detected - waiting for Firebase Storage to be ready...\",\n        );\n        await Future.delayed(Duration(milliseconds: 3000));\n\n        // Verify Firebase Storage is accessible\n        try {\n          _storage.ref().child('test_connection');\n          debugPrint(\"âœ… Firebase Storage connection test passed\");\n        } catch (e) {\n          debugPrint(\"âš ï¸ Firebase Storage connection test failed: $e\");\n        }\n      }\n\n      if (_tempSellerProfileImageFile != null) {\n        debugPrint(\"ğŸ–¼ï¸ Uploading seller profile image...\");\n        if (Platform.isIOS) {\n          sellerProfileImageUrl = await _iosStorageHandler.uploadFile(\n            _tempSellerProfileImageFile!,\n            'seller_profile_images/${currentUser.uid}',\n          );\n        } else {\n          sellerProfileImageUrl = await _uploadFile(\n            _tempSellerProfileImageFile!,\n            'seller_profile_images/${currentUser.uid}',\n          );\n        }\n      }\n      if (_tempShopFrontImageFile != null) {\n        debugPrint(\"ğŸª Uploading shop front image...\");\n        if (Platform.isIOS) {\n          shopFrontImageUrl = await _iosStorageHandler.uploadFile(\n            _tempShopFrontImageFile!,\n            'shop_front_images/${currentUser.uid}',\n          );\n        } else {\n          shopFrontImageUrl = await _uploadFile(\n            _tempShopFrontImageFile!,\n            'shop_front_images/${currentUser.uid}',\n          );\n        }\n      }\n\n      if (_tempSellerProfileImageFile != null &&\n          sellerProfileImageUrl == null) {\n        throw Exception(\"Failed to upload seller profile image.\");\n      }\n      if (_tempShopFrontImageFile != null && shopFrontImageUrl == null) {\n        throw Exception(\"Failed to upload shop front image.\");\n      }\n\n      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM Token Ø¨Ø´ÙƒÙ„ Ø§Ø­ØªØ±Ø§ÙÙŠ\n      final String? fcmToken = await _getFCMTokenSafely();\n\n      // Ø§Ø³ØªØ®Ø¯Ø§Ù… SellerModel Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª\n      final SellerModel sellerToSave = SellerModel(\n        uid: currentUser.uid,\n        sellerName:\n            _tempSellerDataForSubmission?['sellerName'] as String? ?? '',\n        sellerProfileImageUrl: sellerProfileImageUrl,\n        shopName: _tempSellerDataForSubmission?['shopName'] as String? ?? '',\n        shopFrontImageUrl: shopFrontImageUrl,\n        shopPhoneNumber:\n            _tempSellerDataForSubmission?['shopPhoneNumber'] as String? ?? '',\n        shopDescription:\n            _tempSellerDataForSubmission?['shopDescription'] as String?,\n        location:\n            _tempSellerDataForSubmission?['location'] as GeoPoint? ??\n            const GeoPoint(\n              0,\n              0,\n            ), // ØªÙ… Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† location Ù‡Ùˆ GeoPoint ÙÙŠ _tempSellerDataForSubmission\n        shopAddressText:\n            _tempSellerDataForSubmission?['shopAddressText'] as String?,\n        shopCategory:\n            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'Ø£Ø®Ø±Ù‰',\n        workingHours: Map<String, dynamic>.from(\n          _tempSellerDataForSubmission?['workingHours'] ?? {},\n        ),\n        // Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªØ§Ù„ÙŠØ© Ø§Ø®ØªÙŠØ§Ø±ÙŠØ© ÙÙŠ SellerModel ÙˆØ³ÙŠØªÙ… ØªØ¹ÙŠÙŠÙ†Ù‡Ø§ Ø¥Ù„Ù‰ null Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ _tempSellerDataForSubmission\n        commercialRegistrationNumber:\n            _tempSellerDataForSubmission?['commercialRegistrationNumber']\n                as String?,\n        websiteUrl: _tempSellerDataForSubmission?['websiteUrl'] as String?,\n        socialMediaLinks:\n            _tempSellerDataForSubmission?['socialMediaLinks']\n                as Map<String, String>?,\n\n        isProfileComplete: true, // ØªÙ… Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n        isApprovedByAdmin: false, // ÙŠØ­ØªØ§Ø¬ Ù…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù…Ø´Ø±Ù Ø¨Ø´ÙƒÙ„ Ø§ÙØªØ±Ø§Ø¶ÙŠ\n        isActiveBySeller: true, // Ù†Ø´Ø· Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§\n        isPhoneNumberVerified: true, // ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n        averageRating: 0.0,\n        numberOfRatings: 0,\n        sellerType: _sellerTypeFromAuth, // Ù…Ù† SellerAuthController\n        registrationCompleted: true, // Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø±Ø­Ù„Ø©\n        createdAt:\n            Timestamp.now(), // Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù€ FieldValue.serverTimestamp() Ø£Ø¯Ù†Ø§Ù‡\n        updatedAt:\n            null, // SellerModel.toMap() Ø³ÙŠØ¹ÙŠÙ† FieldValue.serverTimestamp() Ù„Ù‡Ø°Ø§\n      );\n\n      Map<String, dynamic> sellerDataToSave = sellerToSave.toMap();\n\n      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø·ÙˆØ§Ø¨Ø¹ Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„Ø®Ø§Ø¯Ù… ÙˆØ¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ ØºÙŠØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ SellerModel\n      sellerDataToSave['createdAt'] = FieldValue.serverTimestamp();\n      sellerDataToSave['updatedAt'] =\n          FieldValue.serverTimestamp(); // Ù„Ù„ØªØ£ÙƒÙŠØ¯ Ø£Ùˆ Ø¥Ø°Ø§ ÙƒØ§Ù† SellerModel.toMap Ù„Ø§ ÙŠÙØ¹Ù„ Ø°Ù„Ùƒ\n\n      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„ØªÙŠ Ù„ÙŠØ³Øª Ø¬Ø²Ø¡Ù‹Ø§ Ù…Ù† SellerModel ÙˆÙ„ÙƒÙ†Ù‡Ø§ Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Firestore\n      sellerDataToSave['email'] = currentUser.email;\n\n      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ø­ÙØ¸ FCM Token\n      if (fcmToken != null && fcmToken.isNotEmpty) {\n        sellerDataToSave['fcmToken'] = fcmToken;\n        sellerDataToSave['fcmTokenUpdatedAt'] = FieldValue.serverTimestamp();\n        debugPrint(\n          \"âœ… FCM Token will be saved: ${fcmToken.substring(0, 30)}...\",\n        );\n      } else {\n        debugPrint(\n          \"âš ï¸ No FCM Token available - saving without notification capability\",\n        );\n        // Ù„Ø§ Ù†Ø­ÙØ¸ fcmToken Ø¥Ø°Ø§ ÙƒØ§Ù† null Ù„ØªØ¬Ù†Ø¨ overwrite Ø£ÙŠ token Ù…ÙˆØ¬ÙˆØ¯\n        sellerDataToSave['fcmTokenStatus'] = 'failed_to_retrieve';\n        sellerDataToSave['fcmTokenFailedAt'] = FieldValue.serverTimestamp();\n\n        // Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n        debugPrint(\"ğŸ“… Scheduling FCM token retry for later...\");\n      }\n\n      debugPrint(\"ğŸ’¾ Saving seller data to Firestore...\");\n      debugPrint(\"ğŸ’¾ Document ID: ${currentUser.uid}\");\n      debugPrint(\"ğŸ’¾ Collection: ${FirebaseX.collectionSeller}\");\n\n      await _firestore\n          .collection(FirebaseX.collectionSeller)\n          .doc(currentUser.uid)\n          .set(sellerDataToSave, SetOptions(merge: true));\n\n      debugPrint(\"âœ… Seller data saved successfully to Firestore!\");\n\n      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      update();\n\n      debugPrint(\"ğŸ‰ Registration completed successfully!\");\n\n      // Ø¥Ø°Ø§ Ù„Ù… Ù†Ø­ØµÙ„ Ø¹Ù„Ù‰ FCM tokenØŒ Ø¬Ø¯ÙˆÙ„Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\n      if (fcmToken == null || fcmToken.isEmpty) {\n        retryFCMTokenLater();\n      }\n\n      Get.snackbar(\n        \"Ù†Ø¬Ø§Ø­\",\n        \"ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ Ø¨Ù†Ø¬Ø§Ø­!\",\n        backgroundColor: Colors.green.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n\n      // Ø¥Ø¶Ø§ÙØ© ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ø¹Ù„Ù‰ iOS Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†Ù‚Ù„\n      if (Platform.isIOS) {\n        await Future.delayed(const Duration(milliseconds: 500));\n      }\n\n      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªÙ†Ù‚Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù€ main thread\n      WidgetsBinding.instance.addPostFrameCallback((_) {\n        Get.offAll(\n          () => SellerMainScreen(),\n        ); // Navigate to seller dashboard or main screen\n      });\n    } catch (e) {\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      update();\n      debugPrint(\"Error finalizing seller registration: $e\");\n      String errorMessage = \"ÙØ´Ù„ Ø¥ÙƒÙ…Ø§Ù„ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ³Ø¬ÙŠÙ„.\";\n      if (e is FirebaseException &&\n          e.code == 'invalid-credential' &&\n          isAutoVerified) {\n        errorMessage =\n            \"ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ù† Ø§Ù„Ù‡Ø§ØªÙ. Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ø±Ù…Ø² ÙŠØ¯ÙˆÙŠÙ‹Ø§.\";\n        // Optionally, you could re-route to OTP screen if auto-verification was the only path here\n        // Get.to(() => OtpVerificationScreen()); // Might need to handle this case more gracefully\n      } else if (e is FirebaseException &&\n          e.code == 'invalid-verification-code') {\n        errorMessage = \"Ø±Ù…Ø² OTP Ø§Ù„Ø°ÙŠ Ø£Ø¯Ø®Ù„ØªÙ‡ ØºÙŠØ± ØµØ­ÙŠØ­.\";\n      } else if (e is FirebaseException && e.code == 'session-expired') {\n        errorMessage = \"Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø¬Ù„Ø³Ø© Ø§Ù„ØªØ­Ù‚Ù‚. ÙŠØ±Ø¬Ù‰ Ø·Ù„Ø¨ Ø±Ù…Ø² Ø¬Ø¯ÙŠØ¯.\";\n      }\n\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"$errorMessage ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<String?> _uploadFile(File file, String path) async {\n    try {\n      debugPrint(\"ğŸ”§ Starting file upload to: $path\");\n      debugPrint(\"ğŸ”§ File exists: ${await file.exists()}\");\n      debugPrint(\"ğŸ”§ File size: ${await file.length()} bytes\");\n\n      // Verify Firebase Storage is properly initialized\n      if (Firebase.apps.isEmpty) {\n        throw Exception(\"Firebase not initialized\");\n      }\n\n      final ref = _storage.ref().child(path);\n      debugPrint(\"ğŸ”§ Storage reference created: ${ref.fullPath}\");\n\n      // iOS-specific: Add metadata to help with upload\n      final metadata = SettableMetadata(\n        contentType: 'image/jpeg',\n        customMetadata: {\n          'uploaded_by': 'seller_registration',\n          'platform': Platform.isIOS ? 'ios' : 'android',\n        },\n      );\n\n      final uploadTask = ref.putFile(file, metadata);\n\n      // Monitor upload progress\n      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        final progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n        debugPrint(\"ğŸ”§ Upload progress: ${progress.toStringAsFixed(1)}%\");\n      });\n\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"âœ… File uploaded successfully: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"âŒ Error uploading file ($path): $e\");\n\n      // iOS-specific error handling\n      if (Platform.isIOS && e.toString().contains('object-not-found')) {\n        debugPrint(\n          \"ğŸ”§ iOS Storage issue detected - retrying with different approach\",\n        );\n        return await _uploadFileWithRetry(file, path);\n      }\n\n      return null;\n    }\n  }\n\n  Future<String?> _uploadFileWithRetry(File file, String path) async {\n    try {\n      // Wait a bit longer on iOS\n      await Future.delayed(Duration(milliseconds: 1500));\n\n      // Try with a different path structure for iOS\n      final timestamp = DateTime.now().millisecondsSinceEpoch;\n      final newPath = '${path.replaceAll('/', '_')}_$timestamp';\n\n      debugPrint(\"ğŸ”§ Retrying upload with path: $newPath\");\n\n      final ref = _storage.ref().child(newPath);\n      final uploadTask = ref.putFile(file);\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"âœ… Retry upload successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"âŒ Retry upload also failed: $e\");\n      return null;\n    }\n  }\n\n  Future<void> pickImage(\n    ImageSource source, {\n    required bool isProfileImage,\n  }) async {\n    try {\n      final XFile? pickedFile = await _picker.pickImage(\n        source: source,\n        imageQuality: 70,\n        maxWidth: 1024,\n      );\n      if (pickedFile != null) {\n        if (isProfileImage) {\n          sellerProfileImageFile.value = File(pickedFile.path);\n        } else {\n          shopFrontImageFile.value = File(pickedFile.path);\n        }\n        update(); // For GetBuilder if used\n      }\n    } catch (e) {\n      Get.snackbar(\"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©\", \"ÙØ´Ù„ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ØµÙˆØ±Ø©: $e\");\n    }\n  }\n\n  // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©\n  void toggleCategorySelection(String category) {\n    if (selectedShopCategories.contains(category)) {\n      selectedShopCategories.remove(category);\n    } else {\n      if (selectedShopCategories.length < maxCategoriesAllowed) {\n        selectedShopCategories.add(category);\n      } else {\n        Get.snackbar(\n          \"ØªØ­Ø°ÙŠØ±\",\n          \"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø®ØªÙŠØ§Ø± Ø­Ø¯ Ø£Ù‚ØµÙ‰ $maxCategoriesAllowed ÙØ¦Ø§Øª ÙÙ‚Ø·\",\n          backgroundColor: Colors.orange.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n        );\n      }\n    }\n  }\n\n  // Ø¯Ø§Ù„Ø© Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø©\n  bool isCategorySelected(String category) {\n    return selectedShopCategories.contains(category);\n  }\n\n  // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¹Ø¯Ø¯ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n  int get selectedCategoriesCount => selectedShopCategories.length;\n\n  // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Øµ Ø¹Ø±Ø¶ Ø§Ù„ÙØ¦Ø§Øª Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n  String get selectedCategoriesDisplay {\n    if (selectedShopCategories.isEmpty) {\n      return 'Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠ ÙØ¦Ø©';\n    } else if (selectedShopCategories.length == 1) {\n      return selectedShopCategories.first;\n    } else {\n      return '${selectedShopCategories.length} ÙØ¦Ø§Øª Ù…Ø®ØªØ§Ø±Ø©';\n    }\n  }\n\n  void toggleDayOpen(String dayKey) {\n    if (workingHours[dayKey] != null) {\n      bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n      workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n\n      if (!workingHours[dayKey]!['isOpen']) {\n        // If day is being closed\n        workingHours[dayKey]!['opensAt'] = null;\n        workingHours[dayKey]!['closesAt'] = null;\n        if (expandedDayPanel.value == dayKey) {\n          // Close expansion panel if it was this day\n          expandedDayPanel.value = null;\n        }\n      } else {\n        // If day is being opened\n        workingHours[dayKey]!['opensAt'] =\n            _lastAppliedOpensAt.value ?? \"09:00 AM\";\n        workingHours[dayKey]!['closesAt'] =\n            _lastAppliedClosesAt.value ?? \"05:00 PM\";\n        // Optionally, open this panel when day is toggled on if not already open by user interaction\n        // expandedDayPanel.value = dayKey;\n      }\n      workingHours.refresh();\n    }\n  }\n\n  bool canApplyToOthers(String dayKey) {\n    final dayData = workingHours[dayKey];\n    if (dayData == null || !(dayData['isOpen'] == true)) return false;\n    return dayData['opensAt'] != null && dayData['closesAt'] != null;\n  }\n\n  void offerToApplyTimesToOtherDays(\n    BuildContext context,\n    String sourceDayKey,\n    String opensAtToApply,\n    String closesAtToApply,\n  ) {\n    Get.dialog(\n      AlertDialog(\n        title: const Text(\"ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§ØªØŸ\"),\n        content: Text(\n          \"Ù‡Ù„ ØªØ±ØºØ¨ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‚Øª Ø§Ù„ÙØªØ­ ($opensAtToApply) ÙˆÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ($closesAtToApply) Ø¹Ù„Ù‰ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ø£Ø®Ø±Ù‰ Ø§Ù„ØªÙŠ ØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡Ø§ ÙƒÙ…ÙØªÙˆØ­Ø© ÙˆÙ„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£ÙˆÙ‚Ø§Øª Ù„Ù‡Ø§ Ø¨Ø¹Ø¯ Ø£Ùˆ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…ÙØªÙˆØ­Ø©ØŸ\",\n        ),\n        actionsAlignment: MainAxisAlignment.spaceEvenly,\n        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),\n        actions: [\n          TextButton(child: const Text(\"Ø¥Ù„ØºØ§Ø¡\"), onPressed: () => Get.back()),\n          ElevatedButton(\n            child: const Text(\"Ù„Ù„Ø£ÙŠØ§Ù… Ø§Ù„ÙØ§Ø±ØºØ© ÙÙ‚Ø·\"),\n            onPressed: () {\n              Get.back();\n              applyTimesToOtherOpenDays(\n                sourceDayKey,\n                opensAtToApply,\n                closesAtToApply,\n                applyToAllOpen: false,\n              );\n            },\n          ),\n          ElevatedButton(\n            child: const Text(\"Ù†Ø¹Ù…ØŒ Ù„Ù„ÙƒÙ„ (Ø§Ù„Ù…ÙØªÙˆØ­)\"),\n            onPressed: () {\n              Get.back();\n              applyTimesToOtherOpenDays(\n                sourceDayKey,\n                opensAtToApply,\n                closesAtToApply,\n                applyToAllOpen: true,\n              );\n            },\n          ),\n        ],\n      ),\n      barrierDismissible: true,\n    );\n  }\n\n  void applyTimesToOtherOpenDays(\n    String sourceDayKey,\n    String opensAtToApply,\n    String closesAtToApply, {\n    required bool applyToAllOpen,\n  }) {\n    bool timesApplied = false;\n    workingHours.forEach((key, value) {\n      if (key != sourceDayKey && (value['isOpen'] == true)) {\n        bool apply = false;\n        if (applyToAllOpen) {\n          apply = true;\n        } else {\n          // Apply to empty open days only\n          if (value['opensAt'] == null || value['closesAt'] == null) {\n            apply = true;\n          }\n        }\n        if (apply) {\n          value['opensAt'] = opensAtToApply;\n          value['closesAt'] = closesAtToApply;\n          timesApplied = true;\n        }\n      }\n    });\n    if (timesApplied) {\n      _lastAppliedOpensAt.value =\n          opensAtToApply; // Update template if changes were made\n      _lastAppliedClosesAt.value = closesAtToApply;\n      workingHours.refresh();\n      Get.snackbar(\n        \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«\",\n        \"ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­.\",\n        snackPosition: SnackPosition.BOTTOM,\n        backgroundColor: Colors.green.shade400,\n        colorText: Colors.white,\n      );\n    } else {\n      Get.snackbar(\n        \"Ù„Ù… ÙŠØªØºÙŠØ± Ø´ÙŠØ¡\",\n        \"Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø£ÙŠØ§Ù… Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø¹Ù„ÙŠÙ‡Ø§ Ø­Ø³Ø¨ Ø§Ø®ØªÙŠØ§Ø±Ùƒ.\",\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<void> selectTime(\n    BuildContext context,\n    String dayKey,\n    bool isOpeningTime,\n  ) async {\n    final Map<String, dynamic>? dayData = workingHours[dayKey];\n    final String? opensAtString = dayData?['opensAt'] as String?;\n    final String? closesAtString = dayData?['closesAt'] as String?;\n\n    String? timeToParse;\n    if (isOpeningTime) {\n      timeToParse = opensAtString;\n    } else {\n      timeToParse = closesAtString;\n    }\n\n    TimeOfDay? initialTime = _parseTime(timeToParse) ?? TimeOfDay.now();\n\n    final TimeOfDay? pickedTime = await showTimePicker(\n      context: context,\n      initialTime: initialTime,\n      builder: (context, child) {\n        return Theme(\n          data: ThemeData.light().copyWith(\n            colorScheme: ColorScheme.light(\n              primary: Get.theme.primaryColor, // header background color\n              onPrimary: Colors.white, // header text color\n              onSurface: Colors.black, // body text color\n            ),\n            timePickerTheme: TimePickerThemeData(\n              dialHandColor: Get.theme.primaryColor,\n            ),\n            textButtonTheme: TextButtonThemeData(\n              style: TextButton.styleFrom(\n                foregroundColor: Get.theme.primaryColor, // button text color\n              ),\n            ),\n          ),\n          child: child!,\n        );\n      },\n    );\n\n    if (pickedTime != null) {\n      final formattedTime = formatTimeOfDay(pickedTime);\n      final currentOpensAt = _parseTime(workingHours[dayKey]?['opensAt']);\n      final currentClosesAt = _parseTime(workingHours[dayKey]?['closesAt']);\n\n      if (isOpeningTime) {\n        if (currentClosesAt != null &&\n            _isTimeBeforeOrEqual(\n              pickedTime,\n              currentClosesAt,\n              isOpening: true,\n              isClosing: false,\n            )) {\n          workingHours[dayKey]!['opensAt'] = formattedTime;\n          _lastAppliedOpensAt.value = formattedTime;\n        } else if (currentClosesAt != null) {\n          Get.snackbar(\n            \"ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­\",\n            \"ÙˆÙ‚Øª Ø§Ù„ÙØªØ­ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù‚Ø¨Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚.\",\n            snackPosition: SnackPosition.BOTTOM,\n            backgroundColor: Colors.orange.shade300,\n          );\n          return;\n        } else {\n          // No closing time set yet, allow setting opening time\n          workingHours[dayKey]!['opensAt'] = formattedTime;\n          _lastAppliedOpensAt.value = formattedTime;\n        }\n      } else {\n        // isClosingTime\n        if (currentOpensAt != null &&\n            _isTimeBeforeOrEqual(\n              currentOpensAt,\n              pickedTime,\n              isOpening: false,\n              isClosing: true,\n            )) {\n          workingHours[dayKey]!['closesAt'] = formattedTime;\n          _lastAppliedClosesAt.value = formattedTime;\n        } else if (currentOpensAt != null) {\n          Get.snackbar(\n            \"ÙˆÙ‚Øª ØºÙŠØ± ØµØ§Ù„Ø­\",\n            \"ÙˆÙ‚Øª Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨Ø¹Ø¯ ÙˆÙ‚Øª Ø§Ù„ÙØªØ­.\",\n            snackPosition: SnackPosition.BOTTOM,\n            backgroundColor: Colors.orange.shade300,\n          );\n          return;\n        } else {\n          // No opening time set yet, allow setting closing time\n          workingHours[dayKey]!['closesAt'] = formattedTime;\n          _lastAppliedClosesAt.value = formattedTime;\n        }\n      }\n      workingHours.refresh();\n    }\n  }\n\n  bool _isTimeBeforeOrEqual(\n    TimeOfDay time1,\n    TimeOfDay time2, {\n    required bool isOpening,\n    required bool isClosing,\n  }) {\n    final time1Minutes = time1.hour * 60 + time1.minute;\n    final time2Minutes = time2.hour * 60 + time2.minute;\n    if (isOpening) {\n      // time1 is opensAt, time2 is closesAt\n      return time1Minutes < time2Minutes;\n    } else {\n      // time1 is opensAt, time2 is closesAt\n      return time1Minutes < time2Minutes;\n    }\n  }\n\n  String formatTimeOfDay(TimeOfDay tod) {\n    final now = DateTime.now();\n    final dt = DateTime(now.year, now.month, now.day, tod.hour, tod.minute);\n    final format = DateFormat.jm(); // e.g., 5:08 PM\n    return format.format(dt);\n  }\n\n  TimeOfDay? _parseTime(String? timeString) {\n    if (timeString == null) return null;\n    try {\n      final format =\n          DateFormat.jm(); // Needs to match the format used in formatTimeOfDay\n      final dt = format.parse(timeString);\n      return TimeOfDay.fromDateTime(dt);\n    } catch (e) {\n      debugPrint(\"Error parsing time: $e\");\n      return null;\n    }\n  }\n\n  // --- Location Methods ---\n  final TextEditingController streetAddressController = TextEditingController();\n\n  void onMapCreated(GoogleMapController controller) {\n    mapController = controller;\n  }\n\n  Future<void> openLocationPickerScreen(BuildContext context) async {\n    final LatLng? result = await Get.to<LatLng>(\n      () => LocationPickerScreen(initialLocation: shopLocation.value),\n    );\n    if (result != null) {\n      shopLocation.value = result;\n      await _getAddressFromLatLng(result);\n      // Optionally move camera on the small map if it's visible and controller is available\n      mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n    }\n  }\n\n  Future<void> _getAddressFromLatLng(LatLng latLng) async {\n    try {\n      List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n        latLng.latitude,\n        latLng.longitude,\n      );\n      if (placemarks.isNotEmpty) {\n        final p = placemarks[0];\n        // Construct a more detailed or relevant address string\n        shopAddressText.value =\n            \"${p.name}, ${p.locality}, ${p.subAdministrativeArea}, ${p.administrativeArea}\"\n                .replaceAll(\"null,\", \"\")\n                .trim()\n                .replaceAll(RegExp(r'^, |,$'), '');\n        if (streetAddressController.text.isEmpty &&\n            p.street != null &&\n            p.street!.isNotEmpty) {\n          streetAddressController.text = p.street!;\n        }\n      } else {\n        shopAddressText.value = \"ØªØ¹Ø°Ø± Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n      }\n    } catch (e) {\n      debugPrint(\"Error getting address: $e\");\n      shopAddressText.value = \"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†\";\n    }\n  }\n\n  Future<void> tryMoveToCurrentLocation() async {\n    isLoading.value = true; // Indicate loading for location fetch\n    update();\n    try {\n      Position currentPosition = await _determinePosition();\n      LatLng newLatLng = LatLng(\n        currentPosition.latitude,\n        currentPosition.longitude,\n      );\n      shopLocation.value = newLatLng;\n      await _getAddressFromLatLng(newLatLng);\n      mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n    } catch (e) {\n      Get.snackbar(\n        \"Ø®Ø·Ø£\",\n        \"ÙØ´Ù„ ÙÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${e.toString()}\",\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    } finally {\n      isLoading.value = false;\n      update();\n    }\n  }\n\n  Future<Position> _determinePosition() async {\n    bool serviceEnabled;\n    LocationPermission permission;\n\n    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n    if (!serviceEnabled) {\n      // Attempt to open location settings\n      await Geolocator.openLocationSettings();\n      return Future.error('Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø¹Ø·Ù„Ø©. ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„Ù‡Ø§.');\n    }\n\n    permission = await Geolocator.checkPermission();\n    if (permission == LocationPermission.denied) {\n      permission = await Geolocator.requestPermission();\n      if (permission == LocationPermission.denied) {\n        return Future.error('ØªÙ… Ø±ÙØ¶ Ø£Ø°ÙˆÙ†Ø§Øª ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹.');\n      }\n    }\n\n    if (permission == LocationPermission.deniedForever) {\n      return Future.error(\n        'Ø£Ø°ÙˆÙ†Ø§Øª ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ø±ÙÙˆØ¶Ø© Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ù…ØŒ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ù†Ø§ Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª. ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„Ù‡Ø§ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.',\n      );\n    }\n    currentPositionAccuracy.value =\n        (await Geolocator.getCurrentPosition()).accuracy;\n\n    return await Geolocator.getCurrentPosition(\n      desiredAccuracy: LocationAccuracy.high,\n    );\n  }\n\n  void submitRegistration(BuildContext context) {\n    debugPrint(\"ğŸ”¥ submitRegistration called\");\n\n    // This method will now call initiatePhoneVerificationAndCollectData\n    // as OTP verification is mandatory.\n\n    // Ø¥Ø¶Ø§ÙØ© Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù…Ù† Ø§Ù„ØªØ¬Ù…ÙŠØ¯\n    _startSafetyTimeout();\n\n    debugPrint(\"About to call initiatePhoneVerificationAndCollectData...\");\n    initiatePhoneVerificationAndCollectData();\n    debugPrint(\"initiatePhoneVerificationAndCollectData call completed\");\n  }\n\n  // Ø¢Ù„ÙŠØ© Ø­Ù…Ø§ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© Ù„ØªØ¬Ù†Ø¨ Ø§Ù„ØªØ¬Ù…ÙŠØ¯ Ø¹Ù„Ù‰ iOS\n  Timer? _safetyTimer;\n\n  void _startSafetyTimeout() {\n    _safetyTimer = Timer(Duration(seconds: Platform.isIOS ? 60 : 90), () {\n      if ((isLoading.value || isOtpSending.value) && !isOtpVerifying.value) {\n        debugPrint(\"Safety timeout triggered - resetting loading states\");\n        isLoading.value = false;\n        isOtpSending.value = false;\n        isOtpVerifying.value = false;\n        update();\n        Get.snackbar(\n          \"Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ù‡Ù„Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ©\",\n          \"ØªÙ… Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ø­Ø¯Ø¯ Ù„Ù„Ø¹Ù…Ù„ÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.\",\n          backgroundColor: Colors.orange.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n        );\n      }\n    });\n  }\n\n  void _cancelSafetyTimeout() {\n    _safetyTimer?.cancel();\n    _safetyTimer = null;\n  }\n\n  /// Ø¯Ø§Ù„Ø© Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM Token Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ù„Ø£Ø®Ø·Ø§Ø¡\n  Future<String?> _getFCMTokenSafely() async {\n    debugPrint(\"ğŸ”‘ Starting FCM token retrieval process...\");\n\n    try {\n      // 1. Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ø£ÙˆÙ„Ø§Ù‹\n      debugPrint(\"ğŸ“± Requesting Firebase Messaging permissions...\");\n      NotificationSettings settings = await _firebaseMessaging\n          .requestPermission(\n            alert: true,\n            announcement: false,\n            badge: true,\n            carPlay: false,\n            criticalAlert: false,\n            provisional: false,\n            sound: true,\n          );\n\n      debugPrint(\"ğŸ”” Permission status: ${settings.authorizationStatus}\");\n\n      if (settings.authorizationStatus == AuthorizationStatus.denied) {\n        debugPrint(\"âŒ Notification permissions denied\");\n        return null;\n      }\n\n      // 2. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªØ¸Ø§Ø± APNS\n      debugPrint(\n        \"ğŸš€ Attempting direct FCM token retrieval (bypass APNS dependency)...\",\n      );\n\n      String? fcmToken;\n      int directAttempts = 0;\n      const maxDirectAttempts = 3;\n\n      while (fcmToken == null && directAttempts < maxDirectAttempts) {\n        directAttempts++;\n        debugPrint(\"ğŸ”„ Direct FCM attempt $directAttempts/$maxDirectAttempts\");\n\n        try {\n          // Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¯ÙˆÙ† Ø§Ù†ØªØ¸Ø§Ø± APNS\n          fcmToken = await _firebaseMessaging.getToken().timeout(\n            Duration(seconds: 20 + (10 * directAttempts)),\n            onTimeout: () => null,\n          );\n\n          if (fcmToken != null && fcmToken.isNotEmpty) {\n            debugPrint(\"âœ… Direct FCM Token received successfully!\");\n            debugPrint(\"ğŸ”‘ Token preview: ${fcmToken.substring(0, 50)}...\");\n            await _cacheFCMToken(fcmToken);\n            return fcmToken;\n          }\n        } catch (e) {\n          debugPrint(\"âš ï¸ Direct FCM attempt $directAttempts failed: $e\");\n          // Ø¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…Ø´ÙƒÙ„Ø© APNSØŒ ØªØ§Ø¨Ø¹\n          if (!e.toString().toLowerCase().contains('apns')) {\n            await Future.delayed(Duration(seconds: directAttempts * 2));\n            continue;\n          }\n        }\n\n        // Ø¥Ø°Ø§ ÙˆØµÙ„Ù†Ø§ Ù‡Ù†Ø§ØŒ ÙØ§Ù„Ù…Ø´ÙƒÙ„Ø© Ù…ØªØ¹Ù„Ù‚Ø© Ø¨Ù€ APNS\n        break;\n      }\n\n      // 3. Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ Ø¬Ø±Ø¨ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ© Ù…Ø¹ APNS\n      if (fcmToken == null && Platform.isIOS) {\n        debugPrint(\"ğŸ Fallback to APNS-dependent approach...\");\n\n        // Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ù† native code\n        debugPrint(\"ğŸ“² Triggering native notification registration...\");\n\n        // Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„Ù†Ø¸Ø§Ù…\n        await Future.delayed(const Duration(seconds: 5));\n\n        // Ù…Ø­Ø§ÙˆÙ„Ø© APNS Ù…Ø­Ø¯ÙˆØ¯Ø©\n        String? apnsToken;\n        for (int attempt = 1; attempt <= 3; attempt++) {\n          debugPrint(\"ğŸ”„ APNS attempt $attempt/3\");\n\n          try {\n            await Future.delayed(Duration(seconds: attempt * 3));\n            apnsToken = await _firebaseMessaging.getAPNSToken();\n            if (apnsToken != null) {\n              debugPrint(\n                \"âœ… APNS Token received: ${apnsToken.substring(0, 20)}...\",\n              );\n              break;\n            }\n          } catch (e) {\n            debugPrint(\"âš ï¸ APNS attempt $attempt failed: $e\");\n          }\n        }\n\n        // 4. Ù…Ø­Ø§ÙˆÙ„Ø© FCM Ù…Ø±Ø© Ø£Ø®ÙŠØ±Ø©\n        if (apnsToken != null) {\n          debugPrint(\"ğŸ”‘ Final FCM token attempt with APNS...\");\n\n          try {\n            fcmToken = await _firebaseMessaging.getToken().timeout(\n              const Duration(seconds: 30),\n              onTimeout: () => null,\n            );\n\n            if (fcmToken != null && fcmToken.isNotEmpty) {\n              debugPrint(\"âœ… FCM Token received after APNS setup!\");\n              await _cacheFCMToken(fcmToken);\n              return fcmToken;\n            }\n          } catch (e) {\n            debugPrint(\"âš ï¸ Final FCM attempt failed: $e\");\n          }\n        }\n      }\n\n      // 5. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ù…Ù† cache\n      debugPrint(\"â™»ï¸ Trying cached token...\");\n      String? cachedToken = await _getCachedFCMToken();\n\n      if (cachedToken != null) {\n        debugPrint(\"âœ… Using cached FCM token\");\n        return cachedToken;\n      }\n\n      // 6. Ø¥Ø°Ø§ ÙØ´Ù„ ÙƒÙ„ Ø´ÙŠØ¡ØŒ Ø¥Ù†Ø´Ø§Ø¡ placeholder token Ù„Ù„ØªØ·ÙˆÙŠØ±\n      if (Platform.isIOS) {\n        debugPrint(\"ğŸ› ï¸ Creating development placeholder token...\");\n        String placeholderToken = await _createDevelopmentToken();\n        if (placeholderToken.isNotEmpty) {\n          debugPrint(\n            \"ğŸ”§ Using development token: ${placeholderToken.substring(0, 30)}...\",\n          );\n          await _cacheFCMToken(placeholderToken);\n          return placeholderToken;\n        }\n      }\n\n      debugPrint(\"âŒ All FCM token retrieval methods failed\");\n      return null;\n    } catch (e) {\n      debugPrint(\"ğŸš¨ Fatal error in FCM token retrieval: $e\");\n      debugPrint(\"ğŸ“Š Error details: ${e.toString()}\");\n\n      // Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®ÙŠØ±Ø© Ù…Ø¹ cached token\n      String? cachedToken = await _getCachedFCMToken();\n      if (cachedToken != null) {\n        debugPrint(\"â™»ï¸ Emergency fallback to cached token\");\n        return cachedToken;\n      }\n\n      return null;\n    }\n  }\n\n  /// Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ·ÙˆÙŠØ± Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙØ´Ù„ APNS\n  Future<String> _createDevelopmentToken() async {\n    try {\n      final User? currentUser = _auth.currentUser;\n      final String deviceId =\n          currentUser?.uid ?? DateTime.now().millisecondsSinceEpoch.toString();\n      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();\n\n      // Ø¥Ù†Ø´Ø§Ø¡ token Ù…Ø¤Ù‚Øª ÙØ±ÙŠØ¯ Ù„Ù„Ø¬Ù‡Ø§Ø²\n      String developmentToken = \"dev_token_ios_${deviceId}_$timestamp\";\n\n      debugPrint(\"ğŸ”§ Generated development token for testing\");\n      return developmentToken;\n    } catch (e) {\n      debugPrint(\"âš ï¸ Failed to create development token: $e\");\n      return \"\";\n    }\n  }\n\n  /// Ø­ÙØ¸ FCM token ÙÙŠ Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©\n  Future<void> _cacheFCMToken(String token) async {\n    try {\n      final box = GetStorage();\n      await box.write('cached_fcm_token', token);\n      await box.write(\n        'fcm_token_timestamp',\n        DateTime.now().millisecondsSinceEpoch,\n      );\n      debugPrint(\"ğŸ’¾ FCM token cached successfully\");\n    } catch (e) {\n      debugPrint(\"âš ï¸ Failed to cache FCM token: $e\");\n    }\n  }\n\n  /// Ø§Ø³ØªØ±Ø¯Ø§Ø¯ FCM token Ù…Ù† Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø­Ù„ÙŠØ©\n  Future<String?> _getCachedFCMToken() async {\n    try {\n      final box = GetStorage();\n      String? cachedToken = box.read('cached_fcm_token');\n      int? timestamp = box.read('fcm_token_timestamp');\n\n      if (cachedToken != null && timestamp != null) {\n        // ØªØ­Ù‚Ù‚ Ù…Ù† Ø¹Ù…Ø± Ø§Ù„Ù€ token (ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 7 Ø£ÙŠØ§Ù…)\n        DateTime tokenDate = DateTime.fromMillisecondsSinceEpoch(timestamp);\n        Duration age = DateTime.now().difference(tokenDate);\n\n        if (age.inDays < 7) {\n          debugPrint(\n            \"â™»ï¸ Found valid cached FCM token (age: ${age.inHours} hours)\",\n          );\n          return cachedToken;\n        } else {\n          debugPrint(\n            \"â° Cached FCM token is too old (${age.inDays} days), ignoring\",\n          );\n        }\n      }\n\n      return null;\n    } catch (e) {\n      debugPrint(\"âš ï¸ Failed to retrieve cached FCM token: $e\");\n      return null;\n    }\n  }\n\n  /// ØªØ­Ø¯ÙŠØ« FCM Token ÙÙŠ Firestore Ù„Ø§Ø­Ù‚Ø§Ù‹ (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù…Ù† Ù…ÙƒØ§Ù† Ø¢Ø®Ø±)\n  Future<void> updateFCMTokenInFirestore() async {\n    try {\n      final User? currentUser = _auth.currentUser;\n      if (currentUser == null) {\n        debugPrint(\"âš ï¸ No current user to update FCM token for\");\n        return;\n      }\n\n      debugPrint(\"ğŸ”„ Attempting to update FCM token in Firestore...\");\n      final String? fcmToken = await _getFCMTokenSafely();\n\n      if (fcmToken != null && fcmToken.isNotEmpty) {\n        await _firestore\n            .collection(FirebaseX.collectionSeller)\n            .doc(currentUser.uid)\n            .update({\n              'fcmToken': fcmToken,\n              'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n              'fcmTokenStatus': 'active',\n            });\n\n        debugPrint(\"âœ… FCM Token updated successfully in Firestore\");\n        Get.snackbar(\n          \"ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«\",\n          \"ØªÙ… ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø±Ù Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­\",\n          backgroundColor: Colors.green.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n          duration: const Duration(seconds: 2),\n        );\n      } else {\n        debugPrint(\"âŒ Failed to get FCM token for update\");\n      }\n    } catch (e) {\n      debugPrint(\"ğŸš¨ Error updating FCM token in Firestore: $e\");\n    }\n  }\n\n  /// Ø¯Ø§Ù„Ø© Ù…Ø­Ø³Ù‘Ù†Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ø¹ Ø¥Ø¹Ø¯Ø§Ø¯ Ø£ÙØ¶Ù„ Ù„Ù€ iOS\n  Future<String?> _getIOSOptimizedFCMToken() async {\n    debugPrint(\"ğŸ Starting iOS-optimized FCM token retrieval...\");\n\n    try {\n      // 1. Ø§Ù†ØªØ¸Ø§Ø± Ø¥Ø¶Ø§ÙÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø¸Ø§Ù…\n      await Future.delayed(const Duration(seconds: 5));\n\n      // 2. Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ù„Ù„Ù€ remote notifications ÙŠØ¯ÙˆÙŠØ§Ù‹ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…Ø³Ø¬Ù„Ø§Ù‹\n      debugPrint(\"ğŸ“± Ensuring iOS remote notification registration...\");\n\n      // 3. Ø·Ù„Ø¨ Ø§Ù„Ø£Ø°ÙˆÙ†Ø§Øª Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n      NotificationSettings settings = await _firebaseMessaging\n          .requestPermission(\n            alert: true,\n            announcement: false,\n            badge: true,\n            carPlay: false,\n            criticalAlert: false,\n            provisional: false,\n            sound: true,\n          );\n\n      if (settings.authorizationStatus != AuthorizationStatus.authorized) {\n        debugPrint(\n          \"âŒ iOS Notifications not authorized: ${settings.authorizationStatus}\",\n        );\n        return null;\n      }\n\n      // 4. Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø®ØªÙ„ÙØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ù…Ø¹ Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„\n      for (int attempt = 1; attempt <= 3; attempt++) {\n        debugPrint(\"ğŸ”‘ iOS FCM token attempt $attempt/3\");\n\n        try {\n          // Ø§Ù†ØªØ¸Ø§Ø± Ù…ØªØ²Ø§ÙŠØ¯ Ù…Ø¹ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©\n          await Future.delayed(Duration(seconds: 3 * attempt));\n\n          String? token = await _firebaseMessaging.getToken().timeout(\n            Duration(seconds: 60 + (10 * attempt)), // Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„ Ù…Ø¹ ÙƒÙ„ Ù…Ø­Ø§ÙˆÙ„Ø©\n          );\n\n          if (token != null && token.isNotEmpty) {\n            debugPrint(\"âœ… iOS FCM token received on attempt $attempt!\");\n            return token;\n          }\n        } catch (e) {\n          debugPrint(\"âš ï¸ iOS FCM attempt $attempt failed: $e\");\n          if (e.toString().toLowerCase().contains('apns')) {\n            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø®Ø·Ø£ APNSØŒ Ø§Ù†ØªØ¸Ø§Ø± Ø£Ø·ÙˆÙ„\n            await Future.delayed(Duration(seconds: 5 * attempt));\n          }\n        }\n      }\n\n      return null;\n    } catch (e) {\n      debugPrint(\"ğŸš¨ iOS FCM token retrieval failed: $e\");\n      return null;\n    }\n  }\n\n  /// Ù…Ø³Ø§Ø¹Ø¯ Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ FCM token Ø¨Ø¹Ø¯ Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n  void retryFCMTokenLater() {\n    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø¨Ø¹Ø¯ 30 Ø«Ø§Ù†ÙŠØ© Ù„Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰\n    Timer(const Duration(seconds: 30), () {\n      debugPrint(\"ğŸ”„ Retrying FCM token retrieval after 30 seconds...\");\n      updateFCMTokenInFirestore();\n    });\n\n    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø®Ø§ØµØ© Ø¨Ù€ iOS Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ø­Ø¯Ø©\n    if (Platform.isIOS) {\n      Timer(const Duration(minutes: 1), () async {\n        debugPrint(\"ğŸ iOS-specific FCM token retry after 1 minute...\");\n        final token = await _getIOSOptimizedFCMToken();\n        if (token != null) {\n          try {\n            final User? currentUser = _auth.currentUser;\n            if (currentUser != null) {\n              await _firestore\n                  .collection(FirebaseX.collectionSeller)\n                  .doc(currentUser.uid)\n                  .update({\n                    'fcmToken': token,\n                    'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n                    'fcmTokenStatus': 'active',\n                  });\n              debugPrint(\"âœ… iOS FCM Token updated successfully in retry!\");\n            }\n          } catch (e) {\n            debugPrint(\"âŒ Failed to update iOS FCM token in retry: $e\");\n          }\n        }\n      });\n    }\n\n    // Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ø¨Ø¹Ø¯ Ø¯Ù‚ÙŠÙ‚ØªÙŠÙ† Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ø£ÙˆÙ„Ù‰\n    Timer(const Duration(minutes: 2), () {\n      debugPrint(\"ğŸ”„ Second retry attempt for FCM token after 2 minutes...\");\n      updateFCMTokenInFirestore();\n    });\n\n    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®ÙŠØ±Ø© Ø¨Ø¹Ø¯ 5 Ø¯Ù‚Ø§Ø¦Ù‚\n    Timer(const Duration(minutes: 5), () {\n      debugPrint(\"ğŸ”„ Final retry attempt for FCM token after 5 minutes...\");\n      updateFCMTokenInFirestore();\n    });\n  }\n}\n\n/// iOS-specific Firebase Storage handler to fix image upload issues\nclass IOSFirebaseStorageHandler {\n  final FirebaseStorage _storage;\n\n  IOSFirebaseStorageHandler(this._storage);\n\n  Future<String?> uploadFile(File file, String path) async {\n    try {\n      debugPrint(\"ğŸ iOS Storage Handler: Starting upload to: $path\");\n\n      // Wait longer for Firebase to be fully ready on iOS\n      await Future.delayed(Duration(milliseconds: 5000));\n\n      // Verify Firebase is properly initialized\n      if (Firebase.apps.isEmpty) {\n        throw Exception(\"Firebase not initialized\");\n      }\n\n      // Test Firebase Storage connection first\n      try {\n        _storage.ref().child(\n          \"connection_test_${DateTime.now().millisecondsSinceEpoch}\",\n        );\n        debugPrint(\"ğŸ Testing Firebase Storage connection...\");\n        // Just create a reference, don't upload\n        debugPrint(\"âœ… Firebase Storage connection test passed\");\n      } catch (e) {\n        debugPrint(\"âŒ Firebase Storage connection test failed: $e\");\n        throw Exception(\"Firebase Storage not accessible: $e\");\n      }\n\n      // Verify file exists and is readable\n      if (!await file.exists()) {\n        throw Exception(\"File does not exist at path: ${file.path}\");\n      }\n\n      final fileSize = await file.length();\n      debugPrint(\"ğŸ iOS Storage Handler: File size: $fileSize bytes\");\n\n      if (fileSize == 0) {\n        throw Exception(\"File is empty\");\n      }\n\n      // Use simple path first - try without modifications\n      debugPrint(\"ğŸ iOS Storage Handler: Trying direct upload to: $path\");\n\n      final ref = _storage.ref().child(path);\n\n      // Set proper metadata for iOS\n      final metadata = SettableMetadata(\n        contentType: _getContentType(file.path),\n        customMetadata: {\n          'uploaded_by': 'ios_seller_registration',\n          'original_path': path,\n          'upload_timestamp': DateTime.now().millisecondsSinceEpoch.toString(),\n        },\n      );\n\n      debugPrint(\"ğŸ iOS Storage Handler: Creating upload task...\");\n      final uploadTask = ref.putFile(file, metadata);\n\n      // Monitor progress\n      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        if (snapshot.totalBytes > 0) {\n          final progress =\n              snapshot.bytesTransferred / snapshot.totalBytes * 100;\n          debugPrint(\"ğŸ iOS Upload progress: ${progress.toStringAsFixed(1)}%\");\n        }\n      });\n\n      debugPrint(\"ğŸ iOS Storage Handler: Waiting for upload completion...\");\n      final snapshot = await uploadTask.whenComplete(() {});\n\n      debugPrint(\"ğŸ iOS Storage Handler: Getting download URL...\");\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"âœ… iOS Upload successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"âŒ iOS Storage Handler error: $e\");\n\n      // Try alternative upload method for iOS\n      return await _alternativeUploadMethod(file, path);\n    }\n  }\n\n  Future<String?> _alternativeUploadMethod(File file, String path) async {\n    // Try multiple alternative approaches for iOS\n\n    // Method 1: putData instead of putFile\n    try {\n      debugPrint(\"ğŸ”„ iOS Alternative Method 1: Using putData...\");\n      await Future.delayed(Duration(milliseconds: 3000));\n\n      final bytes = await file.readAsBytes();\n      debugPrint(\"ğŸ”„ iOS Read ${bytes.length} bytes from file\");\n\n      final ref = _storage.ref().child(path);\n      final uploadTask = ref.putData(\n        bytes,\n        SettableMetadata(\n          contentType: _getContentType(file.path),\n          customMetadata: {\n            'uploaded_by': 'ios_alternative_putdata',\n            'original_path': path,\n          },\n        ),\n      );\n\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"âœ… iOS Alternative Method 1 successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"âŒ iOS Alternative Method 1 failed: $e\");\n    }\n\n    // Method 2: Different path structure\n    try {\n      debugPrint(\"ğŸ”„ iOS Alternative Method 2: Different path structure...\");\n      await Future.delayed(Duration(milliseconds: 3000));\n\n      final timestamp = DateTime.now().millisecondsSinceEpoch;\n      final altPath = \"mobile_uploads/${path.replaceAll('/', '_')}_$timestamp\";\n\n      debugPrint(\"ğŸ”„ iOS Alternative path: $altPath\");\n\n      final bytes = await file.readAsBytes();\n      final ref = _storage.ref().child(altPath);\n\n      final uploadTask = ref.putData(\n        bytes,\n        SettableMetadata(\n          contentType: _getContentType(file.path),\n          customMetadata: {\n            'uploaded_by': 'ios_alternative_path',\n            'original_path': path,\n          },\n        ),\n      );\n\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"âœ… iOS Alternative Method 2 successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"âŒ iOS Alternative Method 2 failed: $e\");\n    }\n\n    // Method 3: Very simple path\n    try {\n      debugPrint(\"ğŸ”„ iOS Alternative Method 3: Simple upload...\");\n      await Future.delayed(Duration(milliseconds: 5000));\n\n      final simplePath = \"uploads/${DateTime.now().millisecondsSinceEpoch}\";\n      debugPrint(\"ğŸ”„ iOS Simple path: $simplePath\");\n\n      final bytes = await file.readAsBytes();\n      final ref = _storage.ref().child(simplePath);\n\n      final uploadTask = ref.putData(bytes);\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"âœ… iOS Alternative Method 3 successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"âŒ iOS Alternative Method 3 failed: $e\");\n    }\n\n    debugPrint(\"âŒ All iOS alternative upload methods failed\");\n    return null;\n  }\n\n  String _getContentType(String filePath) {\n    final extension = filePath.toLowerCase().split('.').last;\n    switch (extension) {\n      case 'jpg':\n      case 'jpeg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n      case 'gif':\n        return 'image/gif';\n      case 'webp':\n        return 'image/webp';\n      default:\n        return 'image/jpeg'; // Default fallback\n    }\n  }\n}\n"
        }
    ]
}