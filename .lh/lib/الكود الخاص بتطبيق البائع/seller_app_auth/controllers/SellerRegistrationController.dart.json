{
    "sourceFile": "lib/الكود الخاص بتطبيق البائع/seller_app_auth/controllers/SellerRegistrationController.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1752491126687,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752491133502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,2048 @@\n+import 'dart:io';\n+import 'dart:async';\n+import 'package:cloud_firestore/cloud_firestore.dart';\n+import 'package:codora/%D8%A7%D9%84%D9%83%D9%88%D8%AF%20%D8%A7%D9%84%D8%AE%D8%A7%D8%B5%20%D8%A8%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%20%D8%A7%D9%84%D8%A8%D8%A7%D8%A6%D8%B9/seller_app_auth/controllers/seller_auth_controller.dart';\n+import 'package:firebase_auth/firebase_auth.dart';\n+import 'package:firebase_storage/firebase_storage.dart';\n+import 'package:firebase_messaging/firebase_messaging.dart';\n+import 'package:firebase_core/firebase_core.dart';\n+import 'package:flutter/material.dart';\n+import 'package:geolocator/geolocator.dart';\n+import 'package:get/get.dart';\n+import 'package:get_storage/get_storage.dart';\n+import 'package:google_maps_flutter/google_maps_flutter.dart';\n+import 'package:image_picker/image_picker.dart';\n+import 'package:intl/intl.dart'; // For DateFormat\n+import 'package:geocoding/geocoding.dart' as geo;\n+\n+import '../../../XXX/xxx_firebase.dart';\n+import '../../../Model/SellerModel.dart';\n+import '../../ui/seller_main_screen.dart';\n+import '../ui/OtpVerificationScreen.dart';\n+import '../ui/LocationPickerScreen.dart';\n+\n+class SellerRegistrationController extends GetxController {\n+  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n+  RxDouble currentPositionAccuracy = 0.0.obs;\n+\n+  // --- Firebase Instances ---\n+  final FirebaseAuth _auth = FirebaseAuth.instance;\n+  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n+  final FirebaseStorage _storage = FirebaseStorage.instance;\n+  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n+  final RxString verificationId = ''.obs; // To store Firebase's verification ID\n+\n+  // iOS-specific Firebase Storage handler\n+  late IOSFirebaseStorageHandler _iosStorageHandler;\n+\n+  // ==========================================================================\n+  // ==========================================================================\n+  // ==========================================================================\n+\n+  // لإضافة نوع البائع\n+  String? _sellerTypeFromAuth; // سيتم جلب هذا من SellerAuthController\n+\n+  final Rxn<int> resendToken = Rxn<int>(null); // For resending OTP\n+  final TextEditingController otpController = TextEditingController();\n+  final RxBool isOtpSending = false.obs; // Loading state for OTP sending\n+  final RxBool isOtpVerifying = false.obs; // Loading state for OTP verification\n+  Map<String, dynamic>? _tempSellerDataForSubmission;\n+  File? _tempSellerProfileImageFile;\n+  File? _tempShopFrontImageFile;\n+\n+  // --- Text Editing Controllers ---\n+  final TextEditingController sellerNameController = TextEditingController();\n+  final TextEditingController shopNameController = TextEditingController();\n+  final TextEditingController shopPhoneNumberController =\n+      TextEditingController();\n+  final TextEditingController shopDescriptionController =\n+      TextEditingController();\n+  // Add more controllers for other text fields like commercial reg no., etc.\n+\n+  // --- Image Pickers ---\n+  final ImagePicker _picker = ImagePicker();\n+  final Rxn<File> sellerProfileImageFile = Rxn<File>(null);\n+  final Rxn<File> shopFrontImageFile = Rxn<File>(null);\n+\n+  // --- Location ---\n+  final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n+  final RxString shopAddressText = ''.obs;\n+  GoogleMapController? mapController;\n+\n+  // --- Working Hours ---\n+  final List<String> dayKeys = [\n+    \"sunday_en\",\n+    \"monday_en\",\n+    \"tuesday_en\",\n+    \"wednesday_en\",\n+    \"thursday_en\",\n+    \"friday_en\",\n+    \"saturday_en\",\n+  ];\n+  final RxnString expandedDayPanel = RxnString(null); // For ExpansionPanelList\n+\n+  final RxMap<String, Map<String, dynamic>> workingHours =\n+      <String, Map<String, dynamic>>{\n+        \"sunday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"الأحد\",\n+        },\n+        \"monday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"الاثنين\",\n+        },\n+        \"tuesday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"الثلاثاء\",\n+        },\n+        \"wednesday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"الأربعاء\",\n+        },\n+        \"thursday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"الخميس\",\n+        },\n+        \"friday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"الجمعة\",\n+        },\n+        \"saturday_en\": {\n+          'isOpen': false,\n+          'opensAt': null,\n+          'closesAt': null,\n+          'name_ar': \"السبت\",\n+        },\n+      }.obs;\n+  final RxnString _lastAppliedOpensAt = RxnString(null);\n+  final RxnString _lastAppliedClosesAt = RxnString(null);\n+  // --- Main Categories ---\n+  // قائمة شاملة بجميع فئات المتاجر الممكنة\n+  final List<String> shopCategories = [\n+    \"إلكترونيات ومعدات تقنية\",\n+    \"ملابس وأزياء\",\n+    \"أحذية وحقائب\",\n+    \"طعام ومشروبات\",\n+    \"منتجات صحية وتجميل\",\n+    \"أدوية ومستلزمات طبية\",\n+    \"كتب ومواد تعليمية\",\n+    \"ألعاب وترفيه\",\n+    \"رياضة ولياقة\",\n+    \"أدوات منزلية ومطبخ\",\n+    \"أثاث وديكور\",\n+    \"حدائق ونباتات\",\n+    \"سيارات وقطع غيار\",\n+    \"أدوات وعدد يدوية\",\n+    \"مواد بناء وتشييد\",\n+    \"مجوهرات وساعات\",\n+    \"هدايا وتحف\",\n+    \"أطفال ومواليد\",\n+    \"حيوانات أليفة ومستلزمات\",\n+    \"موسيقى وآلات موسيقية\",\n+    \"خدمات مهنية\",\n+    \"خدمات تقنية\",\n+    \"خدمات توصيل\",\n+    \"خدمات تنظيف\",\n+    \"خدمات صيانة\",\n+    \"مواد غذائية عضوية\",\n+    \"حرف يدوية وفنون\",\n+    \"أقمشة وخياطة\",\n+    \"عطور ومواد تجميل\",\n+    \"أخرى\",\n+  ];\n+\n+  // الفئات المختارة (حد أقصى 6 فئات)\n+  final RxList<String> selectedShopCategories = <String>[].obs;\n+  final int maxCategoriesAllowed = 6;\n+\n+  // --- Loading State ---\n+  final RxBool isLoading = false.obs;\n+\n+  @override\n+  void onInit() {\n+    super.onInit();\n+\n+    // Initialize iOS-specific storage handler\n+    if (Platform.isIOS) {\n+      _iosStorageHandler = IOSFirebaseStorageHandler(_storage);\n+    }\n+\n+    // جلب SellerAuthController والحصول على sellerType\n+    try {\n+      final SellerAuthController authController =\n+          Get.find<SellerAuthController>();\n+      _sellerTypeFromAuth = authController.sellerType;\n+      if (_sellerTypeFromAuth != null) {\n+        debugPrint(\n+          \"SellerRegistrationController: تم جلب نوع البائع من AuthController: $_sellerTypeFromAuth\",\n+        );\n+      } else {\n+        debugPrint(\n+          \"SellerRegistrationController: لم يتم العثور على sellerType في AuthController. قد يحتاج المستخدم للعودة واختيار النوع.\",\n+        );\n+        // يمكنك هنا إضافة منطق لتوجيه المستخدم إذا كان sellerType ضروريًا ولا يمكن أن يكون null\n+        // مثال: Get.offAll(() => SellerTypeSelectionScreen()); أو عرض رسالة خطأ\n+      }\n+    } catch (e) {\n+      debugPrint(\n+        \"SellerRegistrationController: خطأ أثناء محاولة العثور على SellerAuthController أو الوصول إلى sellerType: $e\",\n+      );\n+      // معالجة الخطأ، ربما توجيه المستخدم أو عرض رسالة\n+    }\n+  }\n+\n+  @override\n+  void onClose() {\n+    sellerNameController.dispose();\n+    shopNameController.dispose();\n+    shopPhoneNumberController.dispose();\n+    shopDescriptionController.dispose();\n+    mapController?.dispose();\n+    otpController.dispose();\n+    super.onClose();\n+  }\n+\n+  void removeImage({required bool isProfileImage}) {\n+    if (isProfileImage) {\n+      sellerProfileImageFile.value = null;\n+    } else {\n+      shopFrontImageFile.value = null;\n+    }\n+    update(); // For GetBuilder if used, or just rely on Obx for reactive updates\n+  }\n+\n+  Future<void> initiatePhoneVerificationAndCollectData() async {\n+    debugPrint(\"🚀 initiatePhoneVerificationAndCollectData called\");\n+    debugPrint(\"Form validation starting...\");\n+\n+    if (!formKey.currentState!.validate()) {\n+      debugPrint(\"❌ Form validation failed\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى ملء جميع الحقول المطلوبة بشكل صحيح.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"✅ Form validation passed\");\n+\n+    // --- Add all your previous validations ---\n+    debugPrint(\"Checking profile image...\");\n+    if (sellerProfileImageFile.value == null) {\n+      debugPrint(\"❌ No profile image selected\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى اختيار صورة شخصية.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"✅ Profile image validation passed\");\n+\n+    debugPrint(\"Checking shop front image...\");\n+    if (shopFrontImageFile.value == null) {\n+      debugPrint(\"❌ No shop front image selected\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى اختيار صورة لواجهة المحل.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"✅ Shop front image validation passed\");\n+\n+    debugPrint(\"Checking shop location...\");\n+    if (shopLocation.value == null) {\n+      debugPrint(\"❌ No shop location selected\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى تحديد موقع المحل.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"✅ Shop location validation passed\");\n+\n+    debugPrint(\"Checking shop category...\");\n+    if (selectedShopCategories.isEmpty) {\n+      debugPrint(\"❌ No shop categories selected\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى اختيار فئة واحدة على الأقل للمتجر.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\n+      \"✅ Shop categories validation passed: ${selectedShopCategories.length} categories selected\",\n+    );\n+\n+    // التحقق إذا كان _sellerTypeFromAuth فارغًا قبل المتابعة (إذا كان إلزاميًا)\n+    debugPrint(\"Checking seller type...\");\n+    if (_sellerTypeFromAuth == null || _sellerTypeFromAuth!.isEmpty) {\n+      debugPrint(\"❌ No seller type selected\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"لم يتم تحديد نوع البائع. يرجى الرجوع واختيار نوع البائع.\",\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"✅ Seller type validation passed: $_sellerTypeFromAuth\");\n+\n+    debugPrint(\"Checking working hours...\");\n+    bool workingHoursValid = true;\n+    String firstInvalidDay = \"\";\n+    workingHours.forEach((key, value) {\n+      if ((value['isOpen'] == true) &&\n+          (value['opensAt'] == null || value['closesAt'] == null)) {\n+        workingHoursValid = false;\n+        firstInvalidDay = value['name_ar'] as String;\n+        return;\n+      }\n+    });\n+    if (!workingHoursValid) {\n+      debugPrint(\"❌ Working hours validation failed for day: $firstInvalidDay\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى تحديد أوقات الفتح والإغلاق لليوم المفتوح: $firstInvalidDay.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"✅ Working hours validation passed\");\n+\n+    String rawPhoneNumber = shopPhoneNumberController.text.trim();\n+    rawPhoneNumber = rawPhoneNumber.replaceAll(RegExp(r'\\s+'), '');\n+    if (rawPhoneNumber.startsWith('0')) {\n+      rawPhoneNumber = rawPhoneNumber.substring(1);\n+    }\n+    const String countryCode = \"+964\";\n+    final String formattedPhoneNumber = \"$countryCode$rawPhoneNumber\";\n+    debugPrint(\"الرقم المدخل الأصلي: ${shopPhoneNumberController.text}\");\n+    debugPrint(\n+      \"الرقم بعد إزالة المسافات والصفر وإضافة رمز الدولة: $formattedPhoneNumber\",\n+    );\n+\n+    final RegExp iraqiPhoneNumberRegExp = RegExp(r'^\\+9647[3-9]\\d{8}$');\n+    debugPrint(\"Checking phone number validation: $formattedPhoneNumber\");\n+    if (!iraqiPhoneNumberRegExp.hasMatch(formattedPhoneNumber)) {\n+      debugPrint(\"Phone number validation failed for: $formattedPhoneNumber\");\n+      Get.snackbar(\n+        \"رقم هاتف غير صالح\",\n+        \"الرجاء التأكد من إدخال رقم هاتف عراقي صحيح.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+    debugPrint(\"Phone number validation passed\");\n+\n+    // ---- Set loading states ----\n+    debugPrint(\"Setting loading states...\");\n+    isOtpSending.value = true;\n+    isLoading.value = true;\n+    update();\n+    debugPrint(\"Loading states set successfully\");\n+\n+    try {\n+      debugPrint(\"Preparing temp data for submission...\");\n+      _tempSellerProfileImageFile = sellerProfileImageFile.value;\n+      _tempShopFrontImageFile = shopFrontImageFile.value;\n+      _tempSellerDataForSubmission = {\n+        \"sellerName\": sellerNameController.text.trim(),\n+        \"shopName\": shopNameController.text.trim(),\n+        \"shopPhoneNumber\": shopPhoneNumberController.text.trim(),\n+        \"shopDescription\": shopDescriptionController.text.trim(),\n+        \"location\": GeoPoint(\n+          shopLocation.value!.latitude,\n+          shopLocation.value!.longitude,\n+        ),\n+        \"shopAddressText\": shopAddressText.value,\n+        \"shopCategories\": selectedShopCategories.toList(),\n+        \"workingHours\": Map<String, Map<String, dynamic>>.from(workingHours),\n+        \"streetAddress\": streetAddressController.text.trim(),\n+      };\n+      debugPrint(\"Temp data prepared successfully\");\n+\n+      debugPrint(\n+        \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n+      );\n+      debugPrint(\"FirebaseAuth instance: $_auth\");\n+\n+      // تفعيل reCAPTCHA للـ iOS صراحة\n+      if (Platform.isIOS) {\n+        debugPrint(\"Setting up reCAPTCHA for iOS...\");\n+        try {\n+          // إعدادات مختلفة للاختبار\n+          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n+\n+          await _auth.setSettings(\n+            appVerificationDisabledForTesting:\n+                isTestNumber, // للرقم التجريبي فقط\n+            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA للأرقام الحقيقية فقط\n+          );\n+\n+          debugPrint(\"✅ Firebase Auth settings configured for iOS\");\n+          debugPrint(\"📱 Test number mode: $isTestNumber\");\n+\n+          // إضافة تأخير قصير للسماح للإعدادات بالتطبيق\n+          await Future.delayed(const Duration(milliseconds: 500));\n+        } catch (e) {\n+          debugPrint(\"⚠️ Error setting Firebase Auth settings: $e\");\n+          // في حالة فشل إعدادات reCAPTCHA، جرب بدونها\n+          debugPrint(\"🔄 Trying without forced reCAPTCHA...\");\n+        }\n+      }\n+\n+      // إضافة timeout إضافي للتأكد من عمل الـ callbacks\n+      Timer callbackTimeoutTimer = Timer(const Duration(seconds: 30), () {\n+        if (isOtpSending.value || isLoading.value) {\n+          debugPrint(\"⚠️ Callback timeout - reCAPTCHA may not have appeared\");\n+          debugPrint(\"⚠️ This usually means Firebase Console settings issue\");\n+          isOtpSending.value = false;\n+          isLoading.value = false;\n+          isOtpVerifying.value = false;\n+          update();\n+          Get.snackbar(\n+            \"مشكلة في التحقق\",\n+            \"لم تظهر صفحة التحقق. تحقق من إعدادات Firebase أو جرب رقماً آخر.\",\n+            backgroundColor: Colors.orange.shade400,\n+            colorText: Colors.white,\n+            snackPosition: SnackPosition.BOTTOM,\n+            duration: const Duration(seconds: 5),\n+          );\n+        }\n+      });\n+\n+      await _auth.verifyPhoneNumber(\n+        phoneNumber: formattedPhoneNumber,\n+        forceResendingToken: resendToken.value,\n+        verificationCompleted: (PhoneAuthCredential credential) async {\n+          debugPrint(\"🎉 VERIFICATION COMPLETED CALLBACK TRIGGERED\");\n+          debugPrint(\n+            \"Phone auto-verified. Credential SMS code (if available): ${credential.smsCode}\",\n+          );\n+\n+          // إلغاء timeout timer\n+          callbackTimeoutTimer.cancel();\n+\n+          // التأكد من تحديث الحالة قبل المتابعة\n+          isOtpSending.value = false;\n+          isLoading.value = true;\n+          isOtpVerifying.value = true;\n+          update();\n+\n+          // إضافة تأخير قصير للسماح للـ UI بالتحديث على iOS\n+          if (Platform.isIOS) {\n+            await Future.delayed(const Duration(milliseconds: 100));\n+          }\n+\n+          await _finalizeSellerRegistration(isAutoVerified: true);\n+        },\n+        verificationFailed: (FirebaseAuthException e) {\n+          debugPrint(\"❌ VERIFICATION FAILED CALLBACK TRIGGERED\");\n+          debugPrint(\"Phone verification failed: ${e.code} - ${e.message}\");\n+          debugPrint(\"Full error: ${e.toString()}\");\n+\n+          // إلغاء timeout timer\n+          callbackTimeoutTimer.cancel();\n+\n+          // التأكد من إعادة تعيين جميع الحالات\n+          isOtpSending.value = false;\n+          isLoading.value = false;\n+          isOtpVerifying.value = false;\n+          update();\n+\n+          String errorMessage = \"فشل التحقق من رقم الهاتف.\";\n+          if (e.code == 'invalid-phone-number') {\n+            errorMessage =\n+                \"رقم الهاتف $formattedPhoneNumber الذي أدخلته غير صالح.\";\n+          } else if (e.code == 'too-many-requests') {\n+            errorMessage =\n+                \"تم إرسال عدد كبير جدا من الطلبات. حاول مرة أخرى لاحقًا.\";\n+          } else if (e.code == 'network-request-failed') {\n+            errorMessage =\n+                \"مشكلة في الاتصال بالإنترنت. يرجى التحقق من الاتصال والمحاولة مرة أخرى.\";\n+          }\n+          Get.snackbar(\n+            \"خطأ\",\n+            errorMessage,\n+            backgroundColor: Colors.red.shade400,\n+            colorText: Colors.white,\n+            snackPosition: SnackPosition.BOTTOM,\n+          );\n+        },\n+        codeSent: (String verId, int? resendTok) async {\n+          debugPrint(\"📱 CODE SENT CALLBACK TRIGGERED\");\n+          debugPrint(\n+            \"OTP code sent. Verification ID: $verId, Resend Token: $resendTok\",\n+          );\n+\n+          // إلغاء timeout timer\n+          callbackTimeoutTimer.cancel();\n+\n+          isOtpSending.value = false; // OTP sending part is done\n+          // isLoading remains true as we are waiting for OTP input\n+          update();\n+\n+          verificationId.value = verId;\n+          resendToken.value = resendTok;\n+\n+          // إضافة تأخير قصير على iOS للسماح للـ UI بالتحديث قبل التنقل\n+          if (Platform.isIOS) {\n+            await Future.delayed(const Duration(milliseconds: 200));\n+          }\n+\n+          // التأكد من أن التنقل يحدث على الـ main thread\n+          WidgetsBinding.instance.addPostFrameCallback((_) {\n+            debugPrint(\"Navigating to OTP verification screen...\");\n+            Get.to(() => OtpVerificationScreen());\n+          });\n+        },\n+        codeAutoRetrievalTimeout: (String verId) {\n+          debugPrint(\"⏰ CODE AUTO RETRIEVAL TIMEOUT CALLBACK TRIGGERED\");\n+          debugPrint(\"OTP auto-retrieval timed out. Verification ID: $verId\");\n+          verificationId.value = verId;\n+          // إعادة تعيين isOtpSending في حال timeout على iOS\n+          if (Platform.isIOS) {\n+            isOtpSending.value = false;\n+            update();\n+          }\n+        },\n+        timeout:\n+            Platform.isIOS\n+                ? const Duration(seconds: 60) // مدة أقصر على iOS\n+                : const Duration(seconds: 120), // مدة أطول على Android\n+      );\n+      debugPrint(\"✅ verifyPhoneNumber call completed successfully\");\n+    } catch (e) {\n+      debugPrint(\"🚨 EXCEPTION CAUGHT IN verifyPhoneNumber\");\n+      debugPrint(\"Exception type: ${e.runtimeType}\");\n+      debugPrint(\"Exception details: $e\");\n+\n+      // التأكد من إعادة تعيين جميع الحالات في حالة الخطأ\n+      isOtpSending.value = false;\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      update();\n+\n+      String errorMessage = \"حدث خطأ غير متوقع أثناء بدء التحقق من الهاتف.\";\n+\n+      // معالجة أخطاء محددة\n+      if (e.toString().contains('network')) {\n+        errorMessage = \"مشكلة في الشبكة. يرجى التحقق من الاتصال بالإنترنت.\";\n+      } else if (e.toString().contains('too-many-requests')) {\n+        errorMessage = \"تم إرسال عدد كبير من الطلبات. يرجى المحاولة لاحقاً.\";\n+      }\n+\n+      Get.snackbar(\n+        \"خطأ\",\n+        errorMessage,\n+        backgroundColor: Colors.red.shade500,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<void> verifyOtpAndFinalize(String otpCode) async {\n+    if (otpCode.isEmpty || otpCode.length < 6) {\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"يرجى إدخال رمز OTP الصحيح المكون من 6 أرقام.\",\n+        backgroundColor: Colors.orange.shade300,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      return;\n+    }\n+\n+    isOtpVerifying.value = true;\n+    isLoading.value =\n+        true; // isLoading should ideally be true from the previous step\n+    update();\n+\n+    try {\n+      PhoneAuthCredential credential = PhoneAuthProvider.credential(\n+        verificationId: verificationId.value,\n+        smsCode: otpCode,\n+      );\n+\n+      // **** خطوة التحقق الفعلية من الـ Credential هنا ****\n+      final User? currentUser = _auth.currentUser;\n+      if (currentUser == null) {\n+        throw FirebaseAuthException(\n+          code: 'no-current-user',\n+          message: 'No user is currently signed in.',\n+        );\n+      }\n+\n+      // محاولة ربط الـ Credential أو التحقق من OTP\n+      try {\n+        await currentUser.linkWithCredential(credential);\n+        debugPrint(\"Phone credential linked successfully.\");\n+      } catch (linkError) {\n+        if (linkError is FirebaseAuthException &&\n+            linkError.code == 'provider-already-linked') {\n+          debugPrint(\n+            \"Phone provider already linked, verifying OTP directly...\",\n+          );\n+          // إذا كان المزود مرتبط بالفعل، نتحقق من صحة OTP فقط\n+          await _auth.signInWithCredential(credential);\n+          debugPrint(\n+            \"OTP verified successfully with existing linked provider.\",\n+          );\n+        } else {\n+          rethrow; // إعادة طرح أي خطأ آخر\n+        }\n+      }\n+\n+      // إلغاء safety timeout لأن العملية نجحت\n+      _cancelSafetyTimeout();\n+\n+      // إذا نجح الربط أو التحقق، قم بإنهاء التسجيل\n+      await _finalizeSellerRegistration(isOtpNowVerified: true);\n+    } on FirebaseAuthException catch (e) {\n+      isOtpVerifying.value = false;\n+      isLoading.value = false;\n+      update();\n+      debugPrint(\n+        \"FirebaseAuthException during OTP verification: ${e.code} - ${e.message}\",\n+      );\n+      String errorMessage = \"فشل التحقق من رمز OTP.\";\n+      if (e.code == 'invalid-verification-code' ||\n+          e.code == 'invalid-credential') {\n+        errorMessage = \"رمز OTP الذي أدخلته غير صحيح.\";\n+      } else if (e.code == 'session-expired') {\n+        errorMessage = \"انتهت صلاحية جلسة التحقق. يرجى طلب رمز جديد.\";\n+      } else if (e.code == 'credential-already-in-use') {\n+        // هذه حالة خاصة: الرقم مرتبط بالفعل بحساب آخر. أو إذا كان مرتبطًا بنفس الحساب، يمكن اعتبارها نجاحًا.\n+        // هنا، نفترض أننا إذا وصلنا لهذه النقطة، والرقم مرتبط بنفس المستخدم، فهذا جيد.\n+        // ولكن إذا كان مرتبطًا بمستخدم مختلف، فهذه مشكلة.\n+        // للحفاظ على البساطة، سنعتبرها خطأ عام الآن، ولكن يمكن تحسين هذا.\n+        // أو إذا كان هذا يعني أنه مرتبط بالفعل بهذا المستخدم، يمكن المتابعة.\n+        // الخيار الأبسط هو معالجته كخطأ إذا لم تكن متأكدًا من كيفية التعامل مع هذا الحساب.\n+        // إذا كان يمكن أن يكون مرتبطًا بالفعل بهذا المستخدم، يمكن استدعاء _finalizeSellerRegistration هنا أيضًا.\n+        // For now, treat as a specific error message or proceed if logic allows\n+        debugPrint(\n+          \"Credential already in use. Assuming for this user is okay or needs specific handling.\",\n+        );\n+        // إذا كان الرقم مرتبطًا بالفعل بنفس المستخدم، قد يكون هذا هو المسار الصحيح\n+        // await _finalizeSellerRegistration(isOtpNowVerified: true);\n+        // Get.snackbar(\"معلومة\", \"رقم الهاتف هذا تم التحقق منه بالفعل لهذا الحساب.\", snackPosition: SnackPosition.BOTTOM);\n+        // return;\n+        errorMessage =\n+            \"رقم الهاتف هذا مرتبط بالفعل. إذا كان هذا حسابك، يمكنك المتابعة أو الاتصال بالدعم.\";\n+      } else if (e.code == 'no-current-user') {\n+        errorMessage =\n+            \"انتهت جلسة المستخدم. يرجى تسجيل الدخول مرة أخرى والمحاولة.\";\n+        // يمكنك هنا توجيه المستخدم لصفحة الدخول\n+      }\n+      Get.snackbar(\n+        \"خطأ\",\n+        errorMessage,\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    } catch (e) {\n+      isOtpVerifying.value = false;\n+      isLoading.value = false;\n+      update();\n+      debugPrint(\"Generic error verifying OTP: $e\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"حدث خطأ غير متوقع أثناء التحقق من الرمز.\",\n+        backgroundColor: Colors.red.shade500,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<void> _finalizeSellerRegistration({\n+    bool isAutoVerified = false,\n+    bool isOtpNowVerified = false,\n+  }) async {\n+    debugPrint(\"🔧 _finalizeSellerRegistration called\");\n+    debugPrint(\n+      \"🔧 isAutoVerified: $isAutoVerified, isOtpNowVerified: $isOtpNowVerified\",\n+    );\n+\n+    // إذا لم يتم التحقق تلقائيًا ولم يتم التحقق الآن (من verifyOtpAndFinalize)، فلا تتابع\n+    if (!isAutoVerified && !isOtpNowVerified) {\n+      debugPrint(\"❌ Neither auto verified nor OTP verified - stopping\");\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"لم يتم التحقق من صحة رقم الهاتف.\",\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      return;\n+    }\n+\n+    debugPrint(\n+      \"✅ Phone verification confirmed, proceeding with registration...\",\n+    );\n+\n+    // Set loading states for this final part\n+    isOtpVerifying.value = true;\n+    isLoading.value = true;\n+    update();\n+\n+    try {\n+      final User? currentUser = _auth.currentUser;\n+      if (currentUser == null) {\n+        Get.snackbar(\n+          \"خطأ\",\n+          \"لم يتم العثور على مستخدم حالي. يرجى تسجيل الدخول مرة أخرى.\",\n+          backgroundColor: Colors.red.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+        );\n+        isLoading.value = false;\n+        isOtpVerifying.value = false;\n+        // Navigate to login or welcome screen\n+        return;\n+      }\n+\n+      String? sellerProfileImageUrl;\n+      String? shopFrontImageUrl;\n+\n+      // iOS-specific: Wait for Firebase to be fully ready\n+      if (Platform.isIOS) {\n+        debugPrint(\n+          \"🔧 iOS detected - waiting for Firebase Storage to be ready...\",\n+        );\n+        await Future.delayed(Duration(milliseconds: 3000));\n+\n+        // Verify Firebase Storage is accessible\n+        try {\n+          _storage.ref().child('test_connection');\n+          debugPrint(\"✅ Firebase Storage connection test passed\");\n+        } catch (e) {\n+          debugPrint(\"⚠️ Firebase Storage connection test failed: $e\");\n+        }\n+      }\n+\n+      if (_tempSellerProfileImageFile != null) {\n+        debugPrint(\"🖼️ Uploading seller profile image...\");\n+        if (Platform.isIOS) {\n+          sellerProfileImageUrl = await _iosStorageHandler.uploadFile(\n+            _tempSellerProfileImageFile!,\n+            'seller_profile_images/${currentUser.uid}',\n+          );\n+        } else {\n+          sellerProfileImageUrl = await _uploadFile(\n+            _tempSellerProfileImageFile!,\n+            'seller_profile_images/${currentUser.uid}',\n+          );\n+        }\n+      }\n+      if (_tempShopFrontImageFile != null) {\n+        debugPrint(\"🏪 Uploading shop front image...\");\n+        if (Platform.isIOS) {\n+          shopFrontImageUrl = await _iosStorageHandler.uploadFile(\n+            _tempShopFrontImageFile!,\n+            'shop_front_images/${currentUser.uid}',\n+          );\n+        } else {\n+          shopFrontImageUrl = await _uploadFile(\n+            _tempShopFrontImageFile!,\n+            'shop_front_images/${currentUser.uid}',\n+          );\n+        }\n+      }\n+\n+      if (_tempSellerProfileImageFile != null &&\n+          sellerProfileImageUrl == null) {\n+        throw Exception(\"Failed to upload seller profile image.\");\n+      }\n+      if (_tempShopFrontImageFile != null && shopFrontImageUrl == null) {\n+        throw Exception(\"Failed to upload shop front image.\");\n+      }\n+\n+      // الحصول على FCM Token بشكل احترافي\n+      final String? fcmToken = await _getFCMTokenSafely();\n+\n+      // استخدام SellerModel لإنشاء البيانات\n+      final SellerModel sellerToSave = SellerModel(\n+        uid: currentUser.uid,\n+        sellerName:\n+            _tempSellerDataForSubmission?['sellerName'] as String? ?? '',\n+        sellerProfileImageUrl: sellerProfileImageUrl,\n+        shopName: _tempSellerDataForSubmission?['shopName'] as String? ?? '',\n+        shopFrontImageUrl: shopFrontImageUrl,\n+        shopPhoneNumber:\n+            _tempSellerDataForSubmission?['shopPhoneNumber'] as String? ?? '',\n+        shopDescription:\n+            _tempSellerDataForSubmission?['shopDescription'] as String?,\n+        location:\n+            _tempSellerDataForSubmission?['location'] as GeoPoint? ??\n+            const GeoPoint(\n+              0,\n+              0,\n+            ), // تم التأكد من أن location هو GeoPoint في _tempSellerDataForSubmission\n+        shopAddressText:\n+            _tempSellerDataForSubmission?['shopAddressText'] as String?,\n+        shopCategory:\n+            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'أخرى',\n+        workingHours: Map<String, dynamic>.from(\n+          _tempSellerDataForSubmission?['workingHours'] ?? {},\n+        ),\n+        // الحقول التالية اختيارية في SellerModel وسيتم تعيينها إلى null إذا لم تكن موجودة في _tempSellerDataForSubmission\n+        commercialRegistrationNumber:\n+            _tempSellerDataForSubmission?['commercialRegistrationNumber']\n+                as String?,\n+        websiteUrl: _tempSellerDataForSubmission?['websiteUrl'] as String?,\n+        socialMediaLinks:\n+            _tempSellerDataForSubmission?['socialMediaLinks']\n+                as Map<String, String>?,\n+\n+        isProfileComplete: true, // تم إكمال الملف الشخصي في هذه المرحلة\n+        isApprovedByAdmin: false, // يحتاج موافقة المشرف بشكل افتراضي\n+        isActiveBySeller: true, // نشط مبدئيًا\n+        isPhoneNumberVerified: true, // تم التحقق من الهاتف في هذه المرحلة\n+        averageRating: 0.0,\n+        numberOfRatings: 0,\n+        sellerType: _sellerTypeFromAuth, // من SellerAuthController\n+        registrationCompleted: true, // اكتمل التسجيل في هذه المرحلة\n+        createdAt:\n+            Timestamp.now(), // سيتم استبداله بـ FieldValue.serverTimestamp() أدناه\n+        updatedAt:\n+            null, // SellerModel.toMap() سيعين FieldValue.serverTimestamp() لهذا\n+      );\n+\n+      Map<String, dynamic> sellerDataToSave = sellerToSave.toMap();\n+\n+      // التأكد من استخدام الطوابع الزمنية للخادم وإضافة الحقول غير الموجودة في SellerModel\n+      sellerDataToSave['createdAt'] = FieldValue.serverTimestamp();\n+      sellerDataToSave['updatedAt'] =\n+          FieldValue.serverTimestamp(); // للتأكيد أو إذا كان SellerModel.toMap لا يفعل ذلك\n+\n+      // إضافة الحقول التي ليست جزءًا من SellerModel ولكنها مطلوبة في Firestore\n+      sellerDataToSave['email'] = currentUser.email;\n+\n+      // معالجة احترافية لحفظ FCM Token\n+      if (fcmToken != null && fcmToken.isNotEmpty) {\n+        sellerDataToSave['fcmToken'] = fcmToken;\n+        sellerDataToSave['fcmTokenUpdatedAt'] = FieldValue.serverTimestamp();\n+        debugPrint(\n+          \"✅ FCM Token will be saved: ${fcmToken.substring(0, 30)}...\",\n+        );\n+      } else {\n+        debugPrint(\n+          \"⚠️ No FCM Token available - saving without notification capability\",\n+        );\n+        // لا نحفظ fcmToken إذا كان null لتجنب overwrite أي token موجود\n+        sellerDataToSave['fcmTokenStatus'] = 'failed_to_retrieve';\n+        sellerDataToSave['fcmTokenFailedAt'] = FieldValue.serverTimestamp();\n+\n+        // جدولة إعادة المحاولة بعد التسجيل\n+        debugPrint(\"📅 Scheduling FCM token retry for later...\");\n+      }\n+\n+      debugPrint(\"💾 Saving seller data to Firestore...\");\n+      debugPrint(\"💾 Document ID: ${currentUser.uid}\");\n+      debugPrint(\"💾 Collection: ${FirebaseX.collectionSeller}\");\n+\n+      await _firestore\n+          .collection(FirebaseX.collectionSeller)\n+          .doc(currentUser.uid)\n+          .set(sellerDataToSave, SetOptions(merge: true));\n+\n+      debugPrint(\"✅ Seller data saved successfully to Firestore!\");\n+\n+      // التأكد من إعادة تعيين الحالات قبل التنقل\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      update();\n+\n+      debugPrint(\"🎉 Registration completed successfully!\");\n+\n+      // إذا لم نحصل على FCM token، جدولة إعادة المحاولة\n+      if (fcmToken == null || fcmToken.isEmpty) {\n+        retryFCMTokenLater();\n+      }\n+\n+      Get.snackbar(\n+        \"نجاح\",\n+        \"تم تسجيل معلوماتك بنجاح!\",\n+        backgroundColor: Colors.green.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+\n+      // إضافة تأخير قصير على iOS قبل التنقل\n+      if (Platform.isIOS) {\n+        await Future.delayed(const Duration(milliseconds: 500));\n+      }\n+\n+      // التأكد من التنقل على الـ main thread\n+      WidgetsBinding.instance.addPostFrameCallback((_) {\n+        Get.offAll(\n+          () => SellerMainScreen(),\n+        ); // Navigate to seller dashboard or main screen\n+      });\n+    } catch (e) {\n+      isLoading.value = false;\n+      isOtpVerifying.value = false;\n+      update();\n+      debugPrint(\"Error finalizing seller registration: $e\");\n+      String errorMessage = \"فشل إكمال عملية التسجيل.\";\n+      if (e is FirebaseException &&\n+          e.code == 'invalid-credential' &&\n+          isAutoVerified) {\n+        errorMessage =\n+            \"فشل التحقق التلقائي من الهاتف. قد تحتاج إلى إدخال الرمز يدويًا.\";\n+        // Optionally, you could re-route to OTP screen if auto-verification was the only path here\n+        // Get.to(() => OtpVerificationScreen()); // Might need to handle this case more gracefully\n+      } else if (e is FirebaseException &&\n+          e.code == 'invalid-verification-code') {\n+        errorMessage = \"رمز OTP الذي أدخلته غير صحيح.\";\n+      } else if (e is FirebaseException && e.code == 'session-expired') {\n+        errorMessage = \"انتهت صلاحية جلسة التحقق. يرجى طلب رمز جديد.\";\n+      }\n+\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"$errorMessage يرجى المحاولة مرة أخرى.\",\n+        backgroundColor: Colors.red.shade400,\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<String?> _uploadFile(File file, String path) async {\n+    try {\n+      debugPrint(\"🔧 Starting file upload to: $path\");\n+      debugPrint(\"🔧 File exists: ${await file.exists()}\");\n+      debugPrint(\"🔧 File size: ${await file.length()} bytes\");\n+\n+      // Verify Firebase Storage is properly initialized\n+      if (Firebase.apps.isEmpty) {\n+        throw Exception(\"Firebase not initialized\");\n+      }\n+\n+      final ref = _storage.ref().child(path);\n+      debugPrint(\"🔧 Storage reference created: ${ref.fullPath}\");\n+\n+      // iOS-specific: Add metadata to help with upload\n+      final metadata = SettableMetadata(\n+        contentType: 'image/jpeg',\n+        customMetadata: {\n+          'uploaded_by': 'seller_registration',\n+          'platform': Platform.isIOS ? 'ios' : 'android',\n+        },\n+      );\n+\n+      final uploadTask = ref.putFile(file, metadata);\n+\n+      // Monitor upload progress\n+      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n+        final progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n+        debugPrint(\"🔧 Upload progress: ${progress.toStringAsFixed(1)}%\");\n+      });\n+\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"✅ File uploaded successfully: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"❌ Error uploading file ($path): $e\");\n+\n+      // iOS-specific error handling\n+      if (Platform.isIOS && e.toString().contains('object-not-found')) {\n+        debugPrint(\n+          \"🔧 iOS Storage issue detected - retrying with different approach\",\n+        );\n+        return await _uploadFileWithRetry(file, path);\n+      }\n+\n+      return null;\n+    }\n+  }\n+\n+  Future<String?> _uploadFileWithRetry(File file, String path) async {\n+    try {\n+      // Wait a bit longer on iOS\n+      await Future.delayed(Duration(milliseconds: 1500));\n+\n+      // Try with a different path structure for iOS\n+      final timestamp = DateTime.now().millisecondsSinceEpoch;\n+      final newPath = '${path.replaceAll('/', '_')}_$timestamp';\n+\n+      debugPrint(\"🔧 Retrying upload with path: $newPath\");\n+\n+      final ref = _storage.ref().child(newPath);\n+      final uploadTask = ref.putFile(file);\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"✅ Retry upload successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"❌ Retry upload also failed: $e\");\n+      return null;\n+    }\n+  }\n+\n+  Future<void> pickImage(\n+    ImageSource source, {\n+    required bool isProfileImage,\n+  }) async {\n+    try {\n+      final XFile? pickedFile = await _picker.pickImage(\n+        source: source,\n+        imageQuality: 70,\n+        maxWidth: 1024,\n+      );\n+      if (pickedFile != null) {\n+        if (isProfileImage) {\n+          sellerProfileImageFile.value = File(pickedFile.path);\n+        } else {\n+          shopFrontImageFile.value = File(pickedFile.path);\n+        }\n+        update(); // For GetBuilder if used\n+      }\n+    } catch (e) {\n+      Get.snackbar(\"خطأ في الصورة\", \"فشل في اختيار الصورة: $e\");\n+    }\n+  }\n+\n+  // دالة لإدارة اختيار الفئات المتعددة\n+  void toggleCategorySelection(String category) {\n+    if (selectedShopCategories.contains(category)) {\n+      selectedShopCategories.remove(category);\n+    } else {\n+      if (selectedShopCategories.length < maxCategoriesAllowed) {\n+        selectedShopCategories.add(category);\n+      } else {\n+        Get.snackbar(\n+          \"تحذير\",\n+          \"يمكنك اختيار حد أقصى $maxCategoriesAllowed فئات فقط\",\n+          backgroundColor: Colors.orange.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+        );\n+      }\n+    }\n+  }\n+\n+  // دالة للتحقق من اختيار الفئة\n+  bool isCategorySelected(String category) {\n+    return selectedShopCategories.contains(category);\n+  }\n+\n+  // دالة للحصول على عدد الفئات المختارة\n+  int get selectedCategoriesCount => selectedShopCategories.length;\n+\n+  // دالة للحصول على نص عرض الفئات المختارة\n+  String get selectedCategoriesDisplay {\n+    if (selectedShopCategories.isEmpty) {\n+      return 'لم يتم اختيار أي فئة';\n+    } else if (selectedShopCategories.length == 1) {\n+      return selectedShopCategories.first;\n+    } else {\n+      return '${selectedShopCategories.length} فئات مختارة';\n+    }\n+  }\n+\n+  void toggleDayOpen(String dayKey) {\n+    if (workingHours[dayKey] != null) {\n+      bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n+      workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n+\n+      if (!workingHours[dayKey]!['isOpen']) {\n+        // If day is being closed\n+        workingHours[dayKey]!['opensAt'] = null;\n+        workingHours[dayKey]!['closesAt'] = null;\n+        if (expandedDayPanel.value == dayKey) {\n+          // Close expansion panel if it was this day\n+          expandedDayPanel.value = null;\n+        }\n+      } else {\n+        // If day is being opened\n+        workingHours[dayKey]!['opensAt'] =\n+            _lastAppliedOpensAt.value ?? \"09:00 AM\";\n+        workingHours[dayKey]!['closesAt'] =\n+            _lastAppliedClosesAt.value ?? \"05:00 PM\";\n+        // Optionally, open this panel when day is toggled on if not already open by user interaction\n+        // expandedDayPanel.value = dayKey;\n+      }\n+      workingHours.refresh();\n+    }\n+  }\n+\n+  bool canApplyToOthers(String dayKey) {\n+    final dayData = workingHours[dayKey];\n+    if (dayData == null || !(dayData['isOpen'] == true)) return false;\n+    return dayData['opensAt'] != null && dayData['closesAt'] != null;\n+  }\n+\n+  void offerToApplyTimesToOtherDays(\n+    BuildContext context,\n+    String sourceDayKey,\n+    String opensAtToApply,\n+    String closesAtToApply,\n+  ) {\n+    Get.dialog(\n+      AlertDialog(\n+        title: const Text(\"تطبيق الأوقات؟\"),\n+        content: Text(\n+          \"هل ترغب في تطبيق وقت الفتح ($opensAtToApply) ووقت الإغلاق ($closesAtToApply) على الأيام الأخرى التي تم تحديدها كمفتوحة ولم يتم تحديد أوقات لها بعد أو على جميع الأيام المفتوحة؟\",\n+        ),\n+        actionsAlignment: MainAxisAlignment.spaceEvenly,\n+        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),\n+        actions: [\n+          TextButton(child: const Text(\"إلغاء\"), onPressed: () => Get.back()),\n+          ElevatedButton(\n+            child: const Text(\"للأيام الفارغة فقط\"),\n+            onPressed: () {\n+              Get.back();\n+              applyTimesToOtherOpenDays(\n+                sourceDayKey,\n+                opensAtToApply,\n+                closesAtToApply,\n+                applyToAllOpen: false,\n+              );\n+            },\n+          ),\n+          ElevatedButton(\n+            child: const Text(\"نعم، للكل (المفتوح)\"),\n+            onPressed: () {\n+              Get.back();\n+              applyTimesToOtherOpenDays(\n+                sourceDayKey,\n+                opensAtToApply,\n+                closesAtToApply,\n+                applyToAllOpen: true,\n+              );\n+            },\n+          ),\n+        ],\n+      ),\n+      barrierDismissible: true,\n+    );\n+  }\n+\n+  void applyTimesToOtherOpenDays(\n+    String sourceDayKey,\n+    String opensAtToApply,\n+    String closesAtToApply, {\n+    required bool applyToAllOpen,\n+  }) {\n+    bool timesApplied = false;\n+    workingHours.forEach((key, value) {\n+      if (key != sourceDayKey && (value['isOpen'] == true)) {\n+        bool apply = false;\n+        if (applyToAllOpen) {\n+          apply = true;\n+        } else {\n+          // Apply to empty open days only\n+          if (value['opensAt'] == null || value['closesAt'] == null) {\n+            apply = true;\n+          }\n+        }\n+        if (apply) {\n+          value['opensAt'] = opensAtToApply;\n+          value['closesAt'] = closesAtToApply;\n+          timesApplied = true;\n+        }\n+      }\n+    });\n+    if (timesApplied) {\n+      _lastAppliedOpensAt.value =\n+          opensAtToApply; // Update template if changes were made\n+      _lastAppliedClosesAt.value = closesAtToApply;\n+      workingHours.refresh();\n+      Get.snackbar(\n+        \"تم التحديث\",\n+        \"تم تطبيق الأوقات بنجاح.\",\n+        snackPosition: SnackPosition.BOTTOM,\n+        backgroundColor: Colors.green.shade400,\n+        colorText: Colors.white,\n+      );\n+    } else {\n+      Get.snackbar(\n+        \"لم يتغير شيء\",\n+        \"لم يتم العثور على أيام لتطبيق الأوقات عليها حسب اختيارك.\",\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    }\n+  }\n+\n+  Future<void> selectTime(\n+    BuildContext context,\n+    String dayKey,\n+    bool isOpeningTime,\n+  ) async {\n+    final Map<String, dynamic>? dayData = workingHours[dayKey];\n+    final String? opensAtString = dayData?['opensAt'] as String?;\n+    final String? closesAtString = dayData?['closesAt'] as String?;\n+\n+    String? timeToParse;\n+    if (isOpeningTime) {\n+      timeToParse = opensAtString;\n+    } else {\n+      timeToParse = closesAtString;\n+    }\n+\n+    TimeOfDay? initialTime = _parseTime(timeToParse) ?? TimeOfDay.now();\n+\n+    final TimeOfDay? pickedTime = await showTimePicker(\n+      context: context,\n+      initialTime: initialTime,\n+      builder: (context, child) {\n+        return Theme(\n+          data: ThemeData.light().copyWith(\n+            colorScheme: ColorScheme.light(\n+              primary: Get.theme.primaryColor, // header background color\n+              onPrimary: Colors.white, // header text color\n+              onSurface: Colors.black, // body text color\n+            ),\n+            timePickerTheme: TimePickerThemeData(\n+              dialHandColor: Get.theme.primaryColor,\n+            ),\n+            textButtonTheme: TextButtonThemeData(\n+              style: TextButton.styleFrom(\n+                foregroundColor: Get.theme.primaryColor, // button text color\n+              ),\n+            ),\n+          ),\n+          child: child!,\n+        );\n+      },\n+    );\n+\n+    if (pickedTime != null) {\n+      final formattedTime = formatTimeOfDay(pickedTime);\n+      final currentOpensAt = _parseTime(workingHours[dayKey]?['opensAt']);\n+      final currentClosesAt = _parseTime(workingHours[dayKey]?['closesAt']);\n+\n+      if (isOpeningTime) {\n+        if (currentClosesAt != null &&\n+            _isTimeBeforeOrEqual(\n+              pickedTime,\n+              currentClosesAt,\n+              isOpening: true,\n+              isClosing: false,\n+            )) {\n+          workingHours[dayKey]!['opensAt'] = formattedTime;\n+          _lastAppliedOpensAt.value = formattedTime;\n+        } else if (currentClosesAt != null) {\n+          Get.snackbar(\n+            \"وقت غير صالح\",\n+            \"وقت الفتح يجب أن يكون قبل وقت الإغلاق.\",\n+            snackPosition: SnackPosition.BOTTOM,\n+            backgroundColor: Colors.orange.shade300,\n+          );\n+          return;\n+        } else {\n+          // No closing time set yet, allow setting opening time\n+          workingHours[dayKey]!['opensAt'] = formattedTime;\n+          _lastAppliedOpensAt.value = formattedTime;\n+        }\n+      } else {\n+        // isClosingTime\n+        if (currentOpensAt != null &&\n+            _isTimeBeforeOrEqual(\n+              currentOpensAt,\n+              pickedTime,\n+              isOpening: false,\n+              isClosing: true,\n+            )) {\n+          workingHours[dayKey]!['closesAt'] = formattedTime;\n+          _lastAppliedClosesAt.value = formattedTime;\n+        } else if (currentOpensAt != null) {\n+          Get.snackbar(\n+            \"وقت غير صالح\",\n+            \"وقت الإغلاق يجب أن يكون بعد وقت الفتح.\",\n+            snackPosition: SnackPosition.BOTTOM,\n+            backgroundColor: Colors.orange.shade300,\n+          );\n+          return;\n+        } else {\n+          // No opening time set yet, allow setting closing time\n+          workingHours[dayKey]!['closesAt'] = formattedTime;\n+          _lastAppliedClosesAt.value = formattedTime;\n+        }\n+      }\n+      workingHours.refresh();\n+    }\n+  }\n+\n+  bool _isTimeBeforeOrEqual(\n+    TimeOfDay time1,\n+    TimeOfDay time2, {\n+    required bool isOpening,\n+    required bool isClosing,\n+  }) {\n+    final time1Minutes = time1.hour * 60 + time1.minute;\n+    final time2Minutes = time2.hour * 60 + time2.minute;\n+    if (isOpening) {\n+      // time1 is opensAt, time2 is closesAt\n+      return time1Minutes < time2Minutes;\n+    } else {\n+      // time1 is opensAt, time2 is closesAt\n+      return time1Minutes < time2Minutes;\n+    }\n+  }\n+\n+  String formatTimeOfDay(TimeOfDay tod) {\n+    final now = DateTime.now();\n+    final dt = DateTime(now.year, now.month, now.day, tod.hour, tod.minute);\n+    final format = DateFormat.jm(); // e.g., 5:08 PM\n+    return format.format(dt);\n+  }\n+\n+  TimeOfDay? _parseTime(String? timeString) {\n+    if (timeString == null) return null;\n+    try {\n+      final format =\n+          DateFormat.jm(); // Needs to match the format used in formatTimeOfDay\n+      final dt = format.parse(timeString);\n+      return TimeOfDay.fromDateTime(dt);\n+    } catch (e) {\n+      debugPrint(\"Error parsing time: $e\");\n+      return null;\n+    }\n+  }\n+\n+  // --- Location Methods ---\n+  final TextEditingController streetAddressController = TextEditingController();\n+\n+  void onMapCreated(GoogleMapController controller) {\n+    mapController = controller;\n+  }\n+\n+  Future<void> openLocationPickerScreen(BuildContext context) async {\n+    final LatLng? result = await Get.to<LatLng>(\n+      () => LocationPickerScreen(initialLocation: shopLocation.value),\n+    );\n+    if (result != null) {\n+      shopLocation.value = result;\n+      await _getAddressFromLatLng(result);\n+      // Optionally move camera on the small map if it's visible and controller is available\n+      mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n+    }\n+  }\n+\n+  Future<void> _getAddressFromLatLng(LatLng latLng) async {\n+    try {\n+      List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n+        latLng.latitude,\n+        latLng.longitude,\n+      );\n+      if (placemarks.isNotEmpty) {\n+        final p = placemarks[0];\n+        // Construct a more detailed or relevant address string\n+        shopAddressText.value =\n+            \"${p.name}, ${p.locality}, ${p.subAdministrativeArea}, ${p.administrativeArea}\"\n+                .replaceAll(\"null,\", \"\")\n+                .trim()\n+                .replaceAll(RegExp(r'^, |,$'), '');\n+        if (streetAddressController.text.isEmpty &&\n+            p.street != null &&\n+            p.street!.isNotEmpty) {\n+          streetAddressController.text = p.street!;\n+        }\n+      } else {\n+        shopAddressText.value = \"تعذر جلب العنوان\";\n+      }\n+    } catch (e) {\n+      debugPrint(\"Error getting address: $e\");\n+      shopAddressText.value = \"خطأ في جلب العنوان\";\n+    }\n+  }\n+\n+  Future<void> tryMoveToCurrentLocation() async {\n+    isLoading.value = true; // Indicate loading for location fetch\n+    update();\n+    try {\n+      Position currentPosition = await _determinePosition();\n+      LatLng newLatLng = LatLng(\n+        currentPosition.latitude,\n+        currentPosition.longitude,\n+      );\n+      shopLocation.value = newLatLng;\n+      await _getAddressFromLatLng(newLatLng);\n+      mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n+    } catch (e) {\n+      Get.snackbar(\n+        \"خطأ\",\n+        \"فشل في تحديد الموقع الحالي: ${e.toString()}\",\n+        snackPosition: SnackPosition.BOTTOM,\n+      );\n+    } finally {\n+      isLoading.value = false;\n+      update();\n+    }\n+  }\n+\n+  Future<Position> _determinePosition() async {\n+    bool serviceEnabled;\n+    LocationPermission permission;\n+\n+    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n+    if (!serviceEnabled) {\n+      // Attempt to open location settings\n+      await Geolocator.openLocationSettings();\n+      return Future.error('خدمات الموقع معطلة. يرجى تفعيلها.');\n+    }\n+\n+    permission = await Geolocator.checkPermission();\n+    if (permission == LocationPermission.denied) {\n+      permission = await Geolocator.requestPermission();\n+      if (permission == LocationPermission.denied) {\n+        return Future.error('تم رفض أذونات تحديد الموقع.');\n+      }\n+    }\n+\n+    if (permission == LocationPermission.deniedForever) {\n+      return Future.error(\n+        'أذونات تحديد الموقع مرفوضة بشكل دائم، لا يمكننا طلب الأذونات. يرجى تفعيلها من الإعدادات.',\n+      );\n+    }\n+    currentPositionAccuracy.value =\n+        (await Geolocator.getCurrentPosition()).accuracy;\n+\n+    return await Geolocator.getCurrentPosition(\n+      desiredAccuracy: LocationAccuracy.high,\n+    );\n+  }\n+\n+  void submitRegistration(BuildContext context) {\n+    debugPrint(\"🔥 submitRegistration called\");\n+\n+    // This method will now call initiatePhoneVerificationAndCollectData\n+    // as OTP verification is mandatory.\n+\n+    // إضافة حماية إضافية من التجميد\n+    _startSafetyTimeout();\n+\n+    debugPrint(\"About to call initiatePhoneVerificationAndCollectData...\");\n+    initiatePhoneVerificationAndCollectData();\n+    debugPrint(\"initiatePhoneVerificationAndCollectData call completed\");\n+  }\n+\n+  // آلية حماية إضافية لتجنب التجميد على iOS\n+  Timer? _safetyTimer;\n+\n+  void _startSafetyTimeout() {\n+    _safetyTimer = Timer(Duration(seconds: Platform.isIOS ? 60 : 90), () {\n+      if ((isLoading.value || isOtpSending.value) && !isOtpVerifying.value) {\n+        debugPrint(\"Safety timeout triggered - resetting loading states\");\n+        isLoading.value = false;\n+        isOtpSending.value = false;\n+        isOtpVerifying.value = false;\n+        update();\n+        Get.snackbar(\n+          \"انتهت المهلة الزمنية\",\n+          \"تم انتهاء الوقت المحدد للعملية. يرجى المحاولة مرة أخرى.\",\n+          backgroundColor: Colors.orange.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+        );\n+      }\n+    });\n+  }\n+\n+  void _cancelSafetyTimeout() {\n+    _safetyTimer?.cancel();\n+    _safetyTimer = null;\n+  }\n+\n+  /// دالة احترافية للحصول على FCM Token مع معالجة شاملة للأخطاء\n+  Future<String?> _getFCMTokenSafely() async {\n+    debugPrint(\"🔑 Starting FCM token retrieval process...\");\n+\n+    try {\n+      // 1. طلب الأذونات أولاً\n+      debugPrint(\"📱 Requesting Firebase Messaging permissions...\");\n+      NotificationSettings settings = await _firebaseMessaging\n+          .requestPermission(\n+            alert: true,\n+            announcement: false,\n+            badge: true,\n+            carPlay: false,\n+            criticalAlert: false,\n+            provisional: false,\n+            sound: true,\n+          );\n+\n+      debugPrint(\"🔔 Permission status: ${settings.authorizationStatus}\");\n+\n+      if (settings.authorizationStatus == AuthorizationStatus.denied) {\n+        debugPrint(\"❌ Notification permissions denied\");\n+        return null;\n+      }\n+\n+      // 2. محاولة مباشرة للحصول على FCM token بدون انتظار APNS\n+      debugPrint(\n+        \"🚀 Attempting direct FCM token retrieval (bypass APNS dependency)...\",\n+      );\n+\n+      String? fcmToken;\n+      int directAttempts = 0;\n+      const maxDirectAttempts = 3;\n+\n+      while (fcmToken == null && directAttempts < maxDirectAttempts) {\n+        directAttempts++;\n+        debugPrint(\"🔄 Direct FCM attempt $directAttempts/$maxDirectAttempts\");\n+\n+        try {\n+          // محاولة مباشرة بدون انتظار APNS\n+          fcmToken = await _firebaseMessaging.getToken().timeout(\n+            Duration(seconds: 20 + (10 * directAttempts)),\n+            onTimeout: () => null,\n+          );\n+\n+          if (fcmToken != null && fcmToken.isNotEmpty) {\n+            debugPrint(\"✅ Direct FCM Token received successfully!\");\n+            debugPrint(\"🔑 Token preview: ${fcmToken.substring(0, 50)}...\");\n+            await _cacheFCMToken(fcmToken);\n+            return fcmToken;\n+          }\n+        } catch (e) {\n+          debugPrint(\"⚠️ Direct FCM attempt $directAttempts failed: $e\");\n+          // إذا لم تكن مشكلة APNS، تابع\n+          if (!e.toString().toLowerCase().contains('apns')) {\n+            await Future.delayed(Duration(seconds: directAttempts * 2));\n+            continue;\n+          }\n+        }\n+\n+        // إذا وصلنا هنا، فالمشكلة متعلقة بـ APNS\n+        break;\n+      }\n+\n+      // 3. إذا فشلت المحاولة المباشرة، جرب الطريقة التقليدية مع APNS\n+      if (fcmToken == null && Platform.isIOS) {\n+        debugPrint(\"🍎 Fallback to APNS-dependent approach...\");\n+\n+        // محاولة تسجيل للإشعارات من native code\n+        debugPrint(\"📲 Triggering native notification registration...\");\n+\n+        // انتظار إضافي للنظام\n+        await Future.delayed(const Duration(seconds: 5));\n+\n+        // محاولة APNS محدودة\n+        String? apnsToken;\n+        for (int attempt = 1; attempt <= 3; attempt++) {\n+          debugPrint(\"🔄 APNS attempt $attempt/3\");\n+\n+          try {\n+            await Future.delayed(Duration(seconds: attempt * 3));\n+            apnsToken = await _firebaseMessaging.getAPNSToken();\n+            if (apnsToken != null) {\n+              debugPrint(\n+                \"✅ APNS Token received: ${apnsToken.substring(0, 20)}...\",\n+              );\n+              break;\n+            }\n+          } catch (e) {\n+            debugPrint(\"⚠️ APNS attempt $attempt failed: $e\");\n+          }\n+        }\n+\n+        // 4. محاولة FCM مرة أخيرة\n+        if (apnsToken != null) {\n+          debugPrint(\"🔑 Final FCM token attempt with APNS...\");\n+\n+          try {\n+            fcmToken = await _firebaseMessaging.getToken().timeout(\n+              const Duration(seconds: 30),\n+              onTimeout: () => null,\n+            );\n+\n+            if (fcmToken != null && fcmToken.isNotEmpty) {\n+              debugPrint(\"✅ FCM Token received after APNS setup!\");\n+              await _cacheFCMToken(fcmToken);\n+              return fcmToken;\n+            }\n+          } catch (e) {\n+            debugPrint(\"⚠️ Final FCM attempt failed: $e\");\n+          }\n+        }\n+      }\n+\n+      // 5. محاولة استرداد من cache\n+      debugPrint(\"♻️ Trying cached token...\");\n+      String? cachedToken = await _getCachedFCMToken();\n+\n+      if (cachedToken != null) {\n+        debugPrint(\"✅ Using cached FCM token\");\n+        return cachedToken;\n+      }\n+\n+      // 6. إذا فشل كل شيء، إنشاء placeholder token للتطوير\n+      if (Platform.isIOS) {\n+        debugPrint(\"🛠️ Creating development placeholder token...\");\n+        String placeholderToken = await _createDevelopmentToken();\n+        if (placeholderToken.isNotEmpty) {\n+          debugPrint(\n+            \"🔧 Using development token: ${placeholderToken.substring(0, 30)}...\",\n+          );\n+          await _cacheFCMToken(placeholderToken);\n+          return placeholderToken;\n+        }\n+      }\n+\n+      debugPrint(\"❌ All FCM token retrieval methods failed\");\n+      return null;\n+    } catch (e) {\n+      debugPrint(\"🚨 Fatal error in FCM token retrieval: $e\");\n+      debugPrint(\"📊 Error details: ${e.toString()}\");\n+\n+      // محاولة أخيرة مع cached token\n+      String? cachedToken = await _getCachedFCMToken();\n+      if (cachedToken != null) {\n+        debugPrint(\"♻️ Emergency fallback to cached token\");\n+        return cachedToken;\n+      }\n+\n+      return null;\n+    }\n+  }\n+\n+  /// إنشاء token مؤقت للتطوير عندما يفشل APNS\n+  Future<String> _createDevelopmentToken() async {\n+    try {\n+      final User? currentUser = _auth.currentUser;\n+      final String deviceId =\n+          currentUser?.uid ?? DateTime.now().millisecondsSinceEpoch.toString();\n+      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();\n+\n+      // إنشاء token مؤقت فريد للجهاز\n+      String developmentToken = \"dev_token_ios_${deviceId}_$timestamp\";\n+\n+      debugPrint(\"🔧 Generated development token for testing\");\n+      return developmentToken;\n+    } catch (e) {\n+      debugPrint(\"⚠️ Failed to create development token: $e\");\n+      return \"\";\n+    }\n+  }\n+\n+  /// حفظ FCM token في التفضيلات المحلية\n+  Future<void> _cacheFCMToken(String token) async {\n+    try {\n+      final box = GetStorage();\n+      await box.write('cached_fcm_token', token);\n+      await box.write(\n+        'fcm_token_timestamp',\n+        DateTime.now().millisecondsSinceEpoch,\n+      );\n+      debugPrint(\"💾 FCM token cached successfully\");\n+    } catch (e) {\n+      debugPrint(\"⚠️ Failed to cache FCM token: $e\");\n+    }\n+  }\n+\n+  /// استرداد FCM token من التفضيلات المحلية\n+  Future<String?> _getCachedFCMToken() async {\n+    try {\n+      final box = GetStorage();\n+      String? cachedToken = box.read('cached_fcm_token');\n+      int? timestamp = box.read('fcm_token_timestamp');\n+\n+      if (cachedToken != null && timestamp != null) {\n+        // تحقق من عمر الـ token (صالح لمدة 7 أيام)\n+        DateTime tokenDate = DateTime.fromMillisecondsSinceEpoch(timestamp);\n+        Duration age = DateTime.now().difference(tokenDate);\n+\n+        if (age.inDays < 7) {\n+          debugPrint(\n+            \"♻️ Found valid cached FCM token (age: ${age.inHours} hours)\",\n+          );\n+          return cachedToken;\n+        } else {\n+          debugPrint(\n+            \"⏰ Cached FCM token is too old (${age.inDays} days), ignoring\",\n+          );\n+        }\n+      }\n+\n+      return null;\n+    } catch (e) {\n+      debugPrint(\"⚠️ Failed to retrieve cached FCM token: $e\");\n+      return null;\n+    }\n+  }\n+\n+  /// تحديث FCM Token في Firestore لاحقاً (يمكن استدعاؤها من مكان آخر)\n+  Future<void> updateFCMTokenInFirestore() async {\n+    try {\n+      final User? currentUser = _auth.currentUser;\n+      if (currentUser == null) {\n+        debugPrint(\"⚠️ No current user to update FCM token for\");\n+        return;\n+      }\n+\n+      debugPrint(\"🔄 Attempting to update FCM token in Firestore...\");\n+      final String? fcmToken = await _getFCMTokenSafely();\n+\n+      if (fcmToken != null && fcmToken.isNotEmpty) {\n+        await _firestore\n+            .collection(FirebaseX.collectionSeller)\n+            .doc(currentUser.uid)\n+            .update({\n+              'fcmToken': fcmToken,\n+              'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n+              'fcmTokenStatus': 'active',\n+            });\n+\n+        debugPrint(\"✅ FCM Token updated successfully in Firestore\");\n+        Get.snackbar(\n+          \"تم التحديث\",\n+          \"تم تحديث معرف الإشعارات بنجاح\",\n+          backgroundColor: Colors.green.shade400,\n+          colorText: Colors.white,\n+          snackPosition: SnackPosition.BOTTOM,\n+          duration: const Duration(seconds: 2),\n+        );\n+      } else {\n+        debugPrint(\"❌ Failed to get FCM token for update\");\n+      }\n+    } catch (e) {\n+      debugPrint(\"🚨 Error updating FCM token in Firestore: $e\");\n+    }\n+  }\n+\n+  /// دالة محسّنة للحصول على FCM token مع إعداد أفضل لـ iOS\n+  Future<String?> _getIOSOptimizedFCMToken() async {\n+    debugPrint(\"🍎 Starting iOS-optimized FCM token retrieval...\");\n+\n+    try {\n+      // 1. انتظار إضافي للتأكد من إعداد النظام\n+      await Future.delayed(const Duration(seconds: 5));\n+\n+      // 2. محاولة تسجيل للـ remote notifications يدوياً إذا لم يكن مسجلاً\n+      debugPrint(\"📱 Ensuring iOS remote notification registration...\");\n+\n+      // 3. طلب الأذونات مرة أخرى\n+      NotificationSettings settings = await _firebaseMessaging\n+          .requestPermission(\n+            alert: true,\n+            announcement: false,\n+            badge: true,\n+            carPlay: false,\n+            criticalAlert: false,\n+            provisional: false,\n+            sound: true,\n+          );\n+\n+      if (settings.authorizationStatus != AuthorizationStatus.authorized) {\n+        debugPrint(\n+          \"❌ iOS Notifications not authorized: ${settings.authorizationStatus}\",\n+        );\n+        return null;\n+      }\n+\n+      // 4. محاولة مختلفة للحصول على FCM token مع انتظار أطول\n+      for (int attempt = 1; attempt <= 3; attempt++) {\n+        debugPrint(\"🔑 iOS FCM token attempt $attempt/3\");\n+\n+        try {\n+          // انتظار متزايد مع كل محاولة\n+          await Future.delayed(Duration(seconds: 3 * attempt));\n+\n+          String? token = await _firebaseMessaging.getToken().timeout(\n+            Duration(seconds: 60 + (10 * attempt)), // انتظار أطول مع كل محاولة\n+          );\n+\n+          if (token != null && token.isNotEmpty) {\n+            debugPrint(\"✅ iOS FCM token received on attempt $attempt!\");\n+            return token;\n+          }\n+        } catch (e) {\n+          debugPrint(\"⚠️ iOS FCM attempt $attempt failed: $e\");\n+          if (e.toString().toLowerCase().contains('apns')) {\n+            // إذا كان خطأ APNS، انتظار أطول\n+            await Future.delayed(Duration(seconds: 5 * attempt));\n+          }\n+        }\n+      }\n+\n+      return null;\n+    } catch (e) {\n+      debugPrint(\"🚨 iOS FCM token retrieval failed: $e\");\n+      return null;\n+    }\n+  }\n+\n+  /// مساعد لإعادة المحاولة في الحصول على FCM token بعد التسجيل\n+  void retryFCMTokenLater() {\n+    // إعادة المحاولة بعد 30 ثانية للمحاولة الأولى\n+    Timer(const Duration(seconds: 30), () {\n+      debugPrint(\"🔄 Retrying FCM token retrieval after 30 seconds...\");\n+      updateFCMTokenInFirestore();\n+    });\n+\n+    // محاولة خاصة بـ iOS بعد دقيقة واحدة\n+    if (Platform.isIOS) {\n+      Timer(const Duration(minutes: 1), () async {\n+        debugPrint(\"🍎 iOS-specific FCM token retry after 1 minute...\");\n+        final token = await _getIOSOptimizedFCMToken();\n+        if (token != null) {\n+          try {\n+            final User? currentUser = _auth.currentUser;\n+            if (currentUser != null) {\n+              await _firestore\n+                  .collection(FirebaseX.collectionSeller)\n+                  .doc(currentUser.uid)\n+                  .update({\n+                    'fcmToken': token,\n+                    'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n+                    'fcmTokenStatus': 'active',\n+                  });\n+              debugPrint(\"✅ iOS FCM Token updated successfully in retry!\");\n+            }\n+          } catch (e) {\n+            debugPrint(\"❌ Failed to update iOS FCM token in retry: $e\");\n+          }\n+        }\n+      });\n+    }\n+\n+    // إعادة محاولة إضافية بعد دقيقتين إذا فشلت الأولى\n+    Timer(const Duration(minutes: 2), () {\n+      debugPrint(\"🔄 Second retry attempt for FCM token after 2 minutes...\");\n+      updateFCMTokenInFirestore();\n+    });\n+\n+    // محاولة أخيرة بعد 5 دقائق\n+    Timer(const Duration(minutes: 5), () {\n+      debugPrint(\"🔄 Final retry attempt for FCM token after 5 minutes...\");\n+      updateFCMTokenInFirestore();\n+    });\n+  }\n+}\n+\n+/// iOS-specific Firebase Storage handler to fix image upload issues\n+class IOSFirebaseStorageHandler {\n+  final FirebaseStorage _storage;\n+\n+  IOSFirebaseStorageHandler(this._storage);\n+\n+  Future<String?> uploadFile(File file, String path) async {\n+    try {\n+      debugPrint(\"🍎 iOS Storage Handler: Starting upload to: $path\");\n+\n+      // Wait longer for Firebase to be fully ready on iOS\n+      await Future.delayed(Duration(milliseconds: 5000));\n+\n+      // Verify Firebase is properly initialized\n+      if (Firebase.apps.isEmpty) {\n+        throw Exception(\"Firebase not initialized\");\n+      }\n+\n+      // Test Firebase Storage connection first\n+      try {\n+        _storage.ref().child(\n+          \"connection_test_${DateTime.now().millisecondsSinceEpoch}\",\n+        );\n+        debugPrint(\"🍎 Testing Firebase Storage connection...\");\n+        // Just create a reference, don't upload\n+        debugPrint(\"✅ Firebase Storage connection test passed\");\n+      } catch (e) {\n+        debugPrint(\"❌ Firebase Storage connection test failed: $e\");\n+        throw Exception(\"Firebase Storage not accessible: $e\");\n+      }\n+\n+      // Verify file exists and is readable\n+      if (!await file.exists()) {\n+        throw Exception(\"File does not exist at path: ${file.path}\");\n+      }\n+\n+      final fileSize = await file.length();\n+      debugPrint(\"🍎 iOS Storage Handler: File size: $fileSize bytes\");\n+\n+      if (fileSize == 0) {\n+        throw Exception(\"File is empty\");\n+      }\n+\n+      // Use simple path first - try without modifications\n+      debugPrint(\"🍎 iOS Storage Handler: Trying direct upload to: $path\");\n+\n+      final ref = _storage.ref().child(path);\n+\n+      // Set proper metadata for iOS\n+      final metadata = SettableMetadata(\n+        contentType: _getContentType(file.path),\n+        customMetadata: {\n+          'uploaded_by': 'ios_seller_registration',\n+          'original_path': path,\n+          'upload_timestamp': DateTime.now().millisecondsSinceEpoch.toString(),\n+        },\n+      );\n+\n+      debugPrint(\"🍎 iOS Storage Handler: Creating upload task...\");\n+      final uploadTask = ref.putFile(file, metadata);\n+\n+      // Monitor progress\n+      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n+        if (snapshot.totalBytes > 0) {\n+          final progress =\n+              snapshot.bytesTransferred / snapshot.totalBytes * 100;\n+          debugPrint(\"🍎 iOS Upload progress: ${progress.toStringAsFixed(1)}%\");\n+        }\n+      });\n+\n+      debugPrint(\"🍎 iOS Storage Handler: Waiting for upload completion...\");\n+      final snapshot = await uploadTask.whenComplete(() {});\n+\n+      debugPrint(\"🍎 iOS Storage Handler: Getting download URL...\");\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"✅ iOS Upload successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"❌ iOS Storage Handler error: $e\");\n+\n+      // Try alternative upload method for iOS\n+      return await _alternativeUploadMethod(file, path);\n+    }\n+  }\n+\n+  Future<String?> _alternativeUploadMethod(File file, String path) async {\n+    // Try multiple alternative approaches for iOS\n+\n+    // Method 1: putData instead of putFile\n+    try {\n+      debugPrint(\"🔄 iOS Alternative Method 1: Using putData...\");\n+      await Future.delayed(Duration(milliseconds: 3000));\n+\n+      final bytes = await file.readAsBytes();\n+      debugPrint(\"🔄 iOS Read ${bytes.length} bytes from file\");\n+\n+      final ref = _storage.ref().child(path);\n+      final uploadTask = ref.putData(\n+        bytes,\n+        SettableMetadata(\n+          contentType: _getContentType(file.path),\n+          customMetadata: {\n+            'uploaded_by': 'ios_alternative_putdata',\n+            'original_path': path,\n+          },\n+        ),\n+      );\n+\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"✅ iOS Alternative Method 1 successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"❌ iOS Alternative Method 1 failed: $e\");\n+    }\n+\n+    // Method 2: Different path structure\n+    try {\n+      debugPrint(\"🔄 iOS Alternative Method 2: Different path structure...\");\n+      await Future.delayed(Duration(milliseconds: 3000));\n+\n+      final timestamp = DateTime.now().millisecondsSinceEpoch;\n+      final altPath = \"mobile_uploads/${path.replaceAll('/', '_')}_$timestamp\";\n+\n+      debugPrint(\"🔄 iOS Alternative path: $altPath\");\n+\n+      final bytes = await file.readAsBytes();\n+      final ref = _storage.ref().child(altPath);\n+\n+      final uploadTask = ref.putData(\n+        bytes,\n+        SettableMetadata(\n+          contentType: _getContentType(file.path),\n+          customMetadata: {\n+            'uploaded_by': 'ios_alternative_path',\n+            'original_path': path,\n+          },\n+        ),\n+      );\n+\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"✅ iOS Alternative Method 2 successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"❌ iOS Alternative Method 2 failed: $e\");\n+    }\n+\n+    // Method 3: Very simple path\n+    try {\n+      debugPrint(\"🔄 iOS Alternative Method 3: Simple upload...\");\n+      await Future.delayed(Duration(milliseconds: 5000));\n+\n+      final simplePath = \"uploads/${DateTime.now().millisecondsSinceEpoch}\";\n+      debugPrint(\"🔄 iOS Simple path: $simplePath\");\n+\n+      final bytes = await file.readAsBytes();\n+      final ref = _storage.ref().child(simplePath);\n+\n+      final uploadTask = ref.putData(bytes);\n+      final snapshot = await uploadTask.whenComplete(() {});\n+      final downloadUrl = await snapshot.ref.getDownloadURL();\n+\n+      debugPrint(\"✅ iOS Alternative Method 3 successful: $downloadUrl\");\n+      return downloadUrl;\n+    } catch (e) {\n+      debugPrint(\"❌ iOS Alternative Method 3 failed: $e\");\n+    }\n+\n+    debugPrint(\"❌ All iOS alternative upload methods failed\");\n+    return null;\n+  }\n+\n+  String _getContentType(String filePath) {\n+    final extension = filePath.toLowerCase().split('.').last;\n+    switch (extension) {\n+      case 'jpg':\n+      case 'jpeg':\n+        return 'image/jpeg';\n+      case 'png':\n+        return 'image/png';\n+      case 'gif':\n+        return 'image/gif';\n+      case 'webp':\n+        return 'image/webp';\n+      default:\n+        return 'image/jpeg'; // Default fallback\n+    }\n+  }\n+}\n"
                },
                {
                    "date": 1752570376950,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -815,10 +815,12 @@\n               0,\n             ), // تم التأكد من أن location هو GeoPoint في _tempSellerDataForSubmission\n         shopAddressText:\n             _tempSellerDataForSubmission?['shopAddressText'] as String?,\n-        shopCategory:\n-            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'أخرى',\n+        shopCategories:\n+            (_tempSellerDataForSubmission?['shopCategories'] as List<dynamic>?)\n+                ?.cast<String>() ??\n+            ['أخرى'],\n         workingHours: Map<String, dynamic>.from(\n           _tempSellerDataForSubmission?['workingHours'] ?? {},\n         ),\n         // الحقول التالية اختيارية في SellerModel وسيتم تعيينها إلى null إذا لم تكن موجودة في _tempSellerDataForSubmission\n@@ -2045,2052 +2047,4 @@\n         return 'image/jpeg'; // Default fallback\n     }\n   }\n }\n-import 'dart:io';\n-import 'dart:async';\n-import 'package:cloud_firestore/cloud_firestore.dart';\n-import 'package:codora/%D8%A7%D9%84%D9%83%D9%88%D8%AF%20%D8%A7%D9%84%D8%AE%D8%A7%D8%B5%20%D8%A8%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%20%D8%A7%D9%84%D8%A8%D8%A7%D8%A6%D8%B9/seller_app_auth/controllers/seller_auth_controller.dart';\n-import 'package:firebase_auth/firebase_auth.dart';\n-import 'package:firebase_storage/firebase_storage.dart';\n-import 'package:firebase_messaging/firebase_messaging.dart';\n-import 'package:firebase_core/firebase_core.dart';\n-import 'package:flutter/material.dart';\n-import 'package:geolocator/geolocator.dart';\n-import 'package:get/get.dart';\n-import 'package:get_storage/get_storage.dart';\n-import 'package:google_maps_flutter/google_maps_flutter.dart';\n-import 'package:image_picker/image_picker.dart';\n-import 'package:intl/intl.dart'; // For DateFormat\n-import 'package:geocoding/geocoding.dart' as geo;\n-\n-import '../../../XXX/xxx_firebase.dart';\n-import '../../../Model/SellerModel.dart';\n-import '../../ui/seller_main_screen.dart';\n-import '../ui/OtpVerificationScreen.dart';\n-import '../ui/LocationPickerScreen.dart';\n-\n-class SellerRegistrationController extends GetxController {\n-  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n-  RxDouble currentPositionAccuracy = 0.0.obs;\n-\n-  // --- Firebase Instances ---\n-  final FirebaseAuth _auth = FirebaseAuth.instance;\n-  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n-  final FirebaseStorage _storage = FirebaseStorage.instance;\n-  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n-  final RxString verificationId = ''.obs; // To store Firebase's verification ID\n-\n-  // iOS-specific Firebase Storage handler\n-  late IOSFirebaseStorageHandler _iosStorageHandler;\n-\n-  // ==========================================================================\n-  // ==========================================================================\n-  // ==========================================================================\n-\n-  // لإضافة نوع البائع\n-  String? _sellerTypeFromAuth; // سيتم جلب هذا من SellerAuthController\n-\n-  final Rxn<int> resendToken = Rxn<int>(null); // For resending OTP\n-  final TextEditingController otpController = TextEditingController();\n-  final RxBool isOtpSending = false.obs; // Loading state for OTP sending\n-  final RxBool isOtpVerifying = false.obs; // Loading state for OTP verification\n-  Map<String, dynamic>? _tempSellerDataForSubmission;\n-  File? _tempSellerProfileImageFile;\n-  File? _tempShopFrontImageFile;\n-\n-  // --- Text Editing Controllers ---\n-  final TextEditingController sellerNameController = TextEditingController();\n-  final TextEditingController shopNameController = TextEditingController();\n-  final TextEditingController shopPhoneNumberController =\n-      TextEditingController();\n-  final TextEditingController shopDescriptionController =\n-      TextEditingController();\n-  // Add more controllers for other text fields like commercial reg no., etc.\n-\n-  // --- Image Pickers ---\n-  final ImagePicker _picker = ImagePicker();\n-  final Rxn<File> sellerProfileImageFile = Rxn<File>(null);\n-  final Rxn<File> shopFrontImageFile = Rxn<File>(null);\n-\n-  // --- Location ---\n-  final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n-  final RxString shopAddressText = ''.obs;\n-  GoogleMapController? mapController;\n-\n-  // --- Working Hours ---\n-  final List<String> dayKeys = [\n-    \"sunday_en\",\n-    \"monday_en\",\n-    \"tuesday_en\",\n-    \"wednesday_en\",\n-    \"thursday_en\",\n-    \"friday_en\",\n-    \"saturday_en\",\n-  ];\n-  final RxnString expandedDayPanel = RxnString(null); // For ExpansionPanelList\n-\n-  final RxMap<String, Map<String, dynamic>> workingHours =\n-      <String, Map<String, dynamic>>{\n-        \"sunday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"الأحد\",\n-        },\n-        \"monday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"الاثنين\",\n-        },\n-        \"tuesday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"الثلاثاء\",\n-        },\n-        \"wednesday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"الأربعاء\",\n-        },\n-        \"thursday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"الخميس\",\n-        },\n-        \"friday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"الجمعة\",\n-        },\n-        \"saturday_en\": {\n-          'isOpen': false,\n-          'opensAt': null,\n-          'closesAt': null,\n-          'name_ar': \"السبت\",\n-        },\n-      }.obs;\n-  final RxnString _lastAppliedOpensAt = RxnString(null);\n-  final RxnString _lastAppliedClosesAt = RxnString(null);\n-  // --- Main Categories ---\n-  // قائمة شاملة بجميع فئات المتاجر الممكنة\n-  final List<String> shopCategories = [\n-    \"إلكترونيات ومعدات تقنية\",\n-    \"ملابس وأزياء\",\n-    \"أحذية وحقائب\",\n-    \"طعام ومشروبات\",\n-    \"منتجات صحية وتجميل\",\n-    \"أدوية ومستلزمات طبية\",\n-    \"كتب ومواد تعليمية\",\n-    \"ألعاب وترفيه\",\n-    \"رياضة ولياقة\",\n-    \"أدوات منزلية ومطبخ\",\n-    \"أثاث وديكور\",\n-    \"حدائق ونباتات\",\n-    \"سيارات وقطع غيار\",\n-    \"أدوات وعدد يدوية\",\n-    \"مواد بناء وتشييد\",\n-    \"مجوهرات وساعات\",\n-    \"هدايا وتحف\",\n-    \"أطفال ومواليد\",\n-    \"حيوانات أليفة ومستلزمات\",\n-    \"موسيقى وآلات موسيقية\",\n-    \"خدمات مهنية\",\n-    \"خدمات تقنية\",\n-    \"خدمات توصيل\",\n-    \"خدمات تنظيف\",\n-    \"خدمات صيانة\",\n-    \"مواد غذائية عضوية\",\n-    \"حرف يدوية وفنون\",\n-    \"أقمشة وخياطة\",\n-    \"عطور ومواد تجميل\",\n-    \"أخرى\",\n-  ];\n-\n-  // الفئات المختارة (حد أقصى 6 فئات)\n-  final RxList<String> selectedShopCategories = <String>[].obs;\n-  final int maxCategoriesAllowed = 6;\n-\n-  // --- Loading State ---\n-  final RxBool isLoading = false.obs;\n-\n-  @override\n-  void onInit() {\n-    super.onInit();\n-\n-    // Initialize iOS-specific storage handler\n-    if (Platform.isIOS) {\n-      _iosStorageHandler = IOSFirebaseStorageHandler(_storage);\n-    }\n-\n-    // جلب SellerAuthController والحصول على sellerType\n-    try {\n-      final SellerAuthController authController =\n-          Get.find<SellerAuthController>();\n-      _sellerTypeFromAuth = authController.sellerType;\n-      if (_sellerTypeFromAuth != null) {\n-        debugPrint(\n-          \"SellerRegistrationController: تم جلب نوع البائع من AuthController: $_sellerTypeFromAuth\",\n-        );\n-      } else {\n-        debugPrint(\n-          \"SellerRegistrationController: لم يتم العثور على sellerType في AuthController. قد يحتاج المستخدم للعودة واختيار النوع.\",\n-        );\n-        // يمكنك هنا إضافة منطق لتوجيه المستخدم إذا كان sellerType ضروريًا ولا يمكن أن يكون null\n-        // مثال: Get.offAll(() => SellerTypeSelectionScreen()); أو عرض رسالة خطأ\n-      }\n-    } catch (e) {\n-      debugPrint(\n-        \"SellerRegistrationController: خطأ أثناء محاولة العثور على SellerAuthController أو الوصول إلى sellerType: $e\",\n-      );\n-      // معالجة الخطأ، ربما توجيه المستخدم أو عرض رسالة\n-    }\n-  }\n-\n-  @override\n-  void onClose() {\n-    sellerNameController.dispose();\n-    shopNameController.dispose();\n-    shopPhoneNumberController.dispose();\n-    shopDescriptionController.dispose();\n-    mapController?.dispose();\n-    otpController.dispose();\n-    super.onClose();\n-  }\n-\n-  void removeImage({required bool isProfileImage}) {\n-    if (isProfileImage) {\n-      sellerProfileImageFile.value = null;\n-    } else {\n-      shopFrontImageFile.value = null;\n-    }\n-    update(); // For GetBuilder if used, or just rely on Obx for reactive updates\n-  }\n-\n-  Future<void> initiatePhoneVerificationAndCollectData() async {\n-    debugPrint(\"🚀 initiatePhoneVerificationAndCollectData called\");\n-    debugPrint(\"Form validation starting...\");\n-\n-    if (!formKey.currentState!.validate()) {\n-      debugPrint(\"❌ Form validation failed\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى ملء جميع الحقول المطلوبة بشكل صحيح.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"✅ Form validation passed\");\n-\n-    // --- Add all your previous validations ---\n-    debugPrint(\"Checking profile image...\");\n-    if (sellerProfileImageFile.value == null) {\n-      debugPrint(\"❌ No profile image selected\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى اختيار صورة شخصية.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"✅ Profile image validation passed\");\n-\n-    debugPrint(\"Checking shop front image...\");\n-    if (shopFrontImageFile.value == null) {\n-      debugPrint(\"❌ No shop front image selected\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى اختيار صورة لواجهة المحل.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"✅ Shop front image validation passed\");\n-\n-    debugPrint(\"Checking shop location...\");\n-    if (shopLocation.value == null) {\n-      debugPrint(\"❌ No shop location selected\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى تحديد موقع المحل.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"✅ Shop location validation passed\");\n-\n-    debugPrint(\"Checking shop category...\");\n-    if (selectedShopCategories.isEmpty) {\n-      debugPrint(\"❌ No shop categories selected\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى اختيار فئة واحدة على الأقل للمتجر.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\n-      \"✅ Shop categories validation passed: ${selectedShopCategories.length} categories selected\",\n-    );\n-\n-    // التحقق إذا كان _sellerTypeFromAuth فارغًا قبل المتابعة (إذا كان إلزاميًا)\n-    debugPrint(\"Checking seller type...\");\n-    if (_sellerTypeFromAuth == null || _sellerTypeFromAuth!.isEmpty) {\n-      debugPrint(\"❌ No seller type selected\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"لم يتم تحديد نوع البائع. يرجى الرجوع واختيار نوع البائع.\",\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"✅ Seller type validation passed: $_sellerTypeFromAuth\");\n-\n-    debugPrint(\"Checking working hours...\");\n-    bool workingHoursValid = true;\n-    String firstInvalidDay = \"\";\n-    workingHours.forEach((key, value) {\n-      if ((value['isOpen'] == true) &&\n-          (value['opensAt'] == null || value['closesAt'] == null)) {\n-        workingHoursValid = false;\n-        firstInvalidDay = value['name_ar'] as String;\n-        return;\n-      }\n-    });\n-    if (!workingHoursValid) {\n-      debugPrint(\"❌ Working hours validation failed for day: $firstInvalidDay\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى تحديد أوقات الفتح والإغلاق لليوم المفتوح: $firstInvalidDay.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"✅ Working hours validation passed\");\n-\n-    String rawPhoneNumber = shopPhoneNumberController.text.trim();\n-    rawPhoneNumber = rawPhoneNumber.replaceAll(RegExp(r'\\s+'), '');\n-    if (rawPhoneNumber.startsWith('0')) {\n-      rawPhoneNumber = rawPhoneNumber.substring(1);\n-    }\n-    const String countryCode = \"+964\";\n-    final String formattedPhoneNumber = \"$countryCode$rawPhoneNumber\";\n-    debugPrint(\"الرقم المدخل الأصلي: ${shopPhoneNumberController.text}\");\n-    debugPrint(\n-      \"الرقم بعد إزالة المسافات والصفر وإضافة رمز الدولة: $formattedPhoneNumber\",\n-    );\n-\n-    final RegExp iraqiPhoneNumberRegExp = RegExp(r'^\\+9647[3-9]\\d{8}$');\n-    debugPrint(\"Checking phone number validation: $formattedPhoneNumber\");\n-    if (!iraqiPhoneNumberRegExp.hasMatch(formattedPhoneNumber)) {\n-      debugPrint(\"Phone number validation failed for: $formattedPhoneNumber\");\n-      Get.snackbar(\n-        \"رقم هاتف غير صالح\",\n-        \"الرجاء التأكد من إدخال رقم هاتف عراقي صحيح.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-    debugPrint(\"Phone number validation passed\");\n-\n-    // ---- Set loading states ----\n-    debugPrint(\"Setting loading states...\");\n-    isOtpSending.value = true;\n-    isLoading.value = true;\n-    update();\n-    debugPrint(\"Loading states set successfully\");\n-\n-    try {\n-      debugPrint(\"Preparing temp data for submission...\");\n-      _tempSellerProfileImageFile = sellerProfileImageFile.value;\n-      _tempShopFrontImageFile = shopFrontImageFile.value;\n-      _tempSellerDataForSubmission = {\n-        \"sellerName\": sellerNameController.text.trim(),\n-        \"shopName\": shopNameController.text.trim(),\n-        \"shopPhoneNumber\": shopPhoneNumberController.text.trim(),\n-        \"shopDescription\": shopDescriptionController.text.trim(),\n-        \"location\": GeoPoint(\n-          shopLocation.value!.latitude,\n-          shopLocation.value!.longitude,\n-        ),\n-        \"shopAddressText\": shopAddressText.value,\n-        \"shopCategories\": selectedShopCategories.toList(),\n-        \"workingHours\": Map<String, Map<String, dynamic>>.from(workingHours),\n-        \"streetAddress\": streetAddressController.text.trim(),\n-      };\n-      debugPrint(\"Temp data prepared successfully\");\n-\n-      debugPrint(\n-        \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n-      );\n-      debugPrint(\"FirebaseAuth instance: $_auth\");\n-\n-      // تفعيل reCAPTCHA للـ iOS صراحة\n-      if (Platform.isIOS) {\n-        debugPrint(\"Setting up reCAPTCHA for iOS...\");\n-        try {\n-          // إعدادات مختلفة للاختبار\n-          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n-\n-          await _auth.setSettings(\n-            appVerificationDisabledForTesting:\n-                isTestNumber, // للرقم التجريبي فقط\n-            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA للأرقام الحقيقية فقط\n-          );\n-\n-          debugPrint(\"✅ Firebase Auth settings configured for iOS\");\n-          debugPrint(\"📱 Test number mode: $isTestNumber\");\n-\n-          // إضافة تأخير قصير للسماح للإعدادات بالتطبيق\n-          await Future.delayed(const Duration(milliseconds: 500));\n-        } catch (e) {\n-          debugPrint(\"⚠️ Error setting Firebase Auth settings: $e\");\n-          // في حالة فشل إعدادات reCAPTCHA، جرب بدونها\n-          debugPrint(\"🔄 Trying without forced reCAPTCHA...\");\n-        }\n-      }\n-\n-      // إضافة timeout إضافي للتأكد من عمل الـ callbacks\n-      Timer callbackTimeoutTimer = Timer(const Duration(seconds: 30), () {\n-        if (isOtpSending.value || isLoading.value) {\n-          debugPrint(\"⚠️ Callback timeout - reCAPTCHA may not have appeared\");\n-          debugPrint(\"⚠️ This usually means Firebase Console settings issue\");\n-          isOtpSending.value = false;\n-          isLoading.value = false;\n-          isOtpVerifying.value = false;\n-          update();\n-          Get.snackbar(\n-            \"مشكلة في التحقق\",\n-            \"لم تظهر صفحة التحقق. تحقق من إعدادات Firebase أو جرب رقماً آخر.\",\n-            backgroundColor: Colors.orange.shade400,\n-            colorText: Colors.white,\n-            snackPosition: SnackPosition.BOTTOM,\n-            duration: const Duration(seconds: 5),\n-          );\n-        }\n-      });\n-\n-      await _auth.verifyPhoneNumber(\n-        phoneNumber: formattedPhoneNumber,\n-        forceResendingToken: resendToken.value,\n-        verificationCompleted: (PhoneAuthCredential credential) async {\n-          debugPrint(\"🎉 VERIFICATION COMPLETED CALLBACK TRIGGERED\");\n-          debugPrint(\n-            \"Phone auto-verified. Credential SMS code (if available): ${credential.smsCode}\",\n-          );\n-\n-          // إلغاء timeout timer\n-          callbackTimeoutTimer.cancel();\n-\n-          // التأكد من تحديث الحالة قبل المتابعة\n-          isOtpSending.value = false;\n-          isLoading.value = true;\n-          isOtpVerifying.value = true;\n-          update();\n-\n-          // إضافة تأخير قصير للسماح للـ UI بالتحديث على iOS\n-          if (Platform.isIOS) {\n-            await Future.delayed(const Duration(milliseconds: 100));\n-          }\n-\n-          await _finalizeSellerRegistration(isAutoVerified: true);\n-        },\n-        verificationFailed: (FirebaseAuthException e) {\n-          debugPrint(\"❌ VERIFICATION FAILED CALLBACK TRIGGERED\");\n-          debugPrint(\"Phone verification failed: ${e.code} - ${e.message}\");\n-          debugPrint(\"Full error: ${e.toString()}\");\n-\n-          // إلغاء timeout timer\n-          callbackTimeoutTimer.cancel();\n-\n-          // التأكد من إعادة تعيين جميع الحالات\n-          isOtpSending.value = false;\n-          isLoading.value = false;\n-          isOtpVerifying.value = false;\n-          update();\n-\n-          String errorMessage = \"فشل التحقق من رقم الهاتف.\";\n-          if (e.code == 'invalid-phone-number') {\n-            errorMessage =\n-                \"رقم الهاتف $formattedPhoneNumber الذي أدخلته غير صالح.\";\n-          } else if (e.code == 'too-many-requests') {\n-            errorMessage =\n-                \"تم إرسال عدد كبير جدا من الطلبات. حاول مرة أخرى لاحقًا.\";\n-          } else if (e.code == 'network-request-failed') {\n-            errorMessage =\n-                \"مشكلة في الاتصال بالإنترنت. يرجى التحقق من الاتصال والمحاولة مرة أخرى.\";\n-          }\n-          Get.snackbar(\n-            \"خطأ\",\n-            errorMessage,\n-            backgroundColor: Colors.red.shade400,\n-            colorText: Colors.white,\n-            snackPosition: SnackPosition.BOTTOM,\n-          );\n-        },\n-        codeSent: (String verId, int? resendTok) async {\n-          debugPrint(\"📱 CODE SENT CALLBACK TRIGGERED\");\n-          debugPrint(\n-            \"OTP code sent. Verification ID: $verId, Resend Token: $resendTok\",\n-          );\n-\n-          // إلغاء timeout timer\n-          callbackTimeoutTimer.cancel();\n-\n-          isOtpSending.value = false; // OTP sending part is done\n-          // isLoading remains true as we are waiting for OTP input\n-          update();\n-\n-          verificationId.value = verId;\n-          resendToken.value = resendTok;\n-\n-          // إضافة تأخير قصير على iOS للسماح للـ UI بالتحديث قبل التنقل\n-          if (Platform.isIOS) {\n-            await Future.delayed(const Duration(milliseconds: 200));\n-          }\n-\n-          // التأكد من أن التنقل يحدث على الـ main thread\n-          WidgetsBinding.instance.addPostFrameCallback((_) {\n-            debugPrint(\"Navigating to OTP verification screen...\");\n-            Get.to(() => OtpVerificationScreen());\n-          });\n-        },\n-        codeAutoRetrievalTimeout: (String verId) {\n-          debugPrint(\"⏰ CODE AUTO RETRIEVAL TIMEOUT CALLBACK TRIGGERED\");\n-          debugPrint(\"OTP auto-retrieval timed out. Verification ID: $verId\");\n-          verificationId.value = verId;\n-          // إعادة تعيين isOtpSending في حال timeout على iOS\n-          if (Platform.isIOS) {\n-            isOtpSending.value = false;\n-            update();\n-          }\n-        },\n-        timeout:\n-            Platform.isIOS\n-                ? const Duration(seconds: 60) // مدة أقصر على iOS\n-                : const Duration(seconds: 120), // مدة أطول على Android\n-      );\n-      debugPrint(\"✅ verifyPhoneNumber call completed successfully\");\n-    } catch (e) {\n-      debugPrint(\"🚨 EXCEPTION CAUGHT IN verifyPhoneNumber\");\n-      debugPrint(\"Exception type: ${e.runtimeType}\");\n-      debugPrint(\"Exception details: $e\");\n-\n-      // التأكد من إعادة تعيين جميع الحالات في حالة الخطأ\n-      isOtpSending.value = false;\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      update();\n-\n-      String errorMessage = \"حدث خطأ غير متوقع أثناء بدء التحقق من الهاتف.\";\n-\n-      // معالجة أخطاء محددة\n-      if (e.toString().contains('network')) {\n-        errorMessage = \"مشكلة في الشبكة. يرجى التحقق من الاتصال بالإنترنت.\";\n-      } else if (e.toString().contains('too-many-requests')) {\n-        errorMessage = \"تم إرسال عدد كبير من الطلبات. يرجى المحاولة لاحقاً.\";\n-      }\n-\n-      Get.snackbar(\n-        \"خطأ\",\n-        errorMessage,\n-        backgroundColor: Colors.red.shade500,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<void> verifyOtpAndFinalize(String otpCode) async {\n-    if (otpCode.isEmpty || otpCode.length < 6) {\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"يرجى إدخال رمز OTP الصحيح المكون من 6 أرقام.\",\n-        backgroundColor: Colors.orange.shade300,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      return;\n-    }\n-\n-    isOtpVerifying.value = true;\n-    isLoading.value =\n-        true; // isLoading should ideally be true from the previous step\n-    update();\n-\n-    try {\n-      PhoneAuthCredential credential = PhoneAuthProvider.credential(\n-        verificationId: verificationId.value,\n-        smsCode: otpCode,\n-      );\n-\n-      // **** خطوة التحقق الفعلية من الـ Credential هنا ****\n-      final User? currentUser = _auth.currentUser;\n-      if (currentUser == null) {\n-        throw FirebaseAuthException(\n-          code: 'no-current-user',\n-          message: 'No user is currently signed in.',\n-        );\n-      }\n-\n-      // محاولة ربط الـ Credential أو التحقق من OTP\n-      try {\n-        await currentUser.linkWithCredential(credential);\n-        debugPrint(\"Phone credential linked successfully.\");\n-      } catch (linkError) {\n-        if (linkError is FirebaseAuthException &&\n-            linkError.code == 'provider-already-linked') {\n-          debugPrint(\n-            \"Phone provider already linked, verifying OTP directly...\",\n-          );\n-          // إذا كان المزود مرتبط بالفعل، نتحقق من صحة OTP فقط\n-          await _auth.signInWithCredential(credential);\n-          debugPrint(\n-            \"OTP verified successfully with existing linked provider.\",\n-          );\n-        } else {\n-          rethrow; // إعادة طرح أي خطأ آخر\n-        }\n-      }\n-\n-      // إلغاء safety timeout لأن العملية نجحت\n-      _cancelSafetyTimeout();\n-\n-      // إذا نجح الربط أو التحقق، قم بإنهاء التسجيل\n-      await _finalizeSellerRegistration(isOtpNowVerified: true);\n-    } on FirebaseAuthException catch (e) {\n-      isOtpVerifying.value = false;\n-      isLoading.value = false;\n-      update();\n-      debugPrint(\n-        \"FirebaseAuthException during OTP verification: ${e.code} - ${e.message}\",\n-      );\n-      String errorMessage = \"فشل التحقق من رمز OTP.\";\n-      if (e.code == 'invalid-verification-code' ||\n-          e.code == 'invalid-credential') {\n-        errorMessage = \"رمز OTP الذي أدخلته غير صحيح.\";\n-      } else if (e.code == 'session-expired') {\n-        errorMessage = \"انتهت صلاحية جلسة التحقق. يرجى طلب رمز جديد.\";\n-      } else if (e.code == 'credential-already-in-use') {\n-        // هذه حالة خاصة: الرقم مرتبط بالفعل بحساب آخر. أو إذا كان مرتبطًا بنفس الحساب، يمكن اعتبارها نجاحًا.\n-        // هنا، نفترض أننا إذا وصلنا لهذه النقطة، والرقم مرتبط بنفس المستخدم، فهذا جيد.\n-        // ولكن إذا كان مرتبطًا بمستخدم مختلف، فهذه مشكلة.\n-        // للحفاظ على البساطة، سنعتبرها خطأ عام الآن، ولكن يمكن تحسين هذا.\n-        // أو إذا كان هذا يعني أنه مرتبط بالفعل بهذا المستخدم، يمكن المتابعة.\n-        // الخيار الأبسط هو معالجته كخطأ إذا لم تكن متأكدًا من كيفية التعامل مع هذا الحساب.\n-        // إذا كان يمكن أن يكون مرتبطًا بالفعل بهذا المستخدم، يمكن استدعاء _finalizeSellerRegistration هنا أيضًا.\n-        // For now, treat as a specific error message or proceed if logic allows\n-        debugPrint(\n-          \"Credential already in use. Assuming for this user is okay or needs specific handling.\",\n-        );\n-        // إذا كان الرقم مرتبطًا بالفعل بنفس المستخدم، قد يكون هذا هو المسار الصحيح\n-        // await _finalizeSellerRegistration(isOtpNowVerified: true);\n-        // Get.snackbar(\"معلومة\", \"رقم الهاتف هذا تم التحقق منه بالفعل لهذا الحساب.\", snackPosition: SnackPosition.BOTTOM);\n-        // return;\n-        errorMessage =\n-            \"رقم الهاتف هذا مرتبط بالفعل. إذا كان هذا حسابك، يمكنك المتابعة أو الاتصال بالدعم.\";\n-      } else if (e.code == 'no-current-user') {\n-        errorMessage =\n-            \"انتهت جلسة المستخدم. يرجى تسجيل الدخول مرة أخرى والمحاولة.\";\n-        // يمكنك هنا توجيه المستخدم لصفحة الدخول\n-      }\n-      Get.snackbar(\n-        \"خطأ\",\n-        errorMessage,\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    } catch (e) {\n-      isOtpVerifying.value = false;\n-      isLoading.value = false;\n-      update();\n-      debugPrint(\"Generic error verifying OTP: $e\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"حدث خطأ غير متوقع أثناء التحقق من الرمز.\",\n-        backgroundColor: Colors.red.shade500,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<void> _finalizeSellerRegistration({\n-    bool isAutoVerified = false,\n-    bool isOtpNowVerified = false,\n-  }) async {\n-    debugPrint(\"🔧 _finalizeSellerRegistration called\");\n-    debugPrint(\n-      \"🔧 isAutoVerified: $isAutoVerified, isOtpNowVerified: $isOtpNowVerified\",\n-    );\n-\n-    // إذا لم يتم التحقق تلقائيًا ولم يتم التحقق الآن (من verifyOtpAndFinalize)، فلا تتابع\n-    if (!isAutoVerified && !isOtpNowVerified) {\n-      debugPrint(\"❌ Neither auto verified nor OTP verified - stopping\");\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"لم يتم التحقق من صحة رقم الهاتف.\",\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      return;\n-    }\n-\n-    debugPrint(\n-      \"✅ Phone verification confirmed, proceeding with registration...\",\n-    );\n-\n-    // Set loading states for this final part\n-    isOtpVerifying.value = true;\n-    isLoading.value = true;\n-    update();\n-\n-    try {\n-      final User? currentUser = _auth.currentUser;\n-      if (currentUser == null) {\n-        Get.snackbar(\n-          \"خطأ\",\n-          \"لم يتم العثور على مستخدم حالي. يرجى تسجيل الدخول مرة أخرى.\",\n-          backgroundColor: Colors.red.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-        );\n-        isLoading.value = false;\n-        isOtpVerifying.value = false;\n-        // Navigate to login or welcome screen\n-        return;\n-      }\n-\n-      String? sellerProfileImageUrl;\n-      String? shopFrontImageUrl;\n-\n-      // iOS-specific: Wait for Firebase to be fully ready\n-      if (Platform.isIOS) {\n-        debugPrint(\n-          \"🔧 iOS detected - waiting for Firebase Storage to be ready...\",\n-        );\n-        await Future.delayed(Duration(milliseconds: 3000));\n-\n-        // Verify Firebase Storage is accessible\n-        try {\n-          _storage.ref().child('test_connection');\n-          debugPrint(\"✅ Firebase Storage connection test passed\");\n-        } catch (e) {\n-          debugPrint(\"⚠️ Firebase Storage connection test failed: $e\");\n-        }\n-      }\n-\n-      if (_tempSellerProfileImageFile != null) {\n-        debugPrint(\"🖼️ Uploading seller profile image...\");\n-        if (Platform.isIOS) {\n-          sellerProfileImageUrl = await _iosStorageHandler.uploadFile(\n-            _tempSellerProfileImageFile!,\n-            'seller_profile_images/${currentUser.uid}',\n-          );\n-        } else {\n-          sellerProfileImageUrl = await _uploadFile(\n-            _tempSellerProfileImageFile!,\n-            'seller_profile_images/${currentUser.uid}',\n-          );\n-        }\n-      }\n-      if (_tempShopFrontImageFile != null) {\n-        debugPrint(\"🏪 Uploading shop front image...\");\n-        if (Platform.isIOS) {\n-          shopFrontImageUrl = await _iosStorageHandler.uploadFile(\n-            _tempShopFrontImageFile!,\n-            'shop_front_images/${currentUser.uid}',\n-          );\n-        } else {\n-          shopFrontImageUrl = await _uploadFile(\n-            _tempShopFrontImageFile!,\n-            'shop_front_images/${currentUser.uid}',\n-          );\n-        }\n-      }\n-\n-      if (_tempSellerProfileImageFile != null &&\n-          sellerProfileImageUrl == null) {\n-        throw Exception(\"Failed to upload seller profile image.\");\n-      }\n-      if (_tempShopFrontImageFile != null && shopFrontImageUrl == null) {\n-        throw Exception(\"Failed to upload shop front image.\");\n-      }\n-\n-      // الحصول على FCM Token بشكل احترافي\n-      final String? fcmToken = await _getFCMTokenSafely();\n-\n-      // استخدام SellerModel لإنشاء البيانات\n-      final SellerModel sellerToSave = SellerModel(\n-        uid: currentUser.uid,\n-        sellerName:\n-            _tempSellerDataForSubmission?['sellerName'] as String? ?? '',\n-        sellerProfileImageUrl: sellerProfileImageUrl,\n-        shopName: _tempSellerDataForSubmission?['shopName'] as String? ?? '',\n-        shopFrontImageUrl: shopFrontImageUrl,\n-        shopPhoneNumber:\n-            _tempSellerDataForSubmission?['shopPhoneNumber'] as String? ?? '',\n-        shopDescription:\n-            _tempSellerDataForSubmission?['shopDescription'] as String?,\n-        location:\n-            _tempSellerDataForSubmission?['location'] as GeoPoint? ??\n-            const GeoPoint(\n-              0,\n-              0,\n-            ), // تم التأكد من أن location هو GeoPoint في _tempSellerDataForSubmission\n-        shopAddressText:\n-            _tempSellerDataForSubmission?['shopAddressText'] as String?,\n-        shopCategory:\n-            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'أخرى',\n-        workingHours: Map<String, dynamic>.from(\n-          _tempSellerDataForSubmission?['workingHours'] ?? {},\n-        ),\n-        // الحقول التالية اختيارية في SellerModel وسيتم تعيينها إلى null إذا لم تكن موجودة في _tempSellerDataForSubmission\n-        commercialRegistrationNumber:\n-            _tempSellerDataForSubmission?['commercialRegistrationNumber']\n-                as String?,\n-        websiteUrl: _tempSellerDataForSubmission?['websiteUrl'] as String?,\n-        socialMediaLinks:\n-            _tempSellerDataForSubmission?['socialMediaLinks']\n-                as Map<String, String>?,\n-\n-        isProfileComplete: true, // تم إكمال الملف الشخصي في هذه المرحلة\n-        isApprovedByAdmin: false, // يحتاج موافقة المشرف بشكل افتراضي\n-        isActiveBySeller: true, // نشط مبدئيًا\n-        isPhoneNumberVerified: true, // تم التحقق من الهاتف في هذه المرحلة\n-        averageRating: 0.0,\n-        numberOfRatings: 0,\n-        sellerType: _sellerTypeFromAuth, // من SellerAuthController\n-        registrationCompleted: true, // اكتمل التسجيل في هذه المرحلة\n-        createdAt:\n-            Timestamp.now(), // سيتم استبداله بـ FieldValue.serverTimestamp() أدناه\n-        updatedAt:\n-            null, // SellerModel.toMap() سيعين FieldValue.serverTimestamp() لهذا\n-      );\n-\n-      Map<String, dynamic> sellerDataToSave = sellerToSave.toMap();\n-\n-      // التأكد من استخدام الطوابع الزمنية للخادم وإضافة الحقول غير الموجودة في SellerModel\n-      sellerDataToSave['createdAt'] = FieldValue.serverTimestamp();\n-      sellerDataToSave['updatedAt'] =\n-          FieldValue.serverTimestamp(); // للتأكيد أو إذا كان SellerModel.toMap لا يفعل ذلك\n-\n-      // إضافة الحقول التي ليست جزءًا من SellerModel ولكنها مطلوبة في Firestore\n-      sellerDataToSave['email'] = currentUser.email;\n-\n-      // معالجة احترافية لحفظ FCM Token\n-      if (fcmToken != null && fcmToken.isNotEmpty) {\n-        sellerDataToSave['fcmToken'] = fcmToken;\n-        sellerDataToSave['fcmTokenUpdatedAt'] = FieldValue.serverTimestamp();\n-        debugPrint(\n-          \"✅ FCM Token will be saved: ${fcmToken.substring(0, 30)}...\",\n-        );\n-      } else {\n-        debugPrint(\n-          \"⚠️ No FCM Token available - saving without notification capability\",\n-        );\n-        // لا نحفظ fcmToken إذا كان null لتجنب overwrite أي token موجود\n-        sellerDataToSave['fcmTokenStatus'] = 'failed_to_retrieve';\n-        sellerDataToSave['fcmTokenFailedAt'] = FieldValue.serverTimestamp();\n-\n-        // جدولة إعادة المحاولة بعد التسجيل\n-        debugPrint(\"📅 Scheduling FCM token retry for later...\");\n-      }\n-\n-      debugPrint(\"💾 Saving seller data to Firestore...\");\n-      debugPrint(\"💾 Document ID: ${currentUser.uid}\");\n-      debugPrint(\"💾 Collection: ${FirebaseX.collectionSeller}\");\n-\n-      await _firestore\n-          .collection(FirebaseX.collectionSeller)\n-          .doc(currentUser.uid)\n-          .set(sellerDataToSave, SetOptions(merge: true));\n-\n-      debugPrint(\"✅ Seller data saved successfully to Firestore!\");\n-\n-      // التأكد من إعادة تعيين الحالات قبل التنقل\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      update();\n-\n-      debugPrint(\"🎉 Registration completed successfully!\");\n-\n-      // إذا لم نحصل على FCM token، جدولة إعادة المحاولة\n-      if (fcmToken == null || fcmToken.isEmpty) {\n-        retryFCMTokenLater();\n-      }\n-\n-      Get.snackbar(\n-        \"نجاح\",\n-        \"تم تسجيل معلوماتك بنجاح!\",\n-        backgroundColor: Colors.green.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-\n-      // إضافة تأخير قصير على iOS قبل التنقل\n-      if (Platform.isIOS) {\n-        await Future.delayed(const Duration(milliseconds: 500));\n-      }\n-\n-      // التأكد من التنقل على الـ main thread\n-      WidgetsBinding.instance.addPostFrameCallback((_) {\n-        Get.offAll(\n-          () => SellerMainScreen(),\n-        ); // Navigate to seller dashboard or main screen\n-      });\n-    } catch (e) {\n-      isLoading.value = false;\n-      isOtpVerifying.value = false;\n-      update();\n-      debugPrint(\"Error finalizing seller registration: $e\");\n-      String errorMessage = \"فشل إكمال عملية التسجيل.\";\n-      if (e is FirebaseException &&\n-          e.code == 'invalid-credential' &&\n-          isAutoVerified) {\n-        errorMessage =\n-            \"فشل التحقق التلقائي من الهاتف. قد تحتاج إلى إدخال الرمز يدويًا.\";\n-        // Optionally, you could re-route to OTP screen if auto-verification was the only path here\n-        // Get.to(() => OtpVerificationScreen()); // Might need to handle this case more gracefully\n-      } else if (e is FirebaseException &&\n-          e.code == 'invalid-verification-code') {\n-        errorMessage = \"رمز OTP الذي أدخلته غير صحيح.\";\n-      } else if (e is FirebaseException && e.code == 'session-expired') {\n-        errorMessage = \"انتهت صلاحية جلسة التحقق. يرجى طلب رمز جديد.\";\n-      }\n-\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"$errorMessage يرجى المحاولة مرة أخرى.\",\n-        backgroundColor: Colors.red.shade400,\n-        colorText: Colors.white,\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<String?> _uploadFile(File file, String path) async {\n-    try {\n-      debugPrint(\"🔧 Starting file upload to: $path\");\n-      debugPrint(\"🔧 File exists: ${await file.exists()}\");\n-      debugPrint(\"🔧 File size: ${await file.length()} bytes\");\n-\n-      // Verify Firebase Storage is properly initialized\n-      if (Firebase.apps.isEmpty) {\n-        throw Exception(\"Firebase not initialized\");\n-      }\n-\n-      final ref = _storage.ref().child(path);\n-      debugPrint(\"🔧 Storage reference created: ${ref.fullPath}\");\n-\n-      // iOS-specific: Add metadata to help with upload\n-      final metadata = SettableMetadata(\n-        contentType: 'image/jpeg',\n-        customMetadata: {\n-          'uploaded_by': 'seller_registration',\n-          'platform': Platform.isIOS ? 'ios' : 'android',\n-        },\n-      );\n-\n-      final uploadTask = ref.putFile(file, metadata);\n-\n-      // Monitor upload progress\n-      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n-        final progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n-        debugPrint(\"🔧 Upload progress: ${progress.toStringAsFixed(1)}%\");\n-      });\n-\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"✅ File uploaded successfully: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"❌ Error uploading file ($path): $e\");\n-\n-      // iOS-specific error handling\n-      if (Platform.isIOS && e.toString().contains('object-not-found')) {\n-        debugPrint(\n-          \"🔧 iOS Storage issue detected - retrying with different approach\",\n-        );\n-        return await _uploadFileWithRetry(file, path);\n-      }\n-\n-      return null;\n-    }\n-  }\n-\n-  Future<String?> _uploadFileWithRetry(File file, String path) async {\n-    try {\n-      // Wait a bit longer on iOS\n-      await Future.delayed(Duration(milliseconds: 1500));\n-\n-      // Try with a different path structure for iOS\n-      final timestamp = DateTime.now().millisecondsSinceEpoch;\n-      final newPath = '${path.replaceAll('/', '_')}_$timestamp';\n-\n-      debugPrint(\"🔧 Retrying upload with path: $newPath\");\n-\n-      final ref = _storage.ref().child(newPath);\n-      final uploadTask = ref.putFile(file);\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"✅ Retry upload successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"❌ Retry upload also failed: $e\");\n-      return null;\n-    }\n-  }\n-\n-  Future<void> pickImage(\n-    ImageSource source, {\n-    required bool isProfileImage,\n-  }) async {\n-    try {\n-      final XFile? pickedFile = await _picker.pickImage(\n-        source: source,\n-        imageQuality: 70,\n-        maxWidth: 1024,\n-      );\n-      if (pickedFile != null) {\n-        if (isProfileImage) {\n-          sellerProfileImageFile.value = File(pickedFile.path);\n-        } else {\n-          shopFrontImageFile.value = File(pickedFile.path);\n-        }\n-        update(); // For GetBuilder if used\n-      }\n-    } catch (e) {\n-      Get.snackbar(\"خطأ في الصورة\", \"فشل في اختيار الصورة: $e\");\n-    }\n-  }\n-\n-  // دالة لإدارة اختيار الفئات المتعددة\n-  void toggleCategorySelection(String category) {\n-    if (selectedShopCategories.contains(category)) {\n-      selectedShopCategories.remove(category);\n-    } else {\n-      if (selectedShopCategories.length < maxCategoriesAllowed) {\n-        selectedShopCategories.add(category);\n-      } else {\n-        Get.snackbar(\n-          \"تحذير\",\n-          \"يمكنك اختيار حد أقصى $maxCategoriesAllowed فئات فقط\",\n-          backgroundColor: Colors.orange.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-        );\n-      }\n-    }\n-  }\n-\n-  // دالة للتحقق من اختيار الفئة\n-  bool isCategorySelected(String category) {\n-    return selectedShopCategories.contains(category);\n-  }\n-\n-  // دالة للحصول على عدد الفئات المختارة\n-  int get selectedCategoriesCount => selectedShopCategories.length;\n-\n-  // دالة للحصول على نص عرض الفئات المختارة\n-  String get selectedCategoriesDisplay {\n-    if (selectedShopCategories.isEmpty) {\n-      return 'لم يتم اختيار أي فئة';\n-    } else if (selectedShopCategories.length == 1) {\n-      return selectedShopCategories.first;\n-    } else {\n-      return '${selectedShopCategories.length} فئات مختارة';\n-    }\n-  }\n-\n-  void toggleDayOpen(String dayKey) {\n-    if (workingHours[dayKey] != null) {\n-      bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n-      workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n-\n-      if (!workingHours[dayKey]!['isOpen']) {\n-        // If day is being closed\n-        workingHours[dayKey]!['opensAt'] = null;\n-        workingHours[dayKey]!['closesAt'] = null;\n-        if (expandedDayPanel.value == dayKey) {\n-          // Close expansion panel if it was this day\n-          expandedDayPanel.value = null;\n-        }\n-      } else {\n-        // If day is being opened\n-        workingHours[dayKey]!['opensAt'] =\n-            _lastAppliedOpensAt.value ?? \"09:00 AM\";\n-        workingHours[dayKey]!['closesAt'] =\n-            _lastAppliedClosesAt.value ?? \"05:00 PM\";\n-        // Optionally, open this panel when day is toggled on if not already open by user interaction\n-        // expandedDayPanel.value = dayKey;\n-      }\n-      workingHours.refresh();\n-    }\n-  }\n-\n-  bool canApplyToOthers(String dayKey) {\n-    final dayData = workingHours[dayKey];\n-    if (dayData == null || !(dayData['isOpen'] == true)) return false;\n-    return dayData['opensAt'] != null && dayData['closesAt'] != null;\n-  }\n-\n-  void offerToApplyTimesToOtherDays(\n-    BuildContext context,\n-    String sourceDayKey,\n-    String opensAtToApply,\n-    String closesAtToApply,\n-  ) {\n-    Get.dialog(\n-      AlertDialog(\n-        title: const Text(\"تطبيق الأوقات؟\"),\n-        content: Text(\n-          \"هل ترغب في تطبيق وقت الفتح ($opensAtToApply) ووقت الإغلاق ($closesAtToApply) على الأيام الأخرى التي تم تحديدها كمفتوحة ولم يتم تحديد أوقات لها بعد أو على جميع الأيام المفتوحة؟\",\n-        ),\n-        actionsAlignment: MainAxisAlignment.spaceEvenly,\n-        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),\n-        actions: [\n-          TextButton(child: const Text(\"إلغاء\"), onPressed: () => Get.back()),\n-          ElevatedButton(\n-            child: const Text(\"للأيام الفارغة فقط\"),\n-            onPressed: () {\n-              Get.back();\n-              applyTimesToOtherOpenDays(\n-                sourceDayKey,\n-                opensAtToApply,\n-                closesAtToApply,\n-                applyToAllOpen: false,\n-              );\n-            },\n-          ),\n-          ElevatedButton(\n-            child: const Text(\"نعم، للكل (المفتوح)\"),\n-            onPressed: () {\n-              Get.back();\n-              applyTimesToOtherOpenDays(\n-                sourceDayKey,\n-                opensAtToApply,\n-                closesAtToApply,\n-                applyToAllOpen: true,\n-              );\n-            },\n-          ),\n-        ],\n-      ),\n-      barrierDismissible: true,\n-    );\n-  }\n-\n-  void applyTimesToOtherOpenDays(\n-    String sourceDayKey,\n-    String opensAtToApply,\n-    String closesAtToApply, {\n-    required bool applyToAllOpen,\n-  }) {\n-    bool timesApplied = false;\n-    workingHours.forEach((key, value) {\n-      if (key != sourceDayKey && (value['isOpen'] == true)) {\n-        bool apply = false;\n-        if (applyToAllOpen) {\n-          apply = true;\n-        } else {\n-          // Apply to empty open days only\n-          if (value['opensAt'] == null || value['closesAt'] == null) {\n-            apply = true;\n-          }\n-        }\n-        if (apply) {\n-          value['opensAt'] = opensAtToApply;\n-          value['closesAt'] = closesAtToApply;\n-          timesApplied = true;\n-        }\n-      }\n-    });\n-    if (timesApplied) {\n-      _lastAppliedOpensAt.value =\n-          opensAtToApply; // Update template if changes were made\n-      _lastAppliedClosesAt.value = closesAtToApply;\n-      workingHours.refresh();\n-      Get.snackbar(\n-        \"تم التحديث\",\n-        \"تم تطبيق الأوقات بنجاح.\",\n-        snackPosition: SnackPosition.BOTTOM,\n-        backgroundColor: Colors.green.shade400,\n-        colorText: Colors.white,\n-      );\n-    } else {\n-      Get.snackbar(\n-        \"لم يتغير شيء\",\n-        \"لم يتم العثور على أيام لتطبيق الأوقات عليها حسب اختيارك.\",\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    }\n-  }\n-\n-  Future<void> selectTime(\n-    BuildContext context,\n-    String dayKey,\n-    bool isOpeningTime,\n-  ) async {\n-    final Map<String, dynamic>? dayData = workingHours[dayKey];\n-    final String? opensAtString = dayData?['opensAt'] as String?;\n-    final String? closesAtString = dayData?['closesAt'] as String?;\n-\n-    String? timeToParse;\n-    if (isOpeningTime) {\n-      timeToParse = opensAtString;\n-    } else {\n-      timeToParse = closesAtString;\n-    }\n-\n-    TimeOfDay? initialTime = _parseTime(timeToParse) ?? TimeOfDay.now();\n-\n-    final TimeOfDay? pickedTime = await showTimePicker(\n-      context: context,\n-      initialTime: initialTime,\n-      builder: (context, child) {\n-        return Theme(\n-          data: ThemeData.light().copyWith(\n-            colorScheme: ColorScheme.light(\n-              primary: Get.theme.primaryColor, // header background color\n-              onPrimary: Colors.white, // header text color\n-              onSurface: Colors.black, // body text color\n-            ),\n-            timePickerTheme: TimePickerThemeData(\n-              dialHandColor: Get.theme.primaryColor,\n-            ),\n-            textButtonTheme: TextButtonThemeData(\n-              style: TextButton.styleFrom(\n-                foregroundColor: Get.theme.primaryColor, // button text color\n-              ),\n-            ),\n-          ),\n-          child: child!,\n-        );\n-      },\n-    );\n-\n-    if (pickedTime != null) {\n-      final formattedTime = formatTimeOfDay(pickedTime);\n-      final currentOpensAt = _parseTime(workingHours[dayKey]?['opensAt']);\n-      final currentClosesAt = _parseTime(workingHours[dayKey]?['closesAt']);\n-\n-      if (isOpeningTime) {\n-        if (currentClosesAt != null &&\n-            _isTimeBeforeOrEqual(\n-              pickedTime,\n-              currentClosesAt,\n-              isOpening: true,\n-              isClosing: false,\n-            )) {\n-          workingHours[dayKey]!['opensAt'] = formattedTime;\n-          _lastAppliedOpensAt.value = formattedTime;\n-        } else if (currentClosesAt != null) {\n-          Get.snackbar(\n-            \"وقت غير صالح\",\n-            \"وقت الفتح يجب أن يكون قبل وقت الإغلاق.\",\n-            snackPosition: SnackPosition.BOTTOM,\n-            backgroundColor: Colors.orange.shade300,\n-          );\n-          return;\n-        } else {\n-          // No closing time set yet, allow setting opening time\n-          workingHours[dayKey]!['opensAt'] = formattedTime;\n-          _lastAppliedOpensAt.value = formattedTime;\n-        }\n-      } else {\n-        // isClosingTime\n-        if (currentOpensAt != null &&\n-            _isTimeBeforeOrEqual(\n-              currentOpensAt,\n-              pickedTime,\n-              isOpening: false,\n-              isClosing: true,\n-            )) {\n-          workingHours[dayKey]!['closesAt'] = formattedTime;\n-          _lastAppliedClosesAt.value = formattedTime;\n-        } else if (currentOpensAt != null) {\n-          Get.snackbar(\n-            \"وقت غير صالح\",\n-            \"وقت الإغلاق يجب أن يكون بعد وقت الفتح.\",\n-            snackPosition: SnackPosition.BOTTOM,\n-            backgroundColor: Colors.orange.shade300,\n-          );\n-          return;\n-        } else {\n-          // No opening time set yet, allow setting closing time\n-          workingHours[dayKey]!['closesAt'] = formattedTime;\n-          _lastAppliedClosesAt.value = formattedTime;\n-        }\n-      }\n-      workingHours.refresh();\n-    }\n-  }\n-\n-  bool _isTimeBeforeOrEqual(\n-    TimeOfDay time1,\n-    TimeOfDay time2, {\n-    required bool isOpening,\n-    required bool isClosing,\n-  }) {\n-    final time1Minutes = time1.hour * 60 + time1.minute;\n-    final time2Minutes = time2.hour * 60 + time2.minute;\n-    if (isOpening) {\n-      // time1 is opensAt, time2 is closesAt\n-      return time1Minutes < time2Minutes;\n-    } else {\n-      // time1 is opensAt, time2 is closesAt\n-      return time1Minutes < time2Minutes;\n-    }\n-  }\n-\n-  String formatTimeOfDay(TimeOfDay tod) {\n-    final now = DateTime.now();\n-    final dt = DateTime(now.year, now.month, now.day, tod.hour, tod.minute);\n-    final format = DateFormat.jm(); // e.g., 5:08 PM\n-    return format.format(dt);\n-  }\n-\n-  TimeOfDay? _parseTime(String? timeString) {\n-    if (timeString == null) return null;\n-    try {\n-      final format =\n-          DateFormat.jm(); // Needs to match the format used in formatTimeOfDay\n-      final dt = format.parse(timeString);\n-      return TimeOfDay.fromDateTime(dt);\n-    } catch (e) {\n-      debugPrint(\"Error parsing time: $e\");\n-      return null;\n-    }\n-  }\n-\n-  // --- Location Methods ---\n-  final TextEditingController streetAddressController = TextEditingController();\n-\n-  void onMapCreated(GoogleMapController controller) {\n-    mapController = controller;\n-  }\n-\n-  Future<void> openLocationPickerScreen(BuildContext context) async {\n-    final LatLng? result = await Get.to<LatLng>(\n-      () => LocationPickerScreen(initialLocation: shopLocation.value),\n-    );\n-    if (result != null) {\n-      shopLocation.value = result;\n-      await _getAddressFromLatLng(result);\n-      // Optionally move camera on the small map if it's visible and controller is available\n-      mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n-    }\n-  }\n-\n-  Future<void> _getAddressFromLatLng(LatLng latLng) async {\n-    try {\n-      List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n-        latLng.latitude,\n-        latLng.longitude,\n-      );\n-      if (placemarks.isNotEmpty) {\n-        final p = placemarks[0];\n-        // Construct a more detailed or relevant address string\n-        shopAddressText.value =\n-            \"${p.name}, ${p.locality}, ${p.subAdministrativeArea}, ${p.administrativeArea}\"\n-                .replaceAll(\"null,\", \"\")\n-                .trim()\n-                .replaceAll(RegExp(r'^, |,$'), '');\n-        if (streetAddressController.text.isEmpty &&\n-            p.street != null &&\n-            p.street!.isNotEmpty) {\n-          streetAddressController.text = p.street!;\n-        }\n-      } else {\n-        shopAddressText.value = \"تعذر جلب العنوان\";\n-      }\n-    } catch (e) {\n-      debugPrint(\"Error getting address: $e\");\n-      shopAddressText.value = \"خطأ في جلب العنوان\";\n-    }\n-  }\n-\n-  Future<void> tryMoveToCurrentLocation() async {\n-    isLoading.value = true; // Indicate loading for location fetch\n-    update();\n-    try {\n-      Position currentPosition = await _determinePosition();\n-      LatLng newLatLng = LatLng(\n-        currentPosition.latitude,\n-        currentPosition.longitude,\n-      );\n-      shopLocation.value = newLatLng;\n-      await _getAddressFromLatLng(newLatLng);\n-      mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n-    } catch (e) {\n-      Get.snackbar(\n-        \"خطأ\",\n-        \"فشل في تحديد الموقع الحالي: ${e.toString()}\",\n-        snackPosition: SnackPosition.BOTTOM,\n-      );\n-    } finally {\n-      isLoading.value = false;\n-      update();\n-    }\n-  }\n-\n-  Future<Position> _determinePosition() async {\n-    bool serviceEnabled;\n-    LocationPermission permission;\n-\n-    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n-    if (!serviceEnabled) {\n-      // Attempt to open location settings\n-      await Geolocator.openLocationSettings();\n-      return Future.error('خدمات الموقع معطلة. يرجى تفعيلها.');\n-    }\n-\n-    permission = await Geolocator.checkPermission();\n-    if (permission == LocationPermission.denied) {\n-      permission = await Geolocator.requestPermission();\n-      if (permission == LocationPermission.denied) {\n-        return Future.error('تم رفض أذونات تحديد الموقع.');\n-      }\n-    }\n-\n-    if (permission == LocationPermission.deniedForever) {\n-      return Future.error(\n-        'أذونات تحديد الموقع مرفوضة بشكل دائم، لا يمكننا طلب الأذونات. يرجى تفعيلها من الإعدادات.',\n-      );\n-    }\n-    currentPositionAccuracy.value =\n-        (await Geolocator.getCurrentPosition()).accuracy;\n-\n-    return await Geolocator.getCurrentPosition(\n-      desiredAccuracy: LocationAccuracy.high,\n-    );\n-  }\n-\n-  void submitRegistration(BuildContext context) {\n-    debugPrint(\"🔥 submitRegistration called\");\n-\n-    // This method will now call initiatePhoneVerificationAndCollectData\n-    // as OTP verification is mandatory.\n-\n-    // إضافة حماية إضافية من التجميد\n-    _startSafetyTimeout();\n-\n-    debugPrint(\"About to call initiatePhoneVerificationAndCollectData...\");\n-    initiatePhoneVerificationAndCollectData();\n-    debugPrint(\"initiatePhoneVerificationAndCollectData call completed\");\n-  }\n-\n-  // آلية حماية إضافية لتجنب التجميد على iOS\n-  Timer? _safetyTimer;\n-\n-  void _startSafetyTimeout() {\n-    _safetyTimer = Timer(Duration(seconds: Platform.isIOS ? 60 : 90), () {\n-      if ((isLoading.value || isOtpSending.value) && !isOtpVerifying.value) {\n-        debugPrint(\"Safety timeout triggered - resetting loading states\");\n-        isLoading.value = false;\n-        isOtpSending.value = false;\n-        isOtpVerifying.value = false;\n-        update();\n-        Get.snackbar(\n-          \"انتهت المهلة الزمنية\",\n-          \"تم انتهاء الوقت المحدد للعملية. يرجى المحاولة مرة أخرى.\",\n-          backgroundColor: Colors.orange.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-        );\n-      }\n-    });\n-  }\n-\n-  void _cancelSafetyTimeout() {\n-    _safetyTimer?.cancel();\n-    _safetyTimer = null;\n-  }\n-\n-  /// دالة احترافية للحصول على FCM Token مع معالجة شاملة للأخطاء\n-  Future<String?> _getFCMTokenSafely() async {\n-    debugPrint(\"🔑 Starting FCM token retrieval process...\");\n-\n-    try {\n-      // 1. طلب الأذونات أولاً\n-      debugPrint(\"📱 Requesting Firebase Messaging permissions...\");\n-      NotificationSettings settings = await _firebaseMessaging\n-          .requestPermission(\n-            alert: true,\n-            announcement: false,\n-            badge: true,\n-            carPlay: false,\n-            criticalAlert: false,\n-            provisional: false,\n-            sound: true,\n-          );\n-\n-      debugPrint(\"🔔 Permission status: ${settings.authorizationStatus}\");\n-\n-      if (settings.authorizationStatus == AuthorizationStatus.denied) {\n-        debugPrint(\"❌ Notification permissions denied\");\n-        return null;\n-      }\n-\n-      // 2. محاولة مباشرة للحصول على FCM token بدون انتظار APNS\n-      debugPrint(\n-        \"🚀 Attempting direct FCM token retrieval (bypass APNS dependency)...\",\n-      );\n-\n-      String? fcmToken;\n-      int directAttempts = 0;\n-      const maxDirectAttempts = 3;\n-\n-      while (fcmToken == null && directAttempts < maxDirectAttempts) {\n-        directAttempts++;\n-        debugPrint(\"🔄 Direct FCM attempt $directAttempts/$maxDirectAttempts\");\n-\n-        try {\n-          // محاولة مباشرة بدون انتظار APNS\n-          fcmToken = await _firebaseMessaging.getToken().timeout(\n-            Duration(seconds: 20 + (10 * directAttempts)),\n-            onTimeout: () => null,\n-          );\n-\n-          if (fcmToken != null && fcmToken.isNotEmpty) {\n-            debugPrint(\"✅ Direct FCM Token received successfully!\");\n-            debugPrint(\"🔑 Token preview: ${fcmToken.substring(0, 50)}...\");\n-            await _cacheFCMToken(fcmToken);\n-            return fcmToken;\n-          }\n-        } catch (e) {\n-          debugPrint(\"⚠️ Direct FCM attempt $directAttempts failed: $e\");\n-          // إذا لم تكن مشكلة APNS، تابع\n-          if (!e.toString().toLowerCase().contains('apns')) {\n-            await Future.delayed(Duration(seconds: directAttempts * 2));\n-            continue;\n-          }\n-        }\n-\n-        // إذا وصلنا هنا، فالمشكلة متعلقة بـ APNS\n-        break;\n-      }\n-\n-      // 3. إذا فشلت المحاولة المباشرة، جرب الطريقة التقليدية مع APNS\n-      if (fcmToken == null && Platform.isIOS) {\n-        debugPrint(\"🍎 Fallback to APNS-dependent approach...\");\n-\n-        // محاولة تسجيل للإشعارات من native code\n-        debugPrint(\"📲 Triggering native notification registration...\");\n-\n-        // انتظار إضافي للنظام\n-        await Future.delayed(const Duration(seconds: 5));\n-\n-        // محاولة APNS محدودة\n-        String? apnsToken;\n-        for (int attempt = 1; attempt <= 3; attempt++) {\n-          debugPrint(\"🔄 APNS attempt $attempt/3\");\n-\n-          try {\n-            await Future.delayed(Duration(seconds: attempt * 3));\n-            apnsToken = await _firebaseMessaging.getAPNSToken();\n-            if (apnsToken != null) {\n-              debugPrint(\n-                \"✅ APNS Token received: ${apnsToken.substring(0, 20)}...\",\n-              );\n-              break;\n-            }\n-          } catch (e) {\n-            debugPrint(\"⚠️ APNS attempt $attempt failed: $e\");\n-          }\n-        }\n-\n-        // 4. محاولة FCM مرة أخيرة\n-        if (apnsToken != null) {\n-          debugPrint(\"🔑 Final FCM token attempt with APNS...\");\n-\n-          try {\n-            fcmToken = await _firebaseMessaging.getToken().timeout(\n-              const Duration(seconds: 30),\n-              onTimeout: () => null,\n-            );\n-\n-            if (fcmToken != null && fcmToken.isNotEmpty) {\n-              debugPrint(\"✅ FCM Token received after APNS setup!\");\n-              await _cacheFCMToken(fcmToken);\n-              return fcmToken;\n-            }\n-          } catch (e) {\n-            debugPrint(\"⚠️ Final FCM attempt failed: $e\");\n-          }\n-        }\n-      }\n-\n-      // 5. محاولة استرداد من cache\n-      debugPrint(\"♻️ Trying cached token...\");\n-      String? cachedToken = await _getCachedFCMToken();\n-\n-      if (cachedToken != null) {\n-        debugPrint(\"✅ Using cached FCM token\");\n-        return cachedToken;\n-      }\n-\n-      // 6. إذا فشل كل شيء، إنشاء placeholder token للتطوير\n-      if (Platform.isIOS) {\n-        debugPrint(\"🛠️ Creating development placeholder token...\");\n-        String placeholderToken = await _createDevelopmentToken();\n-        if (placeholderToken.isNotEmpty) {\n-          debugPrint(\n-            \"🔧 Using development token: ${placeholderToken.substring(0, 30)}...\",\n-          );\n-          await _cacheFCMToken(placeholderToken);\n-          return placeholderToken;\n-        }\n-      }\n-\n-      debugPrint(\"❌ All FCM token retrieval methods failed\");\n-      return null;\n-    } catch (e) {\n-      debugPrint(\"🚨 Fatal error in FCM token retrieval: $e\");\n-      debugPrint(\"📊 Error details: ${e.toString()}\");\n-\n-      // محاولة أخيرة مع cached token\n-      String? cachedToken = await _getCachedFCMToken();\n-      if (cachedToken != null) {\n-        debugPrint(\"♻️ Emergency fallback to cached token\");\n-        return cachedToken;\n-      }\n-\n-      return null;\n-    }\n-  }\n-\n-  /// إنشاء token مؤقت للتطوير عندما يفشل APNS\n-  Future<String> _createDevelopmentToken() async {\n-    try {\n-      final User? currentUser = _auth.currentUser;\n-      final String deviceId =\n-          currentUser?.uid ?? DateTime.now().millisecondsSinceEpoch.toString();\n-      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();\n-\n-      // إنشاء token مؤقت فريد للجهاز\n-      String developmentToken = \"dev_token_ios_${deviceId}_$timestamp\";\n-\n-      debugPrint(\"🔧 Generated development token for testing\");\n-      return developmentToken;\n-    } catch (e) {\n-      debugPrint(\"⚠️ Failed to create development token: $e\");\n-      return \"\";\n-    }\n-  }\n-\n-  /// حفظ FCM token في التفضيلات المحلية\n-  Future<void> _cacheFCMToken(String token) async {\n-    try {\n-      final box = GetStorage();\n-      await box.write('cached_fcm_token', token);\n-      await box.write(\n-        'fcm_token_timestamp',\n-        DateTime.now().millisecondsSinceEpoch,\n-      );\n-      debugPrint(\"💾 FCM token cached successfully\");\n-    } catch (e) {\n-      debugPrint(\"⚠️ Failed to cache FCM token: $e\");\n-    }\n-  }\n-\n-  /// استرداد FCM token من التفضيلات المحلية\n-  Future<String?> _getCachedFCMToken() async {\n-    try {\n-      final box = GetStorage();\n-      String? cachedToken = box.read('cached_fcm_token');\n-      int? timestamp = box.read('fcm_token_timestamp');\n-\n-      if (cachedToken != null && timestamp != null) {\n-        // تحقق من عمر الـ token (صالح لمدة 7 أيام)\n-        DateTime tokenDate = DateTime.fromMillisecondsSinceEpoch(timestamp);\n-        Duration age = DateTime.now().difference(tokenDate);\n-\n-        if (age.inDays < 7) {\n-          debugPrint(\n-            \"♻️ Found valid cached FCM token (age: ${age.inHours} hours)\",\n-          );\n-          return cachedToken;\n-        } else {\n-          debugPrint(\n-            \"⏰ Cached FCM token is too old (${age.inDays} days), ignoring\",\n-          );\n-        }\n-      }\n-\n-      return null;\n-    } catch (e) {\n-      debugPrint(\"⚠️ Failed to retrieve cached FCM token: $e\");\n-      return null;\n-    }\n-  }\n-\n-  /// تحديث FCM Token في Firestore لاحقاً (يمكن استدعاؤها من مكان آخر)\n-  Future<void> updateFCMTokenInFirestore() async {\n-    try {\n-      final User? currentUser = _auth.currentUser;\n-      if (currentUser == null) {\n-        debugPrint(\"⚠️ No current user to update FCM token for\");\n-        return;\n-      }\n-\n-      debugPrint(\"🔄 Attempting to update FCM token in Firestore...\");\n-      final String? fcmToken = await _getFCMTokenSafely();\n-\n-      if (fcmToken != null && fcmToken.isNotEmpty) {\n-        await _firestore\n-            .collection(FirebaseX.collectionSeller)\n-            .doc(currentUser.uid)\n-            .update({\n-              'fcmToken': fcmToken,\n-              'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n-              'fcmTokenStatus': 'active',\n-            });\n-\n-        debugPrint(\"✅ FCM Token updated successfully in Firestore\");\n-        Get.snackbar(\n-          \"تم التحديث\",\n-          \"تم تحديث معرف الإشعارات بنجاح\",\n-          backgroundColor: Colors.green.shade400,\n-          colorText: Colors.white,\n-          snackPosition: SnackPosition.BOTTOM,\n-          duration: const Duration(seconds: 2),\n-        );\n-      } else {\n-        debugPrint(\"❌ Failed to get FCM token for update\");\n-      }\n-    } catch (e) {\n-      debugPrint(\"🚨 Error updating FCM token in Firestore: $e\");\n-    }\n-  }\n-\n-  /// دالة محسّنة للحصول على FCM token مع إعداد أفضل لـ iOS\n-  Future<String?> _getIOSOptimizedFCMToken() async {\n-    debugPrint(\"🍎 Starting iOS-optimized FCM token retrieval...\");\n-\n-    try {\n-      // 1. انتظار إضافي للتأكد من إعداد النظام\n-      await Future.delayed(const Duration(seconds: 5));\n-\n-      // 2. محاولة تسجيل للـ remote notifications يدوياً إذا لم يكن مسجلاً\n-      debugPrint(\"📱 Ensuring iOS remote notification registration...\");\n-\n-      // 3. طلب الأذونات مرة أخرى\n-      NotificationSettings settings = await _firebaseMessaging\n-          .requestPermission(\n-            alert: true,\n-            announcement: false,\n-            badge: true,\n-            carPlay: false,\n-            criticalAlert: false,\n-            provisional: false,\n-            sound: true,\n-          );\n-\n-      if (settings.authorizationStatus != AuthorizationStatus.authorized) {\n-        debugPrint(\n-          \"❌ iOS Notifications not authorized: ${settings.authorizationStatus}\",\n-        );\n-        return null;\n-      }\n-\n-      // 4. محاولة مختلفة للحصول على FCM token مع انتظار أطول\n-      for (int attempt = 1; attempt <= 3; attempt++) {\n-        debugPrint(\"🔑 iOS FCM token attempt $attempt/3\");\n-\n-        try {\n-          // انتظار متزايد مع كل محاولة\n-          await Future.delayed(Duration(seconds: 3 * attempt));\n-\n-          String? token = await _firebaseMessaging.getToken().timeout(\n-            Duration(seconds: 60 + (10 * attempt)), // انتظار أطول مع كل محاولة\n-          );\n-\n-          if (token != null && token.isNotEmpty) {\n-            debugPrint(\"✅ iOS FCM token received on attempt $attempt!\");\n-            return token;\n-          }\n-        } catch (e) {\n-          debugPrint(\"⚠️ iOS FCM attempt $attempt failed: $e\");\n-          if (e.toString().toLowerCase().contains('apns')) {\n-            // إذا كان خطأ APNS، انتظار أطول\n-            await Future.delayed(Duration(seconds: 5 * attempt));\n-          }\n-        }\n-      }\n-\n-      return null;\n-    } catch (e) {\n-      debugPrint(\"🚨 iOS FCM token retrieval failed: $e\");\n-      return null;\n-    }\n-  }\n-\n-  /// مساعد لإعادة المحاولة في الحصول على FCM token بعد التسجيل\n-  void retryFCMTokenLater() {\n-    // إعادة المحاولة بعد 30 ثانية للمحاولة الأولى\n-    Timer(const Duration(seconds: 30), () {\n-      debugPrint(\"🔄 Retrying FCM token retrieval after 30 seconds...\");\n-      updateFCMTokenInFirestore();\n-    });\n-\n-    // محاولة خاصة بـ iOS بعد دقيقة واحدة\n-    if (Platform.isIOS) {\n-      Timer(const Duration(minutes: 1), () async {\n-        debugPrint(\"🍎 iOS-specific FCM token retry after 1 minute...\");\n-        final token = await _getIOSOptimizedFCMToken();\n-        if (token != null) {\n-          try {\n-            final User? currentUser = _auth.currentUser;\n-            if (currentUser != null) {\n-              await _firestore\n-                  .collection(FirebaseX.collectionSeller)\n-                  .doc(currentUser.uid)\n-                  .update({\n-                    'fcmToken': token,\n-                    'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n-                    'fcmTokenStatus': 'active',\n-                  });\n-              debugPrint(\"✅ iOS FCM Token updated successfully in retry!\");\n-            }\n-          } catch (e) {\n-            debugPrint(\"❌ Failed to update iOS FCM token in retry: $e\");\n-          }\n-        }\n-      });\n-    }\n-\n-    // إعادة محاولة إضافية بعد دقيقتين إذا فشلت الأولى\n-    Timer(const Duration(minutes: 2), () {\n-      debugPrint(\"🔄 Second retry attempt for FCM token after 2 minutes...\");\n-      updateFCMTokenInFirestore();\n-    });\n-\n-    // محاولة أخيرة بعد 5 دقائق\n-    Timer(const Duration(minutes: 5), () {\n-      debugPrint(\"🔄 Final retry attempt for FCM token after 5 minutes...\");\n-      updateFCMTokenInFirestore();\n-    });\n-  }\n-}\n-\n-/// iOS-specific Firebase Storage handler to fix image upload issues\n-class IOSFirebaseStorageHandler {\n-  final FirebaseStorage _storage;\n-\n-  IOSFirebaseStorageHandler(this._storage);\n-\n-  Future<String?> uploadFile(File file, String path) async {\n-    try {\n-      debugPrint(\"🍎 iOS Storage Handler: Starting upload to: $path\");\n-\n-      // Wait longer for Firebase to be fully ready on iOS\n-      await Future.delayed(Duration(milliseconds: 5000));\n-\n-      // Verify Firebase is properly initialized\n-      if (Firebase.apps.isEmpty) {\n-        throw Exception(\"Firebase not initialized\");\n-      }\n-\n-      // Test Firebase Storage connection first\n-      try {\n-        _storage.ref().child(\n-          \"connection_test_${DateTime.now().millisecondsSinceEpoch}\",\n-        );\n-        debugPrint(\"🍎 Testing Firebase Storage connection...\");\n-        // Just create a reference, don't upload\n-        debugPrint(\"✅ Firebase Storage connection test passed\");\n-      } catch (e) {\n-        debugPrint(\"❌ Firebase Storage connection test failed: $e\");\n-        throw Exception(\"Firebase Storage not accessible: $e\");\n-      }\n-\n-      // Verify file exists and is readable\n-      if (!await file.exists()) {\n-        throw Exception(\"File does not exist at path: ${file.path}\");\n-      }\n-\n-      final fileSize = await file.length();\n-      debugPrint(\"🍎 iOS Storage Handler: File size: $fileSize bytes\");\n-\n-      if (fileSize == 0) {\n-        throw Exception(\"File is empty\");\n-      }\n-\n-      // Use simple path first - try without modifications\n-      debugPrint(\"🍎 iOS Storage Handler: Trying direct upload to: $path\");\n-\n-      final ref = _storage.ref().child(path);\n-\n-      // Set proper metadata for iOS\n-      final metadata = SettableMetadata(\n-        contentType: _getContentType(file.path),\n-        customMetadata: {\n-          'uploaded_by': 'ios_seller_registration',\n-          'original_path': path,\n-          'upload_timestamp': DateTime.now().millisecondsSinceEpoch.toString(),\n-        },\n-      );\n-\n-      debugPrint(\"🍎 iOS Storage Handler: Creating upload task...\");\n-      final uploadTask = ref.putFile(file, metadata);\n-\n-      // Monitor progress\n-      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n-        if (snapshot.totalBytes > 0) {\n-          final progress =\n-              snapshot.bytesTransferred / snapshot.totalBytes * 100;\n-          debugPrint(\"🍎 iOS Upload progress: ${progress.toStringAsFixed(1)}%\");\n-        }\n-      });\n-\n-      debugPrint(\"🍎 iOS Storage Handler: Waiting for upload completion...\");\n-      final snapshot = await uploadTask.whenComplete(() {});\n-\n-      debugPrint(\"🍎 iOS Storage Handler: Getting download URL...\");\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"✅ iOS Upload successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"❌ iOS Storage Handler error: $e\");\n-\n-      // Try alternative upload method for iOS\n-      return await _alternativeUploadMethod(file, path);\n-    }\n-  }\n-\n-  Future<String?> _alternativeUploadMethod(File file, String path) async {\n-    // Try multiple alternative approaches for iOS\n-\n-    // Method 1: putData instead of putFile\n-    try {\n-      debugPrint(\"🔄 iOS Alternative Method 1: Using putData...\");\n-      await Future.delayed(Duration(milliseconds: 3000));\n-\n-      final bytes = await file.readAsBytes();\n-      debugPrint(\"🔄 iOS Read ${bytes.length} bytes from file\");\n-\n-      final ref = _storage.ref().child(path);\n-      final uploadTask = ref.putData(\n-        bytes,\n-        SettableMetadata(\n-          contentType: _getContentType(file.path),\n-          customMetadata: {\n-            'uploaded_by': 'ios_alternative_putdata',\n-            'original_path': path,\n-          },\n-        ),\n-      );\n-\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"✅ iOS Alternative Method 1 successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"❌ iOS Alternative Method 1 failed: $e\");\n-    }\n-\n-    // Method 2: Different path structure\n-    try {\n-      debugPrint(\"🔄 iOS Alternative Method 2: Different path structure...\");\n-      await Future.delayed(Duration(milliseconds: 3000));\n-\n-      final timestamp = DateTime.now().millisecondsSinceEpoch;\n-      final altPath = \"mobile_uploads/${path.replaceAll('/', '_')}_$timestamp\";\n-\n-      debugPrint(\"🔄 iOS Alternative path: $altPath\");\n-\n-      final bytes = await file.readAsBytes();\n-      final ref = _storage.ref().child(altPath);\n-\n-      final uploadTask = ref.putData(\n-        bytes,\n-        SettableMetadata(\n-          contentType: _getContentType(file.path),\n-          customMetadata: {\n-            'uploaded_by': 'ios_alternative_path',\n-            'original_path': path,\n-          },\n-        ),\n-      );\n-\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"✅ iOS Alternative Method 2 successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"❌ iOS Alternative Method 2 failed: $e\");\n-    }\n-\n-    // Method 3: Very simple path\n-    try {\n-      debugPrint(\"🔄 iOS Alternative Method 3: Simple upload...\");\n-      await Future.delayed(Duration(milliseconds: 5000));\n-\n-      final simplePath = \"uploads/${DateTime.now().millisecondsSinceEpoch}\";\n-      debugPrint(\"🔄 iOS Simple path: $simplePath\");\n-\n-      final bytes = await file.readAsBytes();\n-      final ref = _storage.ref().child(simplePath);\n-\n-      final uploadTask = ref.putData(bytes);\n-      final snapshot = await uploadTask.whenComplete(() {});\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n-\n-      debugPrint(\"✅ iOS Alternative Method 3 successful: $downloadUrl\");\n-      return downloadUrl;\n-    } catch (e) {\n-      debugPrint(\"❌ iOS Alternative Method 3 failed: $e\");\n-    }\n-\n-    debugPrint(\"❌ All iOS alternative upload methods failed\");\n-    return null;\n-  }\n-\n-  String _getContentType(String filePath) {\n-    final extension = filePath.toLowerCase().split('.').last;\n-    switch (extension) {\n-      case 'jpg':\n-      case 'jpeg':\n-        return 'image/jpeg';\n-      case 'png':\n-        return 'image/png';\n-      case 'gif':\n-        return 'image/gif';\n-      case 'webp':\n-        return 'image/webp';\n-      default:\n-        return 'image/jpeg'; // Default fallback\n-    }\n-  }\n-}\n"
                },
                {
                    "date": 1752575864935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,8 +66,15 @@\n \n   // --- Location ---\n   final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n   final RxString shopAddressText = ''.obs;\n+  final Rxn<LatLng> tempSelectedLocation = Rxn<LatLng>(\n+    null,\n+  ); // للموقع المؤقت المختار\n+  final RxBool isLocationLoading = false.obs; // لحالة تحميل الموقع\n+  final RxBool showLocationConfirmation = false.obs; // لإظهار تأكيد الموقع\n+  final RxBool firstTimeAutoExpand =\n+      true.obs; // للتحكم في التوسيع التلقائي لأول مرة فقط\n   GoogleMapController? mapController;\n \n   // --- Working Hours ---\n   final List<String> dayKeys = [\n@@ -128,39 +135,62 @@\n       }.obs;\n   final RxnString _lastAppliedOpensAt = RxnString(null);\n   final RxnString _lastAppliedClosesAt = RxnString(null);\n   // --- Main Categories ---\n-  // قائمة شاملة بجميع فئات المتاجر الممكنة\n+  // قائمة شاملة بفئات المنتجات فقط (لا تتضمن الخدمات)\n   final List<String> shopCategories = [\n     \"إلكترونيات ومعدات تقنية\",\n-    \"ملابس وأزياء\",\n-    \"أحذية وحقائب\",\n-    \"طعام ومشروبات\",\n-    \"منتجات صحية وتجميل\",\n+    \"هواتف ذكية وأجهزة لوحية\",\n+    \"حاسوب ولابتوب\",\n+    \"ملابس رجالية\",\n+    \"ملابس نسائية\",\n+    \"ملابس أطفال\",\n+    \"أحذية رجالية\",\n+    \"أحذية نسائية\",\n+    \"حقائب ومحافظ\",\n+    \"مواد غذائية وبقالة\",\n+    \"حلويات ومعجنات\",\n+    \"مشروبات ومرطبات\",\n+    \"منتجات صحية وفيتامينات\",\n+    \"مستحضرات تجميل ومكياج\",\n+    \"منتجات العناية الشخصية\",\n     \"أدوية ومستلزمات طبية\",\n-    \"كتب ومواد تعليمية\",\n-    \"ألعاب وترفيه\",\n-    \"رياضة ولياقة\",\n+    \"كتب ومجلات\",\n+    \"مواد تعليمية وقرطاسية\",\n+    \"ألعاب أطفال\",\n+    \"ألعاب إلكترونية\",\n+    \"معدات رياضية\",\n+    \"ملابس رياضية\",\n     \"أدوات منزلية ومطبخ\",\n-    \"أثاث وديكور\",\n-    \"حدائق ونباتات\",\n-    \"سيارات وقطع غيار\",\n+    \"أجهزة كهربائية منزلية\",\n+    \"أثاث منزلي\",\n+    \"ديكور ومفروشات\",\n+    \"نباتات وزهور\",\n+    \"أدوات حدائق\",\n+    \"قطع غيار سيارات\",\n+    \"إكسسوارات سيارات\",\n     \"أدوات وعدد يدوية\",\n+    \"معدات ورش\",\n     \"مواد بناء وتشييد\",\n-    \"مجوهرات وساعات\",\n+    \"دهانات ومواد التشطيب\",\n+    \"مجوهرات ذهبية\",\n+    \"ساعات وإكسسوارات\",\n     \"هدايا وتحف\",\n-    \"أطفال ومواليد\",\n-    \"حيوانات أليفة ومستلزمات\",\n-    \"موسيقى وآلات موسيقية\",\n-    \"خدمات مهنية\",\n-    \"خدمات تقنية\",\n-    \"خدمات توصيل\",\n-    \"خدمات تنظيف\",\n-    \"خدمات صيانة\",\n+    \"منتجات الأطفال والمواليد\",\n+    \"ملابس وأحذية أطفال\",\n+    \"طعام ومستلزمات حيوانات أليفة\",\n+    \"آلات موسيقية\",\n+    \"معدات صوتية\",\n     \"مواد غذائية عضوية\",\n+    \"منتجات طبيعية وعشبية\",\n     \"حرف يدوية وفنون\",\n-    \"أقمشة وخياطة\",\n-    \"عطور ومواد تجميل\",\n+    \"منتجات تراثية\",\n+    \"أقمشة ومواد خياطة\",\n+    \"أدوات الخياطة والتطريز\",\n+    \"عطور وبخور\",\n+    \"زيوت عطرية طبيعية\",\n+    \"منتجات رمضانية وعيد\",\n+    \"تحف ومقتنيات\",\n     \"أخرى\",\n   ];\n \n   // الفئات المختارة (حد أقصى 6 فئات)\n@@ -1087,24 +1117,37 @@\n     if (workingHours[dayKey] != null) {\n       bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n       workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n \n+      debugPrint(\n+        \"🔄 Toggling day $dayKey from $isCurrentlyOpen to ${!isCurrentlyOpen}\",\n+      );\n+\n       if (!workingHours[dayKey]!['isOpen']) {\n         // If day is being closed\n         workingHours[dayKey]!['opensAt'] = null;\n         workingHours[dayKey]!['closesAt'] = null;\n         if (expandedDayPanel.value == dayKey) {\n           // Close expansion panel if it was this day\n           expandedDayPanel.value = null;\n+          debugPrint(\"🔒 Closing expansion panel for $dayKey\");\n         }\n       } else {\n         // If day is being opened\n         workingHours[dayKey]!['opensAt'] =\n             _lastAppliedOpensAt.value ?? \"09:00 AM\";\n         workingHours[dayKey]!['closesAt'] =\n             _lastAppliedClosesAt.value ?? \"05:00 PM\";\n-        // Optionally, open this panel when day is toggled on if not already open by user interaction\n-        // expandedDayPanel.value = dayKey;\n+\n+        // التوسيع التلقائي عند تفعيل أي يوم\n+        expandedDayPanel.value = dayKey;\n+        debugPrint(\"🔓 Auto-expanding panel for $dayKey\");\n+\n+        // إضافة تأخير بسيط لضمان إعادة بناء UI قبل التوسيع\n+        Future.delayed(Duration(milliseconds: 100), () {\n+          expandedDayPanel.refresh();\n+          debugPrint(\"🔄 Refreshed expansion panel state\");\n+        });\n       }\n       workingHours.refresh();\n     }\n   }\n@@ -1350,20 +1393,384 @@\n   void onMapCreated(GoogleMapController controller) {\n     mapController = controller;\n   }\n \n+  /// وظيفة محسنة لفتح منتقي الموقع مع تحديد الموقع الحالي\n   Future<void> openLocationPickerScreen(BuildContext context) async {\n+    LatLng? initialLocation = shopLocation.value;\n+\n+    // إذا لم يكن هناك موقع محفوظ، جرب الحصول على الموقع الحالي\n+    if (initialLocation == null) {\n+      try {\n+        isLocationLoading.value = true;\n+        Position currentPosition = await _determinePosition();\n+        initialLocation = LatLng(\n+          currentPosition.latitude,\n+          currentPosition.longitude,\n+        );\n+        debugPrint(\n+          \"✅ Current location obtained: ${initialLocation.latitude}, ${initialLocation.longitude}\",\n+        );\n+      } catch (e) {\n+        debugPrint(\"⚠️ Could not get current location: $e\");\n+        // استخدم موقع افتراضي في بغداد إذا فشل تحديد الموقع الحالي\n+        initialLocation = const LatLng(33.3152, 44.3661);\n+      } finally {\n+        isLocationLoading.value = false;\n+      }\n+    }\n+\n     final LatLng? result = await Get.to<LatLng>(\n-      () => LocationPickerScreen(initialLocation: shopLocation.value),\n+      () => LocationPickerScreen(initialLocation: initialLocation),\n     );\n+\n     if (result != null) {\n       shopLocation.value = result;\n       await _getAddressFromLatLng(result);\n       // Optionally move camera on the small map if it's visible and controller is available\n       mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n     }\n   }\n \n+  /// وظيفة لإظهار منتقي موقع محسن مع تأكيد الموقع\n+  Future<void> showEnhancedLocationPicker(BuildContext context) async {\n+    LatLng? initialLocation;\n+\n+    // إذا كان هناك موقع محدد مسبقاً، استخدمه كنقطة بداية\n+    if (shopLocation.value != null) {\n+      initialLocation = shopLocation.value!;\n+      tempSelectedLocation.value =\n+          shopLocation.value; // تعيين الموقع المؤقت للموقع المحدد سابقاً\n+      showLocationConfirmation.value = true; // إظهار تأكيد الموقع مباشرة\n+      debugPrint(\n+        \"🔄 Starting with previously selected location: ${initialLocation.latitude}, ${initialLocation.longitude}\",\n+      );\n+    } else {\n+      // الحصول على الموقع الحالي للمستخدم كنقطة بداية\n+      try {\n+        isLocationLoading.value = true;\n+        Position position = await _determinePosition();\n+        initialLocation = LatLng(position.latitude, position.longitude);\n+        debugPrint(\n+          \"✅ Starting with current user location: ${initialLocation.latitude}, ${initialLocation.longitude}\",\n+        );\n+      } catch (e) {\n+        debugPrint(\"⚠️ Could not get current location: $e\");\n+        initialLocation = const LatLng(33.3152, 44.3661); // بغداد كموقع افتراضي\n+      } finally {\n+        isLocationLoading.value = false;\n+      }\n+    }\n+\n+    // عرض dialog مخصص للخريطة\n+    await Get.dialog(\n+      Dialog(\n+        backgroundColor: Colors.transparent,\n+        insetPadding: EdgeInsets.all(10),\n+        child: Container(\n+          height: Get.height * 0.8,\n+          width: Get.width * 0.95,\n+          decoration: BoxDecoration(\n+            color: Colors.white,\n+            borderRadius: BorderRadius.circular(20),\n+          ),\n+          child: Column(\n+            children: [\n+              // Header\n+              Container(\n+                padding: EdgeInsets.all(20),\n+                decoration: BoxDecoration(\n+                  gradient: LinearGradient(\n+                    colors: [Color(0xFF6366F1), Color(0xFF8B5CF6)],\n+                    begin: Alignment.centerLeft,\n+                    end: Alignment.centerRight,\n+                  ),\n+                  borderRadius: BorderRadius.only(\n+                    topLeft: Radius.circular(20),\n+                    topRight: Radius.circular(20),\n+                  ),\n+                ),\n+                child: Row(\n+                  children: [\n+                    Icon(\n+                      Icons.location_on_rounded,\n+                      color: Colors.white,\n+                      size: 24,\n+                    ),\n+                    SizedBox(width: 12),\n+                    Expanded(\n+                      child: Text(\n+                        'اختر موقع المتجر',\n+                        style: TextStyle(\n+                          fontSize: 18,\n+                          fontWeight: FontWeight.bold,\n+                          color: Colors.white,\n+                        ),\n+                      ),\n+                    ),\n+                    GestureDetector(\n+                      onTap: () => Get.back(),\n+                      child: Container(\n+                        padding: EdgeInsets.all(8),\n+                        decoration: BoxDecoration(\n+                          color: Colors.white.withOpacity(0.2),\n+                          shape: BoxShape.circle,\n+                        ),\n+                        child: Icon(\n+                          Icons.close_rounded,\n+                          color: Colors.white,\n+                          size: 20,\n+                        ),\n+                      ),\n+                    ),\n+                  ],\n+                ),\n+              ),\n+\n+              // Instructions\n+              Container(\n+                padding: EdgeInsets.all(16),\n+                color: Color(0xFFF8FAFC),\n+                child: Row(\n+                  children: [\n+                    Icon(\n+                      Icons.info_outline,\n+                      color: Color(0xFF6366F1),\n+                      size: 20,\n+                    ),\n+                    SizedBox(width: 8),\n+                    Expanded(\n+                      child: Text(\n+                        'اضغط على الخريطة لاختيار موقع متجرك بدقة',\n+                        style: TextStyle(\n+                          fontSize: 14,\n+                          color: Color(0xFF6B7280),\n+                          fontWeight: FontWeight.w500,\n+                        ),\n+                      ),\n+                    ),\n+                  ],\n+                ),\n+              ),\n+\n+              // Map\n+              Expanded(\n+                child: Obx(\n+                  () => Stack(\n+                    children: [\n+                      GoogleMap(\n+                        initialCameraPosition: CameraPosition(\n+                          target: initialLocation!,\n+                          zoom: 15,\n+                        ),\n+                        onTap: (latLng) {\n+                          tempSelectedLocation.value = latLng;\n+                          showLocationConfirmation.value = true;\n+                          _getAddressFromLatLng(latLng); // لتحديث النص\n+                        },\n+                        markers: _buildLocationMarkers(\n+                          initialLocation,\n+                          shopLocation.value == null,\n+                        ),\n+                        myLocationEnabled: true,\n+                        myLocationButtonEnabled: true,\n+                        mapType: MapType.normal,\n+                        compassEnabled: true,\n+                        zoomControlsEnabled: false,\n+                      ),\n+\n+                      // Location confirmation overlay\n+                      if (showLocationConfirmation.value)\n+                        _buildLocationConfirmationOverlay(context),\n+                    ],\n+                  ),\n+                ),\n+              ),\n+            ],\n+          ),\n+        ),\n+      ),\n+      barrierDismissible: false,\n+    );\n+\n+    // تنظيف المتغيرات المؤقتة بعد إغلاق الـ dialog\n+    tempSelectedLocation.value = null;\n+    showLocationConfirmation.value = false;\n+  }\n+\n+  /// بناء المؤشرات على الخريطة\n+  Set<Marker> _buildLocationMarkers(\n+    LatLng? initialLocation, [\n+    bool showCurrentLocationMarker = true,\n+  ]) {\n+    Set<Marker> markers = {};\n+\n+    // مؤشر الموقع الحالي للمستخدم (فقط إذا لم يكن هناك موقع محدد مسبقاً)\n+    if (initialLocation != null && showCurrentLocationMarker) {\n+      markers.add(\n+        Marker(\n+          markerId: MarkerId('current_location'),\n+          position: initialLocation,\n+          icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueBlue),\n+          infoWindow: InfoWindow(\n+            title: 'موقعك الحالي',\n+            snippet: 'اضغط على الخريطة لاختيار موقع المتجر',\n+          ),\n+        ),\n+      );\n+    }\n+\n+    // مؤشر الموقع المؤقت المختار\n+    if (tempSelectedLocation.value != null) {\n+      markers.add(\n+        Marker(\n+          markerId: MarkerId('selected_location'),\n+          position: tempSelectedLocation.value!,\n+          icon: BitmapDescriptor.defaultMarkerWithHue(BitmapDescriptor.hueRed),\n+          infoWindow: InfoWindow(\n+            title: 'موقع المتجر المختار',\n+            snippet: 'اضغط على \"تأكيد الموقع\" للمتابعة',\n+          ),\n+        ),\n+      );\n+    }\n+\n+    return markers;\n+  }\n+\n+  /// بناء overlay تأكيد الموقع\n+  Widget _buildLocationConfirmationOverlay(BuildContext context) {\n+    return Positioned(\n+      bottom: 20,\n+      left: 20,\n+      right: 20,\n+      child: Container(\n+        padding: EdgeInsets.all(20),\n+        decoration: BoxDecoration(\n+          color: Colors.white,\n+          borderRadius: BorderRadius.circular(16),\n+          boxShadow: [\n+            BoxShadow(\n+              color: Colors.black.withOpacity(0.1),\n+              spreadRadius: 0,\n+              blurRadius: 20,\n+              offset: Offset(0, 4),\n+            ),\n+          ],\n+        ),\n+        child: Column(\n+          mainAxisSize: MainAxisSize.min,\n+          children: [\n+            Row(\n+              children: [\n+                Container(\n+                  padding: EdgeInsets.all(8),\n+                  decoration: BoxDecoration(\n+                    color: Color(0xFF10B981).withOpacity(0.1),\n+                    borderRadius: BorderRadius.circular(8),\n+                  ),\n+                  child: Icon(\n+                    Icons.location_on_rounded,\n+                    color: Color(0xFF10B981),\n+                    size: 20,\n+                  ),\n+                ),\n+                SizedBox(width: 12),\n+                Expanded(\n+                  child: Column(\n+                    crossAxisAlignment: CrossAxisAlignment.start,\n+                    children: [\n+                      Text(\n+                        'موقع مختار',\n+                        style: TextStyle(\n+                          fontSize: 16,\n+                          fontWeight: FontWeight.w600,\n+                          color: Color(0xFF1F2937),\n+                        ),\n+                      ),\n+                      Obx(\n+                        () => Text(\n+                          shopAddressText.value.isNotEmpty\n+                              ? shopAddressText.value\n+                              : 'جاري تحديد العنوان...',\n+                          style: TextStyle(\n+                            fontSize: 12,\n+                            color: Color(0xFF6B7280),\n+                          ),\n+                          maxLines: 2,\n+                          overflow: TextOverflow.ellipsis,\n+                        ),\n+                      ),\n+                    ],\n+                  ),\n+                ),\n+              ],\n+            ),\n+            SizedBox(height: 16),\n+            Row(\n+              children: [\n+                Expanded(\n+                  child: OutlinedButton(\n+                    onPressed: () {\n+                      tempSelectedLocation.value = null;\n+                      showLocationConfirmation.value = false;\n+                    },\n+                    style: OutlinedButton.styleFrom(\n+                      foregroundColor: Color(0xFF6B7280),\n+                      side: BorderSide(color: Color(0xFFE5E7EB)),\n+                      padding: EdgeInsets.symmetric(vertical: 12),\n+                      shape: RoundedRectangleBorder(\n+                        borderRadius: BorderRadius.circular(12),\n+                      ),\n+                    ),\n+                    child: Text('إلغاء'),\n+                  ),\n+                ),\n+                SizedBox(width: 12),\n+                Expanded(\n+                  flex: 2,\n+                  child: ElevatedButton(\n+                    onPressed: () {\n+                      if (tempSelectedLocation.value != null) {\n+                        shopLocation.value = tempSelectedLocation.value;\n+                        Get.back();\n+                        Get.snackbar(\n+                          \"تم التحديد\",\n+                          \"تم اختيار موقع المتجر بنجاح\",\n+                          backgroundColor: Color(0xFF10B981),\n+                          colorText: Colors.white,\n+                          snackPosition: SnackPosition.BOTTOM,\n+                          icon: Icon(Icons.check_circle, color: Colors.white),\n+                        );\n+                      }\n+                    },\n+                    style: ElevatedButton.styleFrom(\n+                      backgroundColor: Color(0xFF10B981),\n+                      foregroundColor: Colors.white,\n+                      padding: EdgeInsets.symmetric(vertical: 12),\n+                      shape: RoundedRectangleBorder(\n+                        borderRadius: BorderRadius.circular(12),\n+                      ),\n+                      elevation: 0,\n+                    ),\n+                    child: Row(\n+                      mainAxisAlignment: MainAxisAlignment.center,\n+                      children: [\n+                        Icon(Icons.check_circle, size: 18),\n+                        SizedBox(width: 8),\n+                        Text('تأكيد الموقع'),\n+                      ],\n+                    ),\n+                  ),\n+                ),\n+              ],\n+            ),\n+          ],\n+        ),\n+      ),\n+    );\n+  }\n+\n   Future<void> _getAddressFromLatLng(LatLng latLng) async {\n     try {\n       List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n         latLng.latitude,\n@@ -1390,10 +1797,11 @@\n       shopAddressText.value = \"خطأ في جلب العنوان\";\n     }\n   }\n \n+  /// الحصول على الموقع الحالي وتحديد موقع المتجر\n   Future<void> tryMoveToCurrentLocation() async {\n-    isLoading.value = true; // Indicate loading for location fetch\n+    isLocationLoading.value = true;\n     update();\n     try {\n       Position currentPosition = await _determinePosition();\n       LatLng newLatLng = LatLng(\n@@ -1402,16 +1810,28 @@\n       );\n       shopLocation.value = newLatLng;\n       await _getAddressFromLatLng(newLatLng);\n       mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n+\n+      Get.snackbar(\n+        \"تم تحديد الموقع\",\n+        \"تم الحصول على موقعك الحالي بنجاح\",\n+        backgroundColor: Color(0xFF10B981),\n+        colorText: Colors.white,\n+        snackPosition: SnackPosition.BOTTOM,\n+        icon: Icon(Icons.my_location, color: Colors.white),\n+      );\n     } catch (e) {\n       Get.snackbar(\n-        \"خطأ\",\n+        \"خطأ في الموقع\",\n         \"فشل في تحديد الموقع الحالي: ${e.toString()}\",\n+        backgroundColor: Color(0xFFEF4444),\n+        colorText: Colors.white,\n         snackPosition: SnackPosition.BOTTOM,\n+        icon: Icon(Icons.error_outline, color: Colors.white),\n       );\n     } finally {\n-      isLoading.value = false;\n+      isLocationLoading.value = false;\n       update();\n     }\n   }\n \n"
                },
                {
                    "date": 1752700868696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -867,8 +867,9 @@\n         isActiveBySeller: true, // نشط مبدئيًا\n         isPhoneNumberVerified: true, // تم التحقق من الهاتف في هذه المرحلة\n         averageRating: 0.0,\n         numberOfRatings: 0,\n+         trustScore: 50.0 ,\n         sellerType: _sellerTypeFromAuth, // من SellerAuthController\n         registrationCompleted: true, // اكتمل التسجيل في هذه المرحلة\n         createdAt:\n             Timestamp.now(), // سيتم استبداله بـ FieldValue.serverTimestamp() أدناه\n@@ -907,8 +908,9 @@\n \n       debugPrint(\"💾 Saving seller data to Firestore...\");\n       debugPrint(\"💾 Document ID: ${currentUser.uid}\");\n       debugPrint(\"💾 Collection: ${FirebaseX.collectionSeller}\");\n+      debugPrint(\"🏆 Trust Score: 50.0 (auto-assigned to new seller)\");\n \n       await _firestore\n           .collection(FirebaseX.collectionSeller)\n           .doc(currentUser.uid)\n"
                },
                {
                    "date": 1752837553514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -426,23 +426,20 @@\n         \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n       );\n       debugPrint(\"FirebaseAuth instance: $_auth\");\n \n-      // تفعيل reCAPTCHA للـ iOS صراحة\n+      // تفعيل reCAPTCHA للـ iOS للجميع\n       if (Platform.isIOS) {\n         debugPrint(\"Setting up reCAPTCHA for iOS...\");\n         try {\n-          // إعدادات مختلفة للاختبار\n-          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n-\n           await _auth.setSettings(\n             appVerificationDisabledForTesting:\n-                isTestNumber, // للرقم التجريبي فقط\n-            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA للأرقام الحقيقية فقط\n+                false, // إزالة دعم الأرقام التجريبية\n+            forceRecaptchaFlow: true, // reCAPTCHA للجميع\n           );\n \n           debugPrint(\"✅ Firebase Auth settings configured for iOS\");\n-          debugPrint(\"📱 Test number mode: $isTestNumber\");\n+          debugPrint(\"✅ Firebase Auth settings configured for iOS\");\n \n           // إضافة تأخير قصير للسماح للإعدادات بالتطبيق\n           await Future.delayed(const Duration(milliseconds: 500));\n         } catch (e) {\n@@ -867,9 +864,9 @@\n         isActiveBySeller: true, // نشط مبدئيًا\n         isPhoneNumberVerified: true, // تم التحقق من الهاتف في هذه المرحلة\n         averageRating: 0.0,\n         numberOfRatings: 0,\n-         trustScore: 50.0 ,\n+        trustScore: 50.0,\n         sellerType: _sellerTypeFromAuth, // من SellerAuthController\n         registrationCompleted: true, // اكتمل التسجيل في هذه المرحلة\n         createdAt:\n             Timestamp.now(), // سيتم استبداله بـ FieldValue.serverTimestamp() أدناه\n"
                }
            ],
            "date": 1752491126687,
            "name": "Commit-0",
            "content": "import 'dart:io';\nimport 'dart:async';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:codora/%D8%A7%D9%84%D9%83%D9%88%D8%AF%20%D8%A7%D9%84%D8%AE%D8%A7%D8%B5%20%D8%A8%D8%AA%D8%B7%D8%A8%D9%8A%D9%82%20%D8%A7%D9%84%D8%A8%D8%A7%D8%A6%D8%B9/seller_app_auth/controllers/seller_auth_controller.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:firebase_core/firebase_core.dart';\nimport 'package:flutter/material.dart';\nimport 'package:geolocator/geolocator.dart';\nimport 'package:get/get.dart';\nimport 'package:get_storage/get_storage.dart';\nimport 'package:google_maps_flutter/google_maps_flutter.dart';\nimport 'package:image_picker/image_picker.dart';\nimport 'package:intl/intl.dart'; // For DateFormat\nimport 'package:geocoding/geocoding.dart' as geo;\n\nimport '../../../XXX/xxx_firebase.dart';\nimport '../../../Model/SellerModel.dart';\nimport '../../ui/seller_main_screen.dart';\nimport '../ui/OtpVerificationScreen.dart';\nimport '../ui/LocationPickerScreen.dart';\n\nclass SellerRegistrationController extends GetxController {\n  final GlobalKey<FormState> formKey = GlobalKey<FormState>();\n  RxDouble currentPositionAccuracy = 0.0.obs;\n\n  // --- Firebase Instances ---\n  final FirebaseAuth _auth = FirebaseAuth.instance;\n  final FirebaseFirestore _firestore = FirebaseFirestore.instance;\n  final FirebaseStorage _storage = FirebaseStorage.instance;\n  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;\n  final RxString verificationId = ''.obs; // To store Firebase's verification ID\n\n  // iOS-specific Firebase Storage handler\n  late IOSFirebaseStorageHandler _iosStorageHandler;\n\n  // ==========================================================================\n  // ==========================================================================\n  // ==========================================================================\n\n  // لإضافة نوع البائع\n  String? _sellerTypeFromAuth; // سيتم جلب هذا من SellerAuthController\n\n  final Rxn<int> resendToken = Rxn<int>(null); // For resending OTP\n  final TextEditingController otpController = TextEditingController();\n  final RxBool isOtpSending = false.obs; // Loading state for OTP sending\n  final RxBool isOtpVerifying = false.obs; // Loading state for OTP verification\n  Map<String, dynamic>? _tempSellerDataForSubmission;\n  File? _tempSellerProfileImageFile;\n  File? _tempShopFrontImageFile;\n\n  // --- Text Editing Controllers ---\n  final TextEditingController sellerNameController = TextEditingController();\n  final TextEditingController shopNameController = TextEditingController();\n  final TextEditingController shopPhoneNumberController =\n      TextEditingController();\n  final TextEditingController shopDescriptionController =\n      TextEditingController();\n  // Add more controllers for other text fields like commercial reg no., etc.\n\n  // --- Image Pickers ---\n  final ImagePicker _picker = ImagePicker();\n  final Rxn<File> sellerProfileImageFile = Rxn<File>(null);\n  final Rxn<File> shopFrontImageFile = Rxn<File>(null);\n\n  // --- Location ---\n  final Rxn<LatLng> shopLocation = Rxn<LatLng>(null);\n  final RxString shopAddressText = ''.obs;\n  GoogleMapController? mapController;\n\n  // --- Working Hours ---\n  final List<String> dayKeys = [\n    \"sunday_en\",\n    \"monday_en\",\n    \"tuesday_en\",\n    \"wednesday_en\",\n    \"thursday_en\",\n    \"friday_en\",\n    \"saturday_en\",\n  ];\n  final RxnString expandedDayPanel = RxnString(null); // For ExpansionPanelList\n\n  final RxMap<String, Map<String, dynamic>> workingHours =\n      <String, Map<String, dynamic>>{\n        \"sunday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"الأحد\",\n        },\n        \"monday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"الاثنين\",\n        },\n        \"tuesday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"الثلاثاء\",\n        },\n        \"wednesday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"الأربعاء\",\n        },\n        \"thursday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"الخميس\",\n        },\n        \"friday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"الجمعة\",\n        },\n        \"saturday_en\": {\n          'isOpen': false,\n          'opensAt': null,\n          'closesAt': null,\n          'name_ar': \"السبت\",\n        },\n      }.obs;\n  final RxnString _lastAppliedOpensAt = RxnString(null);\n  final RxnString _lastAppliedClosesAt = RxnString(null);\n  // --- Main Categories ---\n  // قائمة شاملة بجميع فئات المتاجر الممكنة\n  final List<String> shopCategories = [\n    \"إلكترونيات ومعدات تقنية\",\n    \"ملابس وأزياء\",\n    \"أحذية وحقائب\",\n    \"طعام ومشروبات\",\n    \"منتجات صحية وتجميل\",\n    \"أدوية ومستلزمات طبية\",\n    \"كتب ومواد تعليمية\",\n    \"ألعاب وترفيه\",\n    \"رياضة ولياقة\",\n    \"أدوات منزلية ومطبخ\",\n    \"أثاث وديكور\",\n    \"حدائق ونباتات\",\n    \"سيارات وقطع غيار\",\n    \"أدوات وعدد يدوية\",\n    \"مواد بناء وتشييد\",\n    \"مجوهرات وساعات\",\n    \"هدايا وتحف\",\n    \"أطفال ومواليد\",\n    \"حيوانات أليفة ومستلزمات\",\n    \"موسيقى وآلات موسيقية\",\n    \"خدمات مهنية\",\n    \"خدمات تقنية\",\n    \"خدمات توصيل\",\n    \"خدمات تنظيف\",\n    \"خدمات صيانة\",\n    \"مواد غذائية عضوية\",\n    \"حرف يدوية وفنون\",\n    \"أقمشة وخياطة\",\n    \"عطور ومواد تجميل\",\n    \"أخرى\",\n  ];\n\n  // الفئات المختارة (حد أقصى 6 فئات)\n  final RxList<String> selectedShopCategories = <String>[].obs;\n  final int maxCategoriesAllowed = 6;\n\n  // --- Loading State ---\n  final RxBool isLoading = false.obs;\n\n  @override\n  void onInit() {\n    super.onInit();\n\n    // Initialize iOS-specific storage handler\n    if (Platform.isIOS) {\n      _iosStorageHandler = IOSFirebaseStorageHandler(_storage);\n    }\n\n    // جلب SellerAuthController والحصول على sellerType\n    try {\n      final SellerAuthController authController =\n          Get.find<SellerAuthController>();\n      _sellerTypeFromAuth = authController.sellerType;\n      if (_sellerTypeFromAuth != null) {\n        debugPrint(\n          \"SellerRegistrationController: تم جلب نوع البائع من AuthController: $_sellerTypeFromAuth\",\n        );\n      } else {\n        debugPrint(\n          \"SellerRegistrationController: لم يتم العثور على sellerType في AuthController. قد يحتاج المستخدم للعودة واختيار النوع.\",\n        );\n        // يمكنك هنا إضافة منطق لتوجيه المستخدم إذا كان sellerType ضروريًا ولا يمكن أن يكون null\n        // مثال: Get.offAll(() => SellerTypeSelectionScreen()); أو عرض رسالة خطأ\n      }\n    } catch (e) {\n      debugPrint(\n        \"SellerRegistrationController: خطأ أثناء محاولة العثور على SellerAuthController أو الوصول إلى sellerType: $e\",\n      );\n      // معالجة الخطأ، ربما توجيه المستخدم أو عرض رسالة\n    }\n  }\n\n  @override\n  void onClose() {\n    sellerNameController.dispose();\n    shopNameController.dispose();\n    shopPhoneNumberController.dispose();\n    shopDescriptionController.dispose();\n    mapController?.dispose();\n    otpController.dispose();\n    super.onClose();\n  }\n\n  void removeImage({required bool isProfileImage}) {\n    if (isProfileImage) {\n      sellerProfileImageFile.value = null;\n    } else {\n      shopFrontImageFile.value = null;\n    }\n    update(); // For GetBuilder if used, or just rely on Obx for reactive updates\n  }\n\n  Future<void> initiatePhoneVerificationAndCollectData() async {\n    debugPrint(\"🚀 initiatePhoneVerificationAndCollectData called\");\n    debugPrint(\"Form validation starting...\");\n\n    if (!formKey.currentState!.validate()) {\n      debugPrint(\"❌ Form validation failed\");\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى ملء جميع الحقول المطلوبة بشكل صحيح.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"✅ Form validation passed\");\n\n    // --- Add all your previous validations ---\n    debugPrint(\"Checking profile image...\");\n    if (sellerProfileImageFile.value == null) {\n      debugPrint(\"❌ No profile image selected\");\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى اختيار صورة شخصية.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"✅ Profile image validation passed\");\n\n    debugPrint(\"Checking shop front image...\");\n    if (shopFrontImageFile.value == null) {\n      debugPrint(\"❌ No shop front image selected\");\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى اختيار صورة لواجهة المحل.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"✅ Shop front image validation passed\");\n\n    debugPrint(\"Checking shop location...\");\n    if (shopLocation.value == null) {\n      debugPrint(\"❌ No shop location selected\");\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى تحديد موقع المحل.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"✅ Shop location validation passed\");\n\n    debugPrint(\"Checking shop category...\");\n    if (selectedShopCategories.isEmpty) {\n      debugPrint(\"❌ No shop categories selected\");\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى اختيار فئة واحدة على الأقل للمتجر.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\n      \"✅ Shop categories validation passed: ${selectedShopCategories.length} categories selected\",\n    );\n\n    // التحقق إذا كان _sellerTypeFromAuth فارغًا قبل المتابعة (إذا كان إلزاميًا)\n    debugPrint(\"Checking seller type...\");\n    if (_sellerTypeFromAuth == null || _sellerTypeFromAuth!.isEmpty) {\n      debugPrint(\"❌ No seller type selected\");\n      Get.snackbar(\n        \"خطأ\",\n        \"لم يتم تحديد نوع البائع. يرجى الرجوع واختيار نوع البائع.\",\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"✅ Seller type validation passed: $_sellerTypeFromAuth\");\n\n    debugPrint(\"Checking working hours...\");\n    bool workingHoursValid = true;\n    String firstInvalidDay = \"\";\n    workingHours.forEach((key, value) {\n      if ((value['isOpen'] == true) &&\n          (value['opensAt'] == null || value['closesAt'] == null)) {\n        workingHoursValid = false;\n        firstInvalidDay = value['name_ar'] as String;\n        return;\n      }\n    });\n    if (!workingHoursValid) {\n      debugPrint(\"❌ Working hours validation failed for day: $firstInvalidDay\");\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى تحديد أوقات الفتح والإغلاق لليوم المفتوح: $firstInvalidDay.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"✅ Working hours validation passed\");\n\n    String rawPhoneNumber = shopPhoneNumberController.text.trim();\n    rawPhoneNumber = rawPhoneNumber.replaceAll(RegExp(r'\\s+'), '');\n    if (rawPhoneNumber.startsWith('0')) {\n      rawPhoneNumber = rawPhoneNumber.substring(1);\n    }\n    const String countryCode = \"+964\";\n    final String formattedPhoneNumber = \"$countryCode$rawPhoneNumber\";\n    debugPrint(\"الرقم المدخل الأصلي: ${shopPhoneNumberController.text}\");\n    debugPrint(\n      \"الرقم بعد إزالة المسافات والصفر وإضافة رمز الدولة: $formattedPhoneNumber\",\n    );\n\n    final RegExp iraqiPhoneNumberRegExp = RegExp(r'^\\+9647[3-9]\\d{8}$');\n    debugPrint(\"Checking phone number validation: $formattedPhoneNumber\");\n    if (!iraqiPhoneNumberRegExp.hasMatch(formattedPhoneNumber)) {\n      debugPrint(\"Phone number validation failed for: $formattedPhoneNumber\");\n      Get.snackbar(\n        \"رقم هاتف غير صالح\",\n        \"الرجاء التأكد من إدخال رقم هاتف عراقي صحيح.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n    debugPrint(\"Phone number validation passed\");\n\n    // ---- Set loading states ----\n    debugPrint(\"Setting loading states...\");\n    isOtpSending.value = true;\n    isLoading.value = true;\n    update();\n    debugPrint(\"Loading states set successfully\");\n\n    try {\n      debugPrint(\"Preparing temp data for submission...\");\n      _tempSellerProfileImageFile = sellerProfileImageFile.value;\n      _tempShopFrontImageFile = shopFrontImageFile.value;\n      _tempSellerDataForSubmission = {\n        \"sellerName\": sellerNameController.text.trim(),\n        \"shopName\": shopNameController.text.trim(),\n        \"shopPhoneNumber\": shopPhoneNumberController.text.trim(),\n        \"shopDescription\": shopDescriptionController.text.trim(),\n        \"location\": GeoPoint(\n          shopLocation.value!.latitude,\n          shopLocation.value!.longitude,\n        ),\n        \"shopAddressText\": shopAddressText.value,\n        \"shopCategories\": selectedShopCategories.toList(),\n        \"workingHours\": Map<String, Map<String, dynamic>>.from(workingHours),\n        \"streetAddress\": streetAddressController.text.trim(),\n      };\n      debugPrint(\"Temp data prepared successfully\");\n\n      debugPrint(\n        \"Starting Firebase phone verification for: $formattedPhoneNumber\",\n      );\n      debugPrint(\"FirebaseAuth instance: $_auth\");\n\n      // تفعيل reCAPTCHA للـ iOS صراحة\n      if (Platform.isIOS) {\n        debugPrint(\"Setting up reCAPTCHA for iOS...\");\n        try {\n          // إعدادات مختلفة للاختبار\n          bool isTestNumber = formattedPhoneNumber == \"+9647803346793\";\n\n          await _auth.setSettings(\n            appVerificationDisabledForTesting:\n                isTestNumber, // للرقم التجريبي فقط\n            forceRecaptchaFlow: !isTestNumber, // reCAPTCHA للأرقام الحقيقية فقط\n          );\n\n          debugPrint(\"✅ Firebase Auth settings configured for iOS\");\n          debugPrint(\"📱 Test number mode: $isTestNumber\");\n\n          // إضافة تأخير قصير للسماح للإعدادات بالتطبيق\n          await Future.delayed(const Duration(milliseconds: 500));\n        } catch (e) {\n          debugPrint(\"⚠️ Error setting Firebase Auth settings: $e\");\n          // في حالة فشل إعدادات reCAPTCHA، جرب بدونها\n          debugPrint(\"🔄 Trying without forced reCAPTCHA...\");\n        }\n      }\n\n      // إضافة timeout إضافي للتأكد من عمل الـ callbacks\n      Timer callbackTimeoutTimer = Timer(const Duration(seconds: 30), () {\n        if (isOtpSending.value || isLoading.value) {\n          debugPrint(\"⚠️ Callback timeout - reCAPTCHA may not have appeared\");\n          debugPrint(\"⚠️ This usually means Firebase Console settings issue\");\n          isOtpSending.value = false;\n          isLoading.value = false;\n          isOtpVerifying.value = false;\n          update();\n          Get.snackbar(\n            \"مشكلة في التحقق\",\n            \"لم تظهر صفحة التحقق. تحقق من إعدادات Firebase أو جرب رقماً آخر.\",\n            backgroundColor: Colors.orange.shade400,\n            colorText: Colors.white,\n            snackPosition: SnackPosition.BOTTOM,\n            duration: const Duration(seconds: 5),\n          );\n        }\n      });\n\n      await _auth.verifyPhoneNumber(\n        phoneNumber: formattedPhoneNumber,\n        forceResendingToken: resendToken.value,\n        verificationCompleted: (PhoneAuthCredential credential) async {\n          debugPrint(\"🎉 VERIFICATION COMPLETED CALLBACK TRIGGERED\");\n          debugPrint(\n            \"Phone auto-verified. Credential SMS code (if available): ${credential.smsCode}\",\n          );\n\n          // إلغاء timeout timer\n          callbackTimeoutTimer.cancel();\n\n          // التأكد من تحديث الحالة قبل المتابعة\n          isOtpSending.value = false;\n          isLoading.value = true;\n          isOtpVerifying.value = true;\n          update();\n\n          // إضافة تأخير قصير للسماح للـ UI بالتحديث على iOS\n          if (Platform.isIOS) {\n            await Future.delayed(const Duration(milliseconds: 100));\n          }\n\n          await _finalizeSellerRegistration(isAutoVerified: true);\n        },\n        verificationFailed: (FirebaseAuthException e) {\n          debugPrint(\"❌ VERIFICATION FAILED CALLBACK TRIGGERED\");\n          debugPrint(\"Phone verification failed: ${e.code} - ${e.message}\");\n          debugPrint(\"Full error: ${e.toString()}\");\n\n          // إلغاء timeout timer\n          callbackTimeoutTimer.cancel();\n\n          // التأكد من إعادة تعيين جميع الحالات\n          isOtpSending.value = false;\n          isLoading.value = false;\n          isOtpVerifying.value = false;\n          update();\n\n          String errorMessage = \"فشل التحقق من رقم الهاتف.\";\n          if (e.code == 'invalid-phone-number') {\n            errorMessage =\n                \"رقم الهاتف $formattedPhoneNumber الذي أدخلته غير صالح.\";\n          } else if (e.code == 'too-many-requests') {\n            errorMessage =\n                \"تم إرسال عدد كبير جدا من الطلبات. حاول مرة أخرى لاحقًا.\";\n          } else if (e.code == 'network-request-failed') {\n            errorMessage =\n                \"مشكلة في الاتصال بالإنترنت. يرجى التحقق من الاتصال والمحاولة مرة أخرى.\";\n          }\n          Get.snackbar(\n            \"خطأ\",\n            errorMessage,\n            backgroundColor: Colors.red.shade400,\n            colorText: Colors.white,\n            snackPosition: SnackPosition.BOTTOM,\n          );\n        },\n        codeSent: (String verId, int? resendTok) async {\n          debugPrint(\"📱 CODE SENT CALLBACK TRIGGERED\");\n          debugPrint(\n            \"OTP code sent. Verification ID: $verId, Resend Token: $resendTok\",\n          );\n\n          // إلغاء timeout timer\n          callbackTimeoutTimer.cancel();\n\n          isOtpSending.value = false; // OTP sending part is done\n          // isLoading remains true as we are waiting for OTP input\n          update();\n\n          verificationId.value = verId;\n          resendToken.value = resendTok;\n\n          // إضافة تأخير قصير على iOS للسماح للـ UI بالتحديث قبل التنقل\n          if (Platform.isIOS) {\n            await Future.delayed(const Duration(milliseconds: 200));\n          }\n\n          // التأكد من أن التنقل يحدث على الـ main thread\n          WidgetsBinding.instance.addPostFrameCallback((_) {\n            debugPrint(\"Navigating to OTP verification screen...\");\n            Get.to(() => OtpVerificationScreen());\n          });\n        },\n        codeAutoRetrievalTimeout: (String verId) {\n          debugPrint(\"⏰ CODE AUTO RETRIEVAL TIMEOUT CALLBACK TRIGGERED\");\n          debugPrint(\"OTP auto-retrieval timed out. Verification ID: $verId\");\n          verificationId.value = verId;\n          // إعادة تعيين isOtpSending في حال timeout على iOS\n          if (Platform.isIOS) {\n            isOtpSending.value = false;\n            update();\n          }\n        },\n        timeout:\n            Platform.isIOS\n                ? const Duration(seconds: 60) // مدة أقصر على iOS\n                : const Duration(seconds: 120), // مدة أطول على Android\n      );\n      debugPrint(\"✅ verifyPhoneNumber call completed successfully\");\n    } catch (e) {\n      debugPrint(\"🚨 EXCEPTION CAUGHT IN verifyPhoneNumber\");\n      debugPrint(\"Exception type: ${e.runtimeType}\");\n      debugPrint(\"Exception details: $e\");\n\n      // التأكد من إعادة تعيين جميع الحالات في حالة الخطأ\n      isOtpSending.value = false;\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      update();\n\n      String errorMessage = \"حدث خطأ غير متوقع أثناء بدء التحقق من الهاتف.\";\n\n      // معالجة أخطاء محددة\n      if (e.toString().contains('network')) {\n        errorMessage = \"مشكلة في الشبكة. يرجى التحقق من الاتصال بالإنترنت.\";\n      } else if (e.toString().contains('too-many-requests')) {\n        errorMessage = \"تم إرسال عدد كبير من الطلبات. يرجى المحاولة لاحقاً.\";\n      }\n\n      Get.snackbar(\n        \"خطأ\",\n        errorMessage,\n        backgroundColor: Colors.red.shade500,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<void> verifyOtpAndFinalize(String otpCode) async {\n    if (otpCode.isEmpty || otpCode.length < 6) {\n      Get.snackbar(\n        \"خطأ\",\n        \"يرجى إدخال رمز OTP الصحيح المكون من 6 أرقام.\",\n        backgroundColor: Colors.orange.shade300,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      return;\n    }\n\n    isOtpVerifying.value = true;\n    isLoading.value =\n        true; // isLoading should ideally be true from the previous step\n    update();\n\n    try {\n      PhoneAuthCredential credential = PhoneAuthProvider.credential(\n        verificationId: verificationId.value,\n        smsCode: otpCode,\n      );\n\n      // **** خطوة التحقق الفعلية من الـ Credential هنا ****\n      final User? currentUser = _auth.currentUser;\n      if (currentUser == null) {\n        throw FirebaseAuthException(\n          code: 'no-current-user',\n          message: 'No user is currently signed in.',\n        );\n      }\n\n      // محاولة ربط الـ Credential أو التحقق من OTP\n      try {\n        await currentUser.linkWithCredential(credential);\n        debugPrint(\"Phone credential linked successfully.\");\n      } catch (linkError) {\n        if (linkError is FirebaseAuthException &&\n            linkError.code == 'provider-already-linked') {\n          debugPrint(\n            \"Phone provider already linked, verifying OTP directly...\",\n          );\n          // إذا كان المزود مرتبط بالفعل، نتحقق من صحة OTP فقط\n          await _auth.signInWithCredential(credential);\n          debugPrint(\n            \"OTP verified successfully with existing linked provider.\",\n          );\n        } else {\n          rethrow; // إعادة طرح أي خطأ آخر\n        }\n      }\n\n      // إلغاء safety timeout لأن العملية نجحت\n      _cancelSafetyTimeout();\n\n      // إذا نجح الربط أو التحقق، قم بإنهاء التسجيل\n      await _finalizeSellerRegistration(isOtpNowVerified: true);\n    } on FirebaseAuthException catch (e) {\n      isOtpVerifying.value = false;\n      isLoading.value = false;\n      update();\n      debugPrint(\n        \"FirebaseAuthException during OTP verification: ${e.code} - ${e.message}\",\n      );\n      String errorMessage = \"فشل التحقق من رمز OTP.\";\n      if (e.code == 'invalid-verification-code' ||\n          e.code == 'invalid-credential') {\n        errorMessage = \"رمز OTP الذي أدخلته غير صحيح.\";\n      } else if (e.code == 'session-expired') {\n        errorMessage = \"انتهت صلاحية جلسة التحقق. يرجى طلب رمز جديد.\";\n      } else if (e.code == 'credential-already-in-use') {\n        // هذه حالة خاصة: الرقم مرتبط بالفعل بحساب آخر. أو إذا كان مرتبطًا بنفس الحساب، يمكن اعتبارها نجاحًا.\n        // هنا، نفترض أننا إذا وصلنا لهذه النقطة، والرقم مرتبط بنفس المستخدم، فهذا جيد.\n        // ولكن إذا كان مرتبطًا بمستخدم مختلف، فهذه مشكلة.\n        // للحفاظ على البساطة، سنعتبرها خطأ عام الآن، ولكن يمكن تحسين هذا.\n        // أو إذا كان هذا يعني أنه مرتبط بالفعل بهذا المستخدم، يمكن المتابعة.\n        // الخيار الأبسط هو معالجته كخطأ إذا لم تكن متأكدًا من كيفية التعامل مع هذا الحساب.\n        // إذا كان يمكن أن يكون مرتبطًا بالفعل بهذا المستخدم، يمكن استدعاء _finalizeSellerRegistration هنا أيضًا.\n        // For now, treat as a specific error message or proceed if logic allows\n        debugPrint(\n          \"Credential already in use. Assuming for this user is okay or needs specific handling.\",\n        );\n        // إذا كان الرقم مرتبطًا بالفعل بنفس المستخدم، قد يكون هذا هو المسار الصحيح\n        // await _finalizeSellerRegistration(isOtpNowVerified: true);\n        // Get.snackbar(\"معلومة\", \"رقم الهاتف هذا تم التحقق منه بالفعل لهذا الحساب.\", snackPosition: SnackPosition.BOTTOM);\n        // return;\n        errorMessage =\n            \"رقم الهاتف هذا مرتبط بالفعل. إذا كان هذا حسابك، يمكنك المتابعة أو الاتصال بالدعم.\";\n      } else if (e.code == 'no-current-user') {\n        errorMessage =\n            \"انتهت جلسة المستخدم. يرجى تسجيل الدخول مرة أخرى والمحاولة.\";\n        // يمكنك هنا توجيه المستخدم لصفحة الدخول\n      }\n      Get.snackbar(\n        \"خطأ\",\n        errorMessage,\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    } catch (e) {\n      isOtpVerifying.value = false;\n      isLoading.value = false;\n      update();\n      debugPrint(\"Generic error verifying OTP: $e\");\n      Get.snackbar(\n        \"خطأ\",\n        \"حدث خطأ غير متوقع أثناء التحقق من الرمز.\",\n        backgroundColor: Colors.red.shade500,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<void> _finalizeSellerRegistration({\n    bool isAutoVerified = false,\n    bool isOtpNowVerified = false,\n  }) async {\n    debugPrint(\"🔧 _finalizeSellerRegistration called\");\n    debugPrint(\n      \"🔧 isAutoVerified: $isAutoVerified, isOtpNowVerified: $isOtpNowVerified\",\n    );\n\n    // إذا لم يتم التحقق تلقائيًا ولم يتم التحقق الآن (من verifyOtpAndFinalize)، فلا تتابع\n    if (!isAutoVerified && !isOtpNowVerified) {\n      debugPrint(\"❌ Neither auto verified nor OTP verified - stopping\");\n      Get.snackbar(\n        \"خطأ\",\n        \"لم يتم التحقق من صحة رقم الهاتف.\",\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      return;\n    }\n\n    debugPrint(\n      \"✅ Phone verification confirmed, proceeding with registration...\",\n    );\n\n    // Set loading states for this final part\n    isOtpVerifying.value = true;\n    isLoading.value = true;\n    update();\n\n    try {\n      final User? currentUser = _auth.currentUser;\n      if (currentUser == null) {\n        Get.snackbar(\n          \"خطأ\",\n          \"لم يتم العثور على مستخدم حالي. يرجى تسجيل الدخول مرة أخرى.\",\n          backgroundColor: Colors.red.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n        );\n        isLoading.value = false;\n        isOtpVerifying.value = false;\n        // Navigate to login or welcome screen\n        return;\n      }\n\n      String? sellerProfileImageUrl;\n      String? shopFrontImageUrl;\n\n      // iOS-specific: Wait for Firebase to be fully ready\n      if (Platform.isIOS) {\n        debugPrint(\n          \"🔧 iOS detected - waiting for Firebase Storage to be ready...\",\n        );\n        await Future.delayed(Duration(milliseconds: 3000));\n\n        // Verify Firebase Storage is accessible\n        try {\n          _storage.ref().child('test_connection');\n          debugPrint(\"✅ Firebase Storage connection test passed\");\n        } catch (e) {\n          debugPrint(\"⚠️ Firebase Storage connection test failed: $e\");\n        }\n      }\n\n      if (_tempSellerProfileImageFile != null) {\n        debugPrint(\"🖼️ Uploading seller profile image...\");\n        if (Platform.isIOS) {\n          sellerProfileImageUrl = await _iosStorageHandler.uploadFile(\n            _tempSellerProfileImageFile!,\n            'seller_profile_images/${currentUser.uid}',\n          );\n        } else {\n          sellerProfileImageUrl = await _uploadFile(\n            _tempSellerProfileImageFile!,\n            'seller_profile_images/${currentUser.uid}',\n          );\n        }\n      }\n      if (_tempShopFrontImageFile != null) {\n        debugPrint(\"🏪 Uploading shop front image...\");\n        if (Platform.isIOS) {\n          shopFrontImageUrl = await _iosStorageHandler.uploadFile(\n            _tempShopFrontImageFile!,\n            'shop_front_images/${currentUser.uid}',\n          );\n        } else {\n          shopFrontImageUrl = await _uploadFile(\n            _tempShopFrontImageFile!,\n            'shop_front_images/${currentUser.uid}',\n          );\n        }\n      }\n\n      if (_tempSellerProfileImageFile != null &&\n          sellerProfileImageUrl == null) {\n        throw Exception(\"Failed to upload seller profile image.\");\n      }\n      if (_tempShopFrontImageFile != null && shopFrontImageUrl == null) {\n        throw Exception(\"Failed to upload shop front image.\");\n      }\n\n      // الحصول على FCM Token بشكل احترافي\n      final String? fcmToken = await _getFCMTokenSafely();\n\n      // استخدام SellerModel لإنشاء البيانات\n      final SellerModel sellerToSave = SellerModel(\n        uid: currentUser.uid,\n        sellerName:\n            _tempSellerDataForSubmission?['sellerName'] as String? ?? '',\n        sellerProfileImageUrl: sellerProfileImageUrl,\n        shopName: _tempSellerDataForSubmission?['shopName'] as String? ?? '',\n        shopFrontImageUrl: shopFrontImageUrl,\n        shopPhoneNumber:\n            _tempSellerDataForSubmission?['shopPhoneNumber'] as String? ?? '',\n        shopDescription:\n            _tempSellerDataForSubmission?['shopDescription'] as String?,\n        location:\n            _tempSellerDataForSubmission?['location'] as GeoPoint? ??\n            const GeoPoint(\n              0,\n              0,\n            ), // تم التأكد من أن location هو GeoPoint في _tempSellerDataForSubmission\n        shopAddressText:\n            _tempSellerDataForSubmission?['shopAddressText'] as String?,\n        shopCategory:\n            _tempSellerDataForSubmission?['shopCategory'] as String? ?? 'أخرى',\n        workingHours: Map<String, dynamic>.from(\n          _tempSellerDataForSubmission?['workingHours'] ?? {},\n        ),\n        // الحقول التالية اختيارية في SellerModel وسيتم تعيينها إلى null إذا لم تكن موجودة في _tempSellerDataForSubmission\n        commercialRegistrationNumber:\n            _tempSellerDataForSubmission?['commercialRegistrationNumber']\n                as String?,\n        websiteUrl: _tempSellerDataForSubmission?['websiteUrl'] as String?,\n        socialMediaLinks:\n            _tempSellerDataForSubmission?['socialMediaLinks']\n                as Map<String, String>?,\n\n        isProfileComplete: true, // تم إكمال الملف الشخصي في هذه المرحلة\n        isApprovedByAdmin: false, // يحتاج موافقة المشرف بشكل افتراضي\n        isActiveBySeller: true, // نشط مبدئيًا\n        isPhoneNumberVerified: true, // تم التحقق من الهاتف في هذه المرحلة\n        averageRating: 0.0,\n        numberOfRatings: 0,\n        sellerType: _sellerTypeFromAuth, // من SellerAuthController\n        registrationCompleted: true, // اكتمل التسجيل في هذه المرحلة\n        createdAt:\n            Timestamp.now(), // سيتم استبداله بـ FieldValue.serverTimestamp() أدناه\n        updatedAt:\n            null, // SellerModel.toMap() سيعين FieldValue.serverTimestamp() لهذا\n      );\n\n      Map<String, dynamic> sellerDataToSave = sellerToSave.toMap();\n\n      // التأكد من استخدام الطوابع الزمنية للخادم وإضافة الحقول غير الموجودة في SellerModel\n      sellerDataToSave['createdAt'] = FieldValue.serverTimestamp();\n      sellerDataToSave['updatedAt'] =\n          FieldValue.serverTimestamp(); // للتأكيد أو إذا كان SellerModel.toMap لا يفعل ذلك\n\n      // إضافة الحقول التي ليست جزءًا من SellerModel ولكنها مطلوبة في Firestore\n      sellerDataToSave['email'] = currentUser.email;\n\n      // معالجة احترافية لحفظ FCM Token\n      if (fcmToken != null && fcmToken.isNotEmpty) {\n        sellerDataToSave['fcmToken'] = fcmToken;\n        sellerDataToSave['fcmTokenUpdatedAt'] = FieldValue.serverTimestamp();\n        debugPrint(\n          \"✅ FCM Token will be saved: ${fcmToken.substring(0, 30)}...\",\n        );\n      } else {\n        debugPrint(\n          \"⚠️ No FCM Token available - saving without notification capability\",\n        );\n        // لا نحفظ fcmToken إذا كان null لتجنب overwrite أي token موجود\n        sellerDataToSave['fcmTokenStatus'] = 'failed_to_retrieve';\n        sellerDataToSave['fcmTokenFailedAt'] = FieldValue.serverTimestamp();\n\n        // جدولة إعادة المحاولة بعد التسجيل\n        debugPrint(\"📅 Scheduling FCM token retry for later...\");\n      }\n\n      debugPrint(\"💾 Saving seller data to Firestore...\");\n      debugPrint(\"💾 Document ID: ${currentUser.uid}\");\n      debugPrint(\"💾 Collection: ${FirebaseX.collectionSeller}\");\n\n      await _firestore\n          .collection(FirebaseX.collectionSeller)\n          .doc(currentUser.uid)\n          .set(sellerDataToSave, SetOptions(merge: true));\n\n      debugPrint(\"✅ Seller data saved successfully to Firestore!\");\n\n      // التأكد من إعادة تعيين الحالات قبل التنقل\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      update();\n\n      debugPrint(\"🎉 Registration completed successfully!\");\n\n      // إذا لم نحصل على FCM token، جدولة إعادة المحاولة\n      if (fcmToken == null || fcmToken.isEmpty) {\n        retryFCMTokenLater();\n      }\n\n      Get.snackbar(\n        \"نجاح\",\n        \"تم تسجيل معلوماتك بنجاح!\",\n        backgroundColor: Colors.green.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n\n      // إضافة تأخير قصير على iOS قبل التنقل\n      if (Platform.isIOS) {\n        await Future.delayed(const Duration(milliseconds: 500));\n      }\n\n      // التأكد من التنقل على الـ main thread\n      WidgetsBinding.instance.addPostFrameCallback((_) {\n        Get.offAll(\n          () => SellerMainScreen(),\n        ); // Navigate to seller dashboard or main screen\n      });\n    } catch (e) {\n      isLoading.value = false;\n      isOtpVerifying.value = false;\n      update();\n      debugPrint(\"Error finalizing seller registration: $e\");\n      String errorMessage = \"فشل إكمال عملية التسجيل.\";\n      if (e is FirebaseException &&\n          e.code == 'invalid-credential' &&\n          isAutoVerified) {\n        errorMessage =\n            \"فشل التحقق التلقائي من الهاتف. قد تحتاج إلى إدخال الرمز يدويًا.\";\n        // Optionally, you could re-route to OTP screen if auto-verification was the only path here\n        // Get.to(() => OtpVerificationScreen()); // Might need to handle this case more gracefully\n      } else if (e is FirebaseException &&\n          e.code == 'invalid-verification-code') {\n        errorMessage = \"رمز OTP الذي أدخلته غير صحيح.\";\n      } else if (e is FirebaseException && e.code == 'session-expired') {\n        errorMessage = \"انتهت صلاحية جلسة التحقق. يرجى طلب رمز جديد.\";\n      }\n\n      Get.snackbar(\n        \"خطأ\",\n        \"$errorMessage يرجى المحاولة مرة أخرى.\",\n        backgroundColor: Colors.red.shade400,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<String?> _uploadFile(File file, String path) async {\n    try {\n      debugPrint(\"🔧 Starting file upload to: $path\");\n      debugPrint(\"🔧 File exists: ${await file.exists()}\");\n      debugPrint(\"🔧 File size: ${await file.length()} bytes\");\n\n      // Verify Firebase Storage is properly initialized\n      if (Firebase.apps.isEmpty) {\n        throw Exception(\"Firebase not initialized\");\n      }\n\n      final ref = _storage.ref().child(path);\n      debugPrint(\"🔧 Storage reference created: ${ref.fullPath}\");\n\n      // iOS-specific: Add metadata to help with upload\n      final metadata = SettableMetadata(\n        contentType: 'image/jpeg',\n        customMetadata: {\n          'uploaded_by': 'seller_registration',\n          'platform': Platform.isIOS ? 'ios' : 'android',\n        },\n      );\n\n      final uploadTask = ref.putFile(file, metadata);\n\n      // Monitor upload progress\n      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        final progress = snapshot.bytesTransferred / snapshot.totalBytes * 100;\n        debugPrint(\"🔧 Upload progress: ${progress.toStringAsFixed(1)}%\");\n      });\n\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"✅ File uploaded successfully: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"❌ Error uploading file ($path): $e\");\n\n      // iOS-specific error handling\n      if (Platform.isIOS && e.toString().contains('object-not-found')) {\n        debugPrint(\n          \"🔧 iOS Storage issue detected - retrying with different approach\",\n        );\n        return await _uploadFileWithRetry(file, path);\n      }\n\n      return null;\n    }\n  }\n\n  Future<String?> _uploadFileWithRetry(File file, String path) async {\n    try {\n      // Wait a bit longer on iOS\n      await Future.delayed(Duration(milliseconds: 1500));\n\n      // Try with a different path structure for iOS\n      final timestamp = DateTime.now().millisecondsSinceEpoch;\n      final newPath = '${path.replaceAll('/', '_')}_$timestamp';\n\n      debugPrint(\"🔧 Retrying upload with path: $newPath\");\n\n      final ref = _storage.ref().child(newPath);\n      final uploadTask = ref.putFile(file);\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"✅ Retry upload successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"❌ Retry upload also failed: $e\");\n      return null;\n    }\n  }\n\n  Future<void> pickImage(\n    ImageSource source, {\n    required bool isProfileImage,\n  }) async {\n    try {\n      final XFile? pickedFile = await _picker.pickImage(\n        source: source,\n        imageQuality: 70,\n        maxWidth: 1024,\n      );\n      if (pickedFile != null) {\n        if (isProfileImage) {\n          sellerProfileImageFile.value = File(pickedFile.path);\n        } else {\n          shopFrontImageFile.value = File(pickedFile.path);\n        }\n        update(); // For GetBuilder if used\n      }\n    } catch (e) {\n      Get.snackbar(\"خطأ في الصورة\", \"فشل في اختيار الصورة: $e\");\n    }\n  }\n\n  // دالة لإدارة اختيار الفئات المتعددة\n  void toggleCategorySelection(String category) {\n    if (selectedShopCategories.contains(category)) {\n      selectedShopCategories.remove(category);\n    } else {\n      if (selectedShopCategories.length < maxCategoriesAllowed) {\n        selectedShopCategories.add(category);\n      } else {\n        Get.snackbar(\n          \"تحذير\",\n          \"يمكنك اختيار حد أقصى $maxCategoriesAllowed فئات فقط\",\n          backgroundColor: Colors.orange.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n        );\n      }\n    }\n  }\n\n  // دالة للتحقق من اختيار الفئة\n  bool isCategorySelected(String category) {\n    return selectedShopCategories.contains(category);\n  }\n\n  // دالة للحصول على عدد الفئات المختارة\n  int get selectedCategoriesCount => selectedShopCategories.length;\n\n  // دالة للحصول على نص عرض الفئات المختارة\n  String get selectedCategoriesDisplay {\n    if (selectedShopCategories.isEmpty) {\n      return 'لم يتم اختيار أي فئة';\n    } else if (selectedShopCategories.length == 1) {\n      return selectedShopCategories.first;\n    } else {\n      return '${selectedShopCategories.length} فئات مختارة';\n    }\n  }\n\n  void toggleDayOpen(String dayKey) {\n    if (workingHours[dayKey] != null) {\n      bool isCurrentlyOpen = workingHours[dayKey]!['isOpen'] as bool;\n      workingHours[dayKey]!['isOpen'] = !isCurrentlyOpen;\n\n      if (!workingHours[dayKey]!['isOpen']) {\n        // If day is being closed\n        workingHours[dayKey]!['opensAt'] = null;\n        workingHours[dayKey]!['closesAt'] = null;\n        if (expandedDayPanel.value == dayKey) {\n          // Close expansion panel if it was this day\n          expandedDayPanel.value = null;\n        }\n      } else {\n        // If day is being opened\n        workingHours[dayKey]!['opensAt'] =\n            _lastAppliedOpensAt.value ?? \"09:00 AM\";\n        workingHours[dayKey]!['closesAt'] =\n            _lastAppliedClosesAt.value ?? \"05:00 PM\";\n        // Optionally, open this panel when day is toggled on if not already open by user interaction\n        // expandedDayPanel.value = dayKey;\n      }\n      workingHours.refresh();\n    }\n  }\n\n  bool canApplyToOthers(String dayKey) {\n    final dayData = workingHours[dayKey];\n    if (dayData == null || !(dayData['isOpen'] == true)) return false;\n    return dayData['opensAt'] != null && dayData['closesAt'] != null;\n  }\n\n  void offerToApplyTimesToOtherDays(\n    BuildContext context,\n    String sourceDayKey,\n    String opensAtToApply,\n    String closesAtToApply,\n  ) {\n    Get.dialog(\n      AlertDialog(\n        title: const Text(\"تطبيق الأوقات؟\"),\n        content: Text(\n          \"هل ترغب في تطبيق وقت الفتح ($opensAtToApply) ووقت الإغلاق ($closesAtToApply) على الأيام الأخرى التي تم تحديدها كمفتوحة ولم يتم تحديد أوقات لها بعد أو على جميع الأيام المفتوحة؟\",\n        ),\n        actionsAlignment: MainAxisAlignment.spaceEvenly,\n        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(15)),\n        actions: [\n          TextButton(child: const Text(\"إلغاء\"), onPressed: () => Get.back()),\n          ElevatedButton(\n            child: const Text(\"للأيام الفارغة فقط\"),\n            onPressed: () {\n              Get.back();\n              applyTimesToOtherOpenDays(\n                sourceDayKey,\n                opensAtToApply,\n                closesAtToApply,\n                applyToAllOpen: false,\n              );\n            },\n          ),\n          ElevatedButton(\n            child: const Text(\"نعم، للكل (المفتوح)\"),\n            onPressed: () {\n              Get.back();\n              applyTimesToOtherOpenDays(\n                sourceDayKey,\n                opensAtToApply,\n                closesAtToApply,\n                applyToAllOpen: true,\n              );\n            },\n          ),\n        ],\n      ),\n      barrierDismissible: true,\n    );\n  }\n\n  void applyTimesToOtherOpenDays(\n    String sourceDayKey,\n    String opensAtToApply,\n    String closesAtToApply, {\n    required bool applyToAllOpen,\n  }) {\n    bool timesApplied = false;\n    workingHours.forEach((key, value) {\n      if (key != sourceDayKey && (value['isOpen'] == true)) {\n        bool apply = false;\n        if (applyToAllOpen) {\n          apply = true;\n        } else {\n          // Apply to empty open days only\n          if (value['opensAt'] == null || value['closesAt'] == null) {\n            apply = true;\n          }\n        }\n        if (apply) {\n          value['opensAt'] = opensAtToApply;\n          value['closesAt'] = closesAtToApply;\n          timesApplied = true;\n        }\n      }\n    });\n    if (timesApplied) {\n      _lastAppliedOpensAt.value =\n          opensAtToApply; // Update template if changes were made\n      _lastAppliedClosesAt.value = closesAtToApply;\n      workingHours.refresh();\n      Get.snackbar(\n        \"تم التحديث\",\n        \"تم تطبيق الأوقات بنجاح.\",\n        snackPosition: SnackPosition.BOTTOM,\n        backgroundColor: Colors.green.shade400,\n        colorText: Colors.white,\n      );\n    } else {\n      Get.snackbar(\n        \"لم يتغير شيء\",\n        \"لم يتم العثور على أيام لتطبيق الأوقات عليها حسب اختيارك.\",\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    }\n  }\n\n  Future<void> selectTime(\n    BuildContext context,\n    String dayKey,\n    bool isOpeningTime,\n  ) async {\n    final Map<String, dynamic>? dayData = workingHours[dayKey];\n    final String? opensAtString = dayData?['opensAt'] as String?;\n    final String? closesAtString = dayData?['closesAt'] as String?;\n\n    String? timeToParse;\n    if (isOpeningTime) {\n      timeToParse = opensAtString;\n    } else {\n      timeToParse = closesAtString;\n    }\n\n    TimeOfDay? initialTime = _parseTime(timeToParse) ?? TimeOfDay.now();\n\n    final TimeOfDay? pickedTime = await showTimePicker(\n      context: context,\n      initialTime: initialTime,\n      builder: (context, child) {\n        return Theme(\n          data: ThemeData.light().copyWith(\n            colorScheme: ColorScheme.light(\n              primary: Get.theme.primaryColor, // header background color\n              onPrimary: Colors.white, // header text color\n              onSurface: Colors.black, // body text color\n            ),\n            timePickerTheme: TimePickerThemeData(\n              dialHandColor: Get.theme.primaryColor,\n            ),\n            textButtonTheme: TextButtonThemeData(\n              style: TextButton.styleFrom(\n                foregroundColor: Get.theme.primaryColor, // button text color\n              ),\n            ),\n          ),\n          child: child!,\n        );\n      },\n    );\n\n    if (pickedTime != null) {\n      final formattedTime = formatTimeOfDay(pickedTime);\n      final currentOpensAt = _parseTime(workingHours[dayKey]?['opensAt']);\n      final currentClosesAt = _parseTime(workingHours[dayKey]?['closesAt']);\n\n      if (isOpeningTime) {\n        if (currentClosesAt != null &&\n            _isTimeBeforeOrEqual(\n              pickedTime,\n              currentClosesAt,\n              isOpening: true,\n              isClosing: false,\n            )) {\n          workingHours[dayKey]!['opensAt'] = formattedTime;\n          _lastAppliedOpensAt.value = formattedTime;\n        } else if (currentClosesAt != null) {\n          Get.snackbar(\n            \"وقت غير صالح\",\n            \"وقت الفتح يجب أن يكون قبل وقت الإغلاق.\",\n            snackPosition: SnackPosition.BOTTOM,\n            backgroundColor: Colors.orange.shade300,\n          );\n          return;\n        } else {\n          // No closing time set yet, allow setting opening time\n          workingHours[dayKey]!['opensAt'] = formattedTime;\n          _lastAppliedOpensAt.value = formattedTime;\n        }\n      } else {\n        // isClosingTime\n        if (currentOpensAt != null &&\n            _isTimeBeforeOrEqual(\n              currentOpensAt,\n              pickedTime,\n              isOpening: false,\n              isClosing: true,\n            )) {\n          workingHours[dayKey]!['closesAt'] = formattedTime;\n          _lastAppliedClosesAt.value = formattedTime;\n        } else if (currentOpensAt != null) {\n          Get.snackbar(\n            \"وقت غير صالح\",\n            \"وقت الإغلاق يجب أن يكون بعد وقت الفتح.\",\n            snackPosition: SnackPosition.BOTTOM,\n            backgroundColor: Colors.orange.shade300,\n          );\n          return;\n        } else {\n          // No opening time set yet, allow setting closing time\n          workingHours[dayKey]!['closesAt'] = formattedTime;\n          _lastAppliedClosesAt.value = formattedTime;\n        }\n      }\n      workingHours.refresh();\n    }\n  }\n\n  bool _isTimeBeforeOrEqual(\n    TimeOfDay time1,\n    TimeOfDay time2, {\n    required bool isOpening,\n    required bool isClosing,\n  }) {\n    final time1Minutes = time1.hour * 60 + time1.minute;\n    final time2Minutes = time2.hour * 60 + time2.minute;\n    if (isOpening) {\n      // time1 is opensAt, time2 is closesAt\n      return time1Minutes < time2Minutes;\n    } else {\n      // time1 is opensAt, time2 is closesAt\n      return time1Minutes < time2Minutes;\n    }\n  }\n\n  String formatTimeOfDay(TimeOfDay tod) {\n    final now = DateTime.now();\n    final dt = DateTime(now.year, now.month, now.day, tod.hour, tod.minute);\n    final format = DateFormat.jm(); // e.g., 5:08 PM\n    return format.format(dt);\n  }\n\n  TimeOfDay? _parseTime(String? timeString) {\n    if (timeString == null) return null;\n    try {\n      final format =\n          DateFormat.jm(); // Needs to match the format used in formatTimeOfDay\n      final dt = format.parse(timeString);\n      return TimeOfDay.fromDateTime(dt);\n    } catch (e) {\n      debugPrint(\"Error parsing time: $e\");\n      return null;\n    }\n  }\n\n  // --- Location Methods ---\n  final TextEditingController streetAddressController = TextEditingController();\n\n  void onMapCreated(GoogleMapController controller) {\n    mapController = controller;\n  }\n\n  Future<void> openLocationPickerScreen(BuildContext context) async {\n    final LatLng? result = await Get.to<LatLng>(\n      () => LocationPickerScreen(initialLocation: shopLocation.value),\n    );\n    if (result != null) {\n      shopLocation.value = result;\n      await _getAddressFromLatLng(result);\n      // Optionally move camera on the small map if it's visible and controller is available\n      mapController?.animateCamera(CameraUpdate.newLatLngZoom(result, 16.0));\n    }\n  }\n\n  Future<void> _getAddressFromLatLng(LatLng latLng) async {\n    try {\n      List<geo.Placemark> placemarks = await geo.placemarkFromCoordinates(\n        latLng.latitude,\n        latLng.longitude,\n      );\n      if (placemarks.isNotEmpty) {\n        final p = placemarks[0];\n        // Construct a more detailed or relevant address string\n        shopAddressText.value =\n            \"${p.name}, ${p.locality}, ${p.subAdministrativeArea}, ${p.administrativeArea}\"\n                .replaceAll(\"null,\", \"\")\n                .trim()\n                .replaceAll(RegExp(r'^, |,$'), '');\n        if (streetAddressController.text.isEmpty &&\n            p.street != null &&\n            p.street!.isNotEmpty) {\n          streetAddressController.text = p.street!;\n        }\n      } else {\n        shopAddressText.value = \"تعذر جلب العنوان\";\n      }\n    } catch (e) {\n      debugPrint(\"Error getting address: $e\");\n      shopAddressText.value = \"خطأ في جلب العنوان\";\n    }\n  }\n\n  Future<void> tryMoveToCurrentLocation() async {\n    isLoading.value = true; // Indicate loading for location fetch\n    update();\n    try {\n      Position currentPosition = await _determinePosition();\n      LatLng newLatLng = LatLng(\n        currentPosition.latitude,\n        currentPosition.longitude,\n      );\n      shopLocation.value = newLatLng;\n      await _getAddressFromLatLng(newLatLng);\n      mapController?.animateCamera(CameraUpdate.newLatLngZoom(newLatLng, 16.0));\n    } catch (e) {\n      Get.snackbar(\n        \"خطأ\",\n        \"فشل في تحديد الموقع الحالي: ${e.toString()}\",\n        snackPosition: SnackPosition.BOTTOM,\n      );\n    } finally {\n      isLoading.value = false;\n      update();\n    }\n  }\n\n  Future<Position> _determinePosition() async {\n    bool serviceEnabled;\n    LocationPermission permission;\n\n    serviceEnabled = await Geolocator.isLocationServiceEnabled();\n    if (!serviceEnabled) {\n      // Attempt to open location settings\n      await Geolocator.openLocationSettings();\n      return Future.error('خدمات الموقع معطلة. يرجى تفعيلها.');\n    }\n\n    permission = await Geolocator.checkPermission();\n    if (permission == LocationPermission.denied) {\n      permission = await Geolocator.requestPermission();\n      if (permission == LocationPermission.denied) {\n        return Future.error('تم رفض أذونات تحديد الموقع.');\n      }\n    }\n\n    if (permission == LocationPermission.deniedForever) {\n      return Future.error(\n        'أذونات تحديد الموقع مرفوضة بشكل دائم، لا يمكننا طلب الأذونات. يرجى تفعيلها من الإعدادات.',\n      );\n    }\n    currentPositionAccuracy.value =\n        (await Geolocator.getCurrentPosition()).accuracy;\n\n    return await Geolocator.getCurrentPosition(\n      desiredAccuracy: LocationAccuracy.high,\n    );\n  }\n\n  void submitRegistration(BuildContext context) {\n    debugPrint(\"🔥 submitRegistration called\");\n\n    // This method will now call initiatePhoneVerificationAndCollectData\n    // as OTP verification is mandatory.\n\n    // إضافة حماية إضافية من التجميد\n    _startSafetyTimeout();\n\n    debugPrint(\"About to call initiatePhoneVerificationAndCollectData...\");\n    initiatePhoneVerificationAndCollectData();\n    debugPrint(\"initiatePhoneVerificationAndCollectData call completed\");\n  }\n\n  // آلية حماية إضافية لتجنب التجميد على iOS\n  Timer? _safetyTimer;\n\n  void _startSafetyTimeout() {\n    _safetyTimer = Timer(Duration(seconds: Platform.isIOS ? 60 : 90), () {\n      if ((isLoading.value || isOtpSending.value) && !isOtpVerifying.value) {\n        debugPrint(\"Safety timeout triggered - resetting loading states\");\n        isLoading.value = false;\n        isOtpSending.value = false;\n        isOtpVerifying.value = false;\n        update();\n        Get.snackbar(\n          \"انتهت المهلة الزمنية\",\n          \"تم انتهاء الوقت المحدد للعملية. يرجى المحاولة مرة أخرى.\",\n          backgroundColor: Colors.orange.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n        );\n      }\n    });\n  }\n\n  void _cancelSafetyTimeout() {\n    _safetyTimer?.cancel();\n    _safetyTimer = null;\n  }\n\n  /// دالة احترافية للحصول على FCM Token مع معالجة شاملة للأخطاء\n  Future<String?> _getFCMTokenSafely() async {\n    debugPrint(\"🔑 Starting FCM token retrieval process...\");\n\n    try {\n      // 1. طلب الأذونات أولاً\n      debugPrint(\"📱 Requesting Firebase Messaging permissions...\");\n      NotificationSettings settings = await _firebaseMessaging\n          .requestPermission(\n            alert: true,\n            announcement: false,\n            badge: true,\n            carPlay: false,\n            criticalAlert: false,\n            provisional: false,\n            sound: true,\n          );\n\n      debugPrint(\"🔔 Permission status: ${settings.authorizationStatus}\");\n\n      if (settings.authorizationStatus == AuthorizationStatus.denied) {\n        debugPrint(\"❌ Notification permissions denied\");\n        return null;\n      }\n\n      // 2. محاولة مباشرة للحصول على FCM token بدون انتظار APNS\n      debugPrint(\n        \"🚀 Attempting direct FCM token retrieval (bypass APNS dependency)...\",\n      );\n\n      String? fcmToken;\n      int directAttempts = 0;\n      const maxDirectAttempts = 3;\n\n      while (fcmToken == null && directAttempts < maxDirectAttempts) {\n        directAttempts++;\n        debugPrint(\"🔄 Direct FCM attempt $directAttempts/$maxDirectAttempts\");\n\n        try {\n          // محاولة مباشرة بدون انتظار APNS\n          fcmToken = await _firebaseMessaging.getToken().timeout(\n            Duration(seconds: 20 + (10 * directAttempts)),\n            onTimeout: () => null,\n          );\n\n          if (fcmToken != null && fcmToken.isNotEmpty) {\n            debugPrint(\"✅ Direct FCM Token received successfully!\");\n            debugPrint(\"🔑 Token preview: ${fcmToken.substring(0, 50)}...\");\n            await _cacheFCMToken(fcmToken);\n            return fcmToken;\n          }\n        } catch (e) {\n          debugPrint(\"⚠️ Direct FCM attempt $directAttempts failed: $e\");\n          // إذا لم تكن مشكلة APNS، تابع\n          if (!e.toString().toLowerCase().contains('apns')) {\n            await Future.delayed(Duration(seconds: directAttempts * 2));\n            continue;\n          }\n        }\n\n        // إذا وصلنا هنا، فالمشكلة متعلقة بـ APNS\n        break;\n      }\n\n      // 3. إذا فشلت المحاولة المباشرة، جرب الطريقة التقليدية مع APNS\n      if (fcmToken == null && Platform.isIOS) {\n        debugPrint(\"🍎 Fallback to APNS-dependent approach...\");\n\n        // محاولة تسجيل للإشعارات من native code\n        debugPrint(\"📲 Triggering native notification registration...\");\n\n        // انتظار إضافي للنظام\n        await Future.delayed(const Duration(seconds: 5));\n\n        // محاولة APNS محدودة\n        String? apnsToken;\n        for (int attempt = 1; attempt <= 3; attempt++) {\n          debugPrint(\"🔄 APNS attempt $attempt/3\");\n\n          try {\n            await Future.delayed(Duration(seconds: attempt * 3));\n            apnsToken = await _firebaseMessaging.getAPNSToken();\n            if (apnsToken != null) {\n              debugPrint(\n                \"✅ APNS Token received: ${apnsToken.substring(0, 20)}...\",\n              );\n              break;\n            }\n          } catch (e) {\n            debugPrint(\"⚠️ APNS attempt $attempt failed: $e\");\n          }\n        }\n\n        // 4. محاولة FCM مرة أخيرة\n        if (apnsToken != null) {\n          debugPrint(\"🔑 Final FCM token attempt with APNS...\");\n\n          try {\n            fcmToken = await _firebaseMessaging.getToken().timeout(\n              const Duration(seconds: 30),\n              onTimeout: () => null,\n            );\n\n            if (fcmToken != null && fcmToken.isNotEmpty) {\n              debugPrint(\"✅ FCM Token received after APNS setup!\");\n              await _cacheFCMToken(fcmToken);\n              return fcmToken;\n            }\n          } catch (e) {\n            debugPrint(\"⚠️ Final FCM attempt failed: $e\");\n          }\n        }\n      }\n\n      // 5. محاولة استرداد من cache\n      debugPrint(\"♻️ Trying cached token...\");\n      String? cachedToken = await _getCachedFCMToken();\n\n      if (cachedToken != null) {\n        debugPrint(\"✅ Using cached FCM token\");\n        return cachedToken;\n      }\n\n      // 6. إذا فشل كل شيء، إنشاء placeholder token للتطوير\n      if (Platform.isIOS) {\n        debugPrint(\"🛠️ Creating development placeholder token...\");\n        String placeholderToken = await _createDevelopmentToken();\n        if (placeholderToken.isNotEmpty) {\n          debugPrint(\n            \"🔧 Using development token: ${placeholderToken.substring(0, 30)}...\",\n          );\n          await _cacheFCMToken(placeholderToken);\n          return placeholderToken;\n        }\n      }\n\n      debugPrint(\"❌ All FCM token retrieval methods failed\");\n      return null;\n    } catch (e) {\n      debugPrint(\"🚨 Fatal error in FCM token retrieval: $e\");\n      debugPrint(\"📊 Error details: ${e.toString()}\");\n\n      // محاولة أخيرة مع cached token\n      String? cachedToken = await _getCachedFCMToken();\n      if (cachedToken != null) {\n        debugPrint(\"♻️ Emergency fallback to cached token\");\n        return cachedToken;\n      }\n\n      return null;\n    }\n  }\n\n  /// إنشاء token مؤقت للتطوير عندما يفشل APNS\n  Future<String> _createDevelopmentToken() async {\n    try {\n      final User? currentUser = _auth.currentUser;\n      final String deviceId =\n          currentUser?.uid ?? DateTime.now().millisecondsSinceEpoch.toString();\n      final String timestamp = DateTime.now().millisecondsSinceEpoch.toString();\n\n      // إنشاء token مؤقت فريد للجهاز\n      String developmentToken = \"dev_token_ios_${deviceId}_$timestamp\";\n\n      debugPrint(\"🔧 Generated development token for testing\");\n      return developmentToken;\n    } catch (e) {\n      debugPrint(\"⚠️ Failed to create development token: $e\");\n      return \"\";\n    }\n  }\n\n  /// حفظ FCM token في التفضيلات المحلية\n  Future<void> _cacheFCMToken(String token) async {\n    try {\n      final box = GetStorage();\n      await box.write('cached_fcm_token', token);\n      await box.write(\n        'fcm_token_timestamp',\n        DateTime.now().millisecondsSinceEpoch,\n      );\n      debugPrint(\"💾 FCM token cached successfully\");\n    } catch (e) {\n      debugPrint(\"⚠️ Failed to cache FCM token: $e\");\n    }\n  }\n\n  /// استرداد FCM token من التفضيلات المحلية\n  Future<String?> _getCachedFCMToken() async {\n    try {\n      final box = GetStorage();\n      String? cachedToken = box.read('cached_fcm_token');\n      int? timestamp = box.read('fcm_token_timestamp');\n\n      if (cachedToken != null && timestamp != null) {\n        // تحقق من عمر الـ token (صالح لمدة 7 أيام)\n        DateTime tokenDate = DateTime.fromMillisecondsSinceEpoch(timestamp);\n        Duration age = DateTime.now().difference(tokenDate);\n\n        if (age.inDays < 7) {\n          debugPrint(\n            \"♻️ Found valid cached FCM token (age: ${age.inHours} hours)\",\n          );\n          return cachedToken;\n        } else {\n          debugPrint(\n            \"⏰ Cached FCM token is too old (${age.inDays} days), ignoring\",\n          );\n        }\n      }\n\n      return null;\n    } catch (e) {\n      debugPrint(\"⚠️ Failed to retrieve cached FCM token: $e\");\n      return null;\n    }\n  }\n\n  /// تحديث FCM Token في Firestore لاحقاً (يمكن استدعاؤها من مكان آخر)\n  Future<void> updateFCMTokenInFirestore() async {\n    try {\n      final User? currentUser = _auth.currentUser;\n      if (currentUser == null) {\n        debugPrint(\"⚠️ No current user to update FCM token for\");\n        return;\n      }\n\n      debugPrint(\"🔄 Attempting to update FCM token in Firestore...\");\n      final String? fcmToken = await _getFCMTokenSafely();\n\n      if (fcmToken != null && fcmToken.isNotEmpty) {\n        await _firestore\n            .collection(FirebaseX.collectionSeller)\n            .doc(currentUser.uid)\n            .update({\n              'fcmToken': fcmToken,\n              'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n              'fcmTokenStatus': 'active',\n            });\n\n        debugPrint(\"✅ FCM Token updated successfully in Firestore\");\n        Get.snackbar(\n          \"تم التحديث\",\n          \"تم تحديث معرف الإشعارات بنجاح\",\n          backgroundColor: Colors.green.shade400,\n          colorText: Colors.white,\n          snackPosition: SnackPosition.BOTTOM,\n          duration: const Duration(seconds: 2),\n        );\n      } else {\n        debugPrint(\"❌ Failed to get FCM token for update\");\n      }\n    } catch (e) {\n      debugPrint(\"🚨 Error updating FCM token in Firestore: $e\");\n    }\n  }\n\n  /// دالة محسّنة للحصول على FCM token مع إعداد أفضل لـ iOS\n  Future<String?> _getIOSOptimizedFCMToken() async {\n    debugPrint(\"🍎 Starting iOS-optimized FCM token retrieval...\");\n\n    try {\n      // 1. انتظار إضافي للتأكد من إعداد النظام\n      await Future.delayed(const Duration(seconds: 5));\n\n      // 2. محاولة تسجيل للـ remote notifications يدوياً إذا لم يكن مسجلاً\n      debugPrint(\"📱 Ensuring iOS remote notification registration...\");\n\n      // 3. طلب الأذونات مرة أخرى\n      NotificationSettings settings = await _firebaseMessaging\n          .requestPermission(\n            alert: true,\n            announcement: false,\n            badge: true,\n            carPlay: false,\n            criticalAlert: false,\n            provisional: false,\n            sound: true,\n          );\n\n      if (settings.authorizationStatus != AuthorizationStatus.authorized) {\n        debugPrint(\n          \"❌ iOS Notifications not authorized: ${settings.authorizationStatus}\",\n        );\n        return null;\n      }\n\n      // 4. محاولة مختلفة للحصول على FCM token مع انتظار أطول\n      for (int attempt = 1; attempt <= 3; attempt++) {\n        debugPrint(\"🔑 iOS FCM token attempt $attempt/3\");\n\n        try {\n          // انتظار متزايد مع كل محاولة\n          await Future.delayed(Duration(seconds: 3 * attempt));\n\n          String? token = await _firebaseMessaging.getToken().timeout(\n            Duration(seconds: 60 + (10 * attempt)), // انتظار أطول مع كل محاولة\n          );\n\n          if (token != null && token.isNotEmpty) {\n            debugPrint(\"✅ iOS FCM token received on attempt $attempt!\");\n            return token;\n          }\n        } catch (e) {\n          debugPrint(\"⚠️ iOS FCM attempt $attempt failed: $e\");\n          if (e.toString().toLowerCase().contains('apns')) {\n            // إذا كان خطأ APNS، انتظار أطول\n            await Future.delayed(Duration(seconds: 5 * attempt));\n          }\n        }\n      }\n\n      return null;\n    } catch (e) {\n      debugPrint(\"🚨 iOS FCM token retrieval failed: $e\");\n      return null;\n    }\n  }\n\n  /// مساعد لإعادة المحاولة في الحصول على FCM token بعد التسجيل\n  void retryFCMTokenLater() {\n    // إعادة المحاولة بعد 30 ثانية للمحاولة الأولى\n    Timer(const Duration(seconds: 30), () {\n      debugPrint(\"🔄 Retrying FCM token retrieval after 30 seconds...\");\n      updateFCMTokenInFirestore();\n    });\n\n    // محاولة خاصة بـ iOS بعد دقيقة واحدة\n    if (Platform.isIOS) {\n      Timer(const Duration(minutes: 1), () async {\n        debugPrint(\"🍎 iOS-specific FCM token retry after 1 minute...\");\n        final token = await _getIOSOptimizedFCMToken();\n        if (token != null) {\n          try {\n            final User? currentUser = _auth.currentUser;\n            if (currentUser != null) {\n              await _firestore\n                  .collection(FirebaseX.collectionSeller)\n                  .doc(currentUser.uid)\n                  .update({\n                    'fcmToken': token,\n                    'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),\n                    'fcmTokenStatus': 'active',\n                  });\n              debugPrint(\"✅ iOS FCM Token updated successfully in retry!\");\n            }\n          } catch (e) {\n            debugPrint(\"❌ Failed to update iOS FCM token in retry: $e\");\n          }\n        }\n      });\n    }\n\n    // إعادة محاولة إضافية بعد دقيقتين إذا فشلت الأولى\n    Timer(const Duration(minutes: 2), () {\n      debugPrint(\"🔄 Second retry attempt for FCM token after 2 minutes...\");\n      updateFCMTokenInFirestore();\n    });\n\n    // محاولة أخيرة بعد 5 دقائق\n    Timer(const Duration(minutes: 5), () {\n      debugPrint(\"🔄 Final retry attempt for FCM token after 5 minutes...\");\n      updateFCMTokenInFirestore();\n    });\n  }\n}\n\n/// iOS-specific Firebase Storage handler to fix image upload issues\nclass IOSFirebaseStorageHandler {\n  final FirebaseStorage _storage;\n\n  IOSFirebaseStorageHandler(this._storage);\n\n  Future<String?> uploadFile(File file, String path) async {\n    try {\n      debugPrint(\"🍎 iOS Storage Handler: Starting upload to: $path\");\n\n      // Wait longer for Firebase to be fully ready on iOS\n      await Future.delayed(Duration(milliseconds: 5000));\n\n      // Verify Firebase is properly initialized\n      if (Firebase.apps.isEmpty) {\n        throw Exception(\"Firebase not initialized\");\n      }\n\n      // Test Firebase Storage connection first\n      try {\n        _storage.ref().child(\n          \"connection_test_${DateTime.now().millisecondsSinceEpoch}\",\n        );\n        debugPrint(\"🍎 Testing Firebase Storage connection...\");\n        // Just create a reference, don't upload\n        debugPrint(\"✅ Firebase Storage connection test passed\");\n      } catch (e) {\n        debugPrint(\"❌ Firebase Storage connection test failed: $e\");\n        throw Exception(\"Firebase Storage not accessible: $e\");\n      }\n\n      // Verify file exists and is readable\n      if (!await file.exists()) {\n        throw Exception(\"File does not exist at path: ${file.path}\");\n      }\n\n      final fileSize = await file.length();\n      debugPrint(\"🍎 iOS Storage Handler: File size: $fileSize bytes\");\n\n      if (fileSize == 0) {\n        throw Exception(\"File is empty\");\n      }\n\n      // Use simple path first - try without modifications\n      debugPrint(\"🍎 iOS Storage Handler: Trying direct upload to: $path\");\n\n      final ref = _storage.ref().child(path);\n\n      // Set proper metadata for iOS\n      final metadata = SettableMetadata(\n        contentType: _getContentType(file.path),\n        customMetadata: {\n          'uploaded_by': 'ios_seller_registration',\n          'original_path': path,\n          'upload_timestamp': DateTime.now().millisecondsSinceEpoch.toString(),\n        },\n      );\n\n      debugPrint(\"🍎 iOS Storage Handler: Creating upload task...\");\n      final uploadTask = ref.putFile(file, metadata);\n\n      // Monitor progress\n      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {\n        if (snapshot.totalBytes > 0) {\n          final progress =\n              snapshot.bytesTransferred / snapshot.totalBytes * 100;\n          debugPrint(\"🍎 iOS Upload progress: ${progress.toStringAsFixed(1)}%\");\n        }\n      });\n\n      debugPrint(\"🍎 iOS Storage Handler: Waiting for upload completion...\");\n      final snapshot = await uploadTask.whenComplete(() {});\n\n      debugPrint(\"🍎 iOS Storage Handler: Getting download URL...\");\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"✅ iOS Upload successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"❌ iOS Storage Handler error: $e\");\n\n      // Try alternative upload method for iOS\n      return await _alternativeUploadMethod(file, path);\n    }\n  }\n\n  Future<String?> _alternativeUploadMethod(File file, String path) async {\n    // Try multiple alternative approaches for iOS\n\n    // Method 1: putData instead of putFile\n    try {\n      debugPrint(\"🔄 iOS Alternative Method 1: Using putData...\");\n      await Future.delayed(Duration(milliseconds: 3000));\n\n      final bytes = await file.readAsBytes();\n      debugPrint(\"🔄 iOS Read ${bytes.length} bytes from file\");\n\n      final ref = _storage.ref().child(path);\n      final uploadTask = ref.putData(\n        bytes,\n        SettableMetadata(\n          contentType: _getContentType(file.path),\n          customMetadata: {\n            'uploaded_by': 'ios_alternative_putdata',\n            'original_path': path,\n          },\n        ),\n      );\n\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"✅ iOS Alternative Method 1 successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"❌ iOS Alternative Method 1 failed: $e\");\n    }\n\n    // Method 2: Different path structure\n    try {\n      debugPrint(\"🔄 iOS Alternative Method 2: Different path structure...\");\n      await Future.delayed(Duration(milliseconds: 3000));\n\n      final timestamp = DateTime.now().millisecondsSinceEpoch;\n      final altPath = \"mobile_uploads/${path.replaceAll('/', '_')}_$timestamp\";\n\n      debugPrint(\"🔄 iOS Alternative path: $altPath\");\n\n      final bytes = await file.readAsBytes();\n      final ref = _storage.ref().child(altPath);\n\n      final uploadTask = ref.putData(\n        bytes,\n        SettableMetadata(\n          contentType: _getContentType(file.path),\n          customMetadata: {\n            'uploaded_by': 'ios_alternative_path',\n            'original_path': path,\n          },\n        ),\n      );\n\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"✅ iOS Alternative Method 2 successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"❌ iOS Alternative Method 2 failed: $e\");\n    }\n\n    // Method 3: Very simple path\n    try {\n      debugPrint(\"🔄 iOS Alternative Method 3: Simple upload...\");\n      await Future.delayed(Duration(milliseconds: 5000));\n\n      final simplePath = \"uploads/${DateTime.now().millisecondsSinceEpoch}\";\n      debugPrint(\"🔄 iOS Simple path: $simplePath\");\n\n      final bytes = await file.readAsBytes();\n      final ref = _storage.ref().child(simplePath);\n\n      final uploadTask = ref.putData(bytes);\n      final snapshot = await uploadTask.whenComplete(() {});\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      debugPrint(\"✅ iOS Alternative Method 3 successful: $downloadUrl\");\n      return downloadUrl;\n    } catch (e) {\n      debugPrint(\"❌ iOS Alternative Method 3 failed: $e\");\n    }\n\n    debugPrint(\"❌ All iOS alternative upload methods failed\");\n    return null;\n  }\n\n  String _getContentType(String filePath) {\n    final extension = filePath.toLowerCase().split('.').last;\n    switch (extension) {\n      case 'jpg':\n      case 'jpeg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n      case 'gif':\n        return 'image/gif';\n      case 'webp':\n        return 'image/webp';\n      default:\n        return 'image/jpeg'; // Default fallback\n    }\n  }\n}\n"
        }
    ]
}