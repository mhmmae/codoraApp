{
    "sourceFile": "lib/الكود الخاص بتطبيق العميل /registration/phoneNamber/controllers/code_phone_controller.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1752751503159,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1752798049975,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,276 +1,659 @@\n import 'dart:async';\n-import 'dart:typed_data';\n import 'package:cloud_firestore/cloud_firestore.dart';\n import 'package:firebase_auth/firebase_auth.dart';\n import 'package:firebase_storage/firebase_storage.dart';\n+import 'package:firebase_messaging/firebase_messaging.dart';\n import 'package:flutter/material.dart';\n+import 'package:flutter/services.dart';\n import 'package:get/get.dart';\n+import 'package:connectivity_plus/connectivity_plus.dart';\n+import 'package:permission_handler/permission_handler.dart';\n \n-import '../../../core/error_display_manager.dart';\n import '../../../services/phone_auth_service.dart';\n+import '../../../../Model/model_user.dart';\n+import '../../../../XXX/xxx_firebase.dart';\n+import '../../../bottonBar/botonBar.dart';\n \n-/// تحكم متقدم لصفحة إدخال رمز التحقق\n+/// كونترولر متقدم لصفحة رمز التحقق\n+/// يدعم التحقق التلقائي من الرسائل، شبكة المراقبة، والتحقق الذكي\n class CodePhoneController extends GetxController {\n-  // Controllers للحقول\n+  // ===================== Constants =====================\n+  static const int _codeLength = 6;\n+  static const int _resendTimeoutSeconds = 60;\n+  static const int _maxResendAttempts = 3;\n+  static const int _maxVerificationAttempts = 5;\n+\n+  // ===================== Controllers & Focus Nodes =====================\n   final List<TextEditingController> codeControllers = List.generate(\n-    6,\n+    _codeLength,\n     (index) => TextEditingController(),\n   );\n \n-  // FocusNodes للحقول\n-  final List<FocusNode> focusNodes = List.generate(6, (index) => FocusNode());\n+  final List<FocusNode> focusNodes = List.generate(\n+    _codeLength,\n+    (index) => FocusNode(),\n+  );\n \n-  // متغيرات التحكم\n+  // ===================== Observable States =====================\n   final RxBool isLoading = false.obs;\n   final RxBool isCodeValid = true.obs;\n   final RxBool canResend = false.obs;\n-  final RxInt resendCounter = 60.obs;\n+  final RxBool isNetworkConnected = true.obs;\n+  final RxInt resendCounter = _resendTimeoutSeconds.obs;\n+  final RxInt resendAttempts = 0.obs;\n+  final RxInt verificationAttempts = 0.obs;\n   final RxString statusMessage = ''.obs;\n+  final RxString errorMessage = ''.obs;\n   final RxDouble progress = 0.0.obs;\n+  final RxBool isAutoVerifying = false.obs;\n+  final RxString allCodeText = ''.obs;\n \n-  // خدمة المصادقة\n+  // ===================== Services & Utilities =====================\n   late PhoneAuthService _phoneAuthService;\n-\n-  // Timer لإعادة الإرسال\n   Timer? _resendTimer;\n+  Timer? _autoFillTimer;\n+  late StreamSubscription<List<ConnectivityResult>> _connectivitySubscription;\n \n-  // بيانات المستخدم\n+  // ===================== Pinput Controller =====================\n+  final pinController = TextEditingController();\n+\n+  // ===================== User Data =====================\n   final String phoneNumber;\n   final Uint8List userImage;\n   final String name;\n   final String email;\n   final String password;\n-  final bool hasPassword;\n+  String? verificationId;\n+  int? forceResendingToken;\n \n+  // ===================== Constructor =====================\n   CodePhoneController({\n     required this.phoneNumber,\n     required this.userImage,\n     required this.name,\n     required this.email,\n     required this.password,\n-    required this.hasPassword,\n+    this.verificationId,\n+    this.forceResendingToken,\n   });\n \n+  // ===================== Lifecycle Methods =====================\n   @override\n   void onInit() {\n     super.onInit();\n-    _initializeService();\n-    _startResendTimer();\n-    _setupFocusListeners();\n+    _initializeController();\n+  }\n \n-    print('CodePhoneController initialized for $phoneNumber');\n+  @override\n+  void onClose() {\n+    _disposeResources();\n+    super.onClose();\n   }\n \n-  /// تهيئة خدمة المصادقة\n-  void _initializeService() {\n+  // ===================== Initialization =====================\n+  Future<void> _initializeController() async {\n     try {\n-      if (!Get.isRegistered<PhoneAuthService>()) {\n-        Get.put(PhoneAuthService());\n-      }\n-      _phoneAuthService = Get.find<PhoneAuthService>();\n+      await _initializeService();\n+      _setupNetworkMonitoring();\n+      _setupFocusListeners();\n+      _setupCodeValidation();\n+      _startResendTimer();\n+      _setupAutoFill();\n+\n+      statusMessage.value = 'تم إرسال رمز التحقق إلى $phoneNumber';\n+\n+      // تشخيص Firebase وإرسال الرمز\n+      await sendVerificationCodeWithDiagnosis();\n     } catch (e) {\n-      print('ERROR: Failed to initialize PhoneAuthService: $e');\n-      ErrorDisplayManager.showError(\n-        'فشل في تهيئة خدمة المصادقة',\n-        details: e.toString(),\n-      );\n+      _handleError('فشل في تهيئة النظام', e);\n     }\n   }\n \n-  /// إعداد listeners للحقول\n+  Future<void> _initializeService() async {\n+    _phoneAuthService = Get.find<PhoneAuthService>();\n+  }\n+\n+  void _setupNetworkMonitoring() {\n+    _connectivitySubscription = Connectivity().onConnectivityChanged.listen((\n+      List<ConnectivityResult> results,\n+    ) {\n+      final isConnected = results.any(\n+        (result) => result != ConnectivityResult.none,\n+      );\n+      isNetworkConnected.value = isConnected;\n+\n+      if (isConnected) {\n+        statusMessage.value = 'تم استعادة الاتصال بالإنترنت';\n+      } else {\n+        statusMessage.value = 'لا يوجد اتصال بالإنترنت';\n+      }\n+    });\n+  }\n+\n   void _setupFocusListeners() {\n     for (int i = 0; i < focusNodes.length; i++) {\n-      codeControllers[i].addListener(() {\n-        if (codeControllers[i].text.length == 1) {\n-          if (i < focusNodes.length - 1) {\n-            focusNodes[i + 1].requestFocus();\n-          } else {\n-            focusNodes[i].unfocus();\n-          }\n+      focusNodes[i].addListener(() {\n+        if (focusNodes[i].hasFocus) {\n+          HapticFeedback.selectionClick();\n         }\n       });\n     }\n   }\n \n-  /// بدء مؤقت إعادة الإرسال\n+  void _setupCodeValidation() {\n+    for (int i = 0; i < codeControllers.length; i++) {\n+      codeControllers[i].addListener(() {\n+        _validateInput(i);\n+      });\n+    }\n+  }\n+\n   void _startResendTimer() {\n     canResend.value = false;\n-    resendCounter.value = 60;\n+    resendCounter.value = _resendTimeoutSeconds;\n \n+    _resendTimer?.cancel();\n     _resendTimer = Timer.periodic(const Duration(seconds: 1), (timer) {\n       if (resendCounter.value > 0) {\n         resendCounter.value--;\n       } else {\n         canResend.value = true;\n         timer.cancel();\n-        print('Resend code is now available');\n       }\n     });\n   }\n \n-  /// إعادة إرسال الرمز\n-  Future<void> resendCode() async {\n-    if (!canResend.value) return;\n+  void _setupAutoFill() {\n+    _requestSmsListenPermission();\n+    _setupPinputController();\n+  }\n \n+  // ===================== Pinput Setup =====================\n+  void _setupPinputController() {\n+    pinController.addListener(() {\n+      final text = pinController.text;\n+      if (text.length == _codeLength) {\n+        // التحقق التلقائي بعد إدخال جميع الأرقام\n+        Future.delayed(const Duration(milliseconds: 300), () {\n+          if (pinController.text.length == _codeLength) {\n+            verifyCode();\n+          }\n+        });\n+      }\n+    });\n+  }\n+\n+  // ===================== Pinput Helper Methods =====================\n+  void clearPinput() {\n+    pinController.clear();\n+    isCodeValid.value = true;\n+    errorMessage.value = '';\n+  }\n+\n+  void setPinputCode(String code) {\n+    pinController.text = code;\n+  }\n+\n+  String getPinputCode() {\n+    return pinController.text;\n+  }\n+\n+  bool get isPinputComplete => pinController.text.length == _codeLength;\n+\n+  // ===================== Pinput Code Validation =====================\n+  bool validatePinputCode() {\n+    final code = pinController.text;\n+\n+    if (code.length != _codeLength) {\n+      _showError('يرجى إدخال الرمز كاملاً');\n+      return false;\n+    }\n+\n+    if (!RegExp(r'^[0-9]+$').hasMatch(code)) {\n+      _showError('الرمز يجب أن يحتوي على أرقام فقط');\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  // ===================== Pinput Verification =====================\n+  Future<void> verifyCodeFromPinput() async {\n+    final code = pinController.text;\n+\n+    if (code.length != _codeLength) {\n+      _showError('يرجى إدخال الرمز كاملاً');\n+      return;\n+    }\n+\n+    if (!RegExp(r'^[0-9]+$').hasMatch(code)) {\n+      _showError('الرمز يجب أن يحتوي على أرقام فقط');\n+      return;\n+    }\n+\n+    verificationAttempts.value++;\n+\n+    if (verificationAttempts.value > _maxVerificationAttempts) {\n+      _handleError('تم تجاوز الحد الأقصى للمحاولات', 'يرجى المحاولة لاحقاً');\n+      return;\n+    }\n+\n     try {\n       isLoading.value = true;\n-      statusMessage.value = 'جارٍ إعادة إرسال الرمز...';\n+      statusMessage.value = 'جاري التحقق من الرمز...';\n \n-      final result = await _phoneAuthService.sendVerificationCode(phoneNumber);\n+      final result = await _phoneAuthService.verifyCode(code);\n \n       if (result.isSuccess) {\n-        ErrorDisplayManager.showSuccess('تم إعادة إرسال الرمز بنجاح');\n-        _startResendTimer();\n-        _clearCodeFields();\n+        await _handleSuccessfulVerification(result.user);\n       } else {\n-        ErrorDisplayManager.showError(\n-          'فشل في إعادة إرسال الرمز',\n-          details: result.error?.toString(),\n-        );\n+        _handleVerificationError(result.error ?? 'خطأ في التحقق من الرمز');\n       }\n     } catch (e) {\n-      print('ERROR in resendCode: $e');\n-      ErrorDisplayManager.showError(\n-        'خطأ غير متوقع أثناء إعادة الإرسال',\n-        details: e.toString(),\n-      );\n+      _handleVerificationError(e);\n     } finally {\n       isLoading.value = false;\n-      statusMessage.value = '';\n     }\n   }\n \n-  /// التحقق من الرمز عند اكتماله\n-  void checkCodeOnComplete() {\n-    final code = codeControllers.map((c) => c.text).join();\n-    if (code.length == 6) {\n-      verifyCode(code);\n+  // ===================== SMS Permission (للاستخدام المستقبلي) =====================\n+  Future<void> _requestSmsListenPermission() async {\n+    try {\n+      // طلب إذن قراءة الرسائل\n+      final status = await Permission.sms.request();\n+\n+      if (status.isGranted) {\n+        statusMessage.value =\n+            'يمكنك إدخال رمز التحقق يدوياً أو انتظار الملء التلقائي';\n+      } else {\n+        statusMessage.value = 'يمكنك إدخال رمز التحقق يدوياً';\n+      }\n+    } catch (e) {\n+      print('خطأ في طلب إذن قراءة الرسائل: $e');\n+      statusMessage.value = 'يمكنك إدخال رمز التحقق يدوياً';\n     }\n   }\n \n-  /// التحقق من الرمز\n-  Future<void> verifyCode(String code) async {\n-    if (code.length != 6) {\n-      isCodeValid.value = false;\n-      ErrorDisplayManager.showError('يجب أن يكون الرمز مكون من 6 أرقام');\n+  // ===================== Success Handling =====================\n+\n+  // ===================== Core Verification Logic =====================\n+  Future<void> sendVerificationCodeWithDiagnosis() async {\n+    if (!isNetworkConnected.value) {\n+      _handleError('لا يوجد اتصال بالإنترنت', 'تحقق من الاتصال وحاول مرة أخرى');\n       return;\n     }\n \n     try {\n       isLoading.value = true;\n-      isCodeValid.value = true;\n-      statusMessage.value = 'جارٍ التحقق من الرمز...';\n-      progress.value = 0.2;\n+      statusMessage.value = 'جاري إرسال رمز التحقق...';\n \n-      final result = await _phoneAuthService.verifyCode(code);\n-      progress.value = 0.6;\n+      final result = await _phoneAuthService.sendVerificationCode(phoneNumber);\n \n-      if (result.isSuccess && result.user != null) {\n-        statusMessage.value = 'تم التحقق بنجاح، جارٍ إنشاء الحساب...';\n-        progress.value = 0.8;\n+      if (result.isSuccess) {\n+        if (result.type == PhoneAuthResultType.codeSent) {\n+          verificationId = result.verificationId;\n+          statusMessage.value = 'تم إرسال رمز التحقق بنجاح';\n+        } else if (result.type == PhoneAuthResultType.autoVerified) {\n+          await _handleSuccessfulVerification(result.user);\n+          return;\n+        }\n+      } else {\n+        _handleError(\n+          'فشل في إرسال رمز التحقق',\n+          result.error ?? 'خطأ غير معروف',\n+        );\n+      }\n+    } catch (e) {\n+      _handleError('فشل في إرسال رمز التحقق', e);\n+    } finally {\n+      isLoading.value = false;\n+    }\n+  }\n \n-        await _completeUserRegistration(result.user!);\n-        progress.value = 1.0;\n+  Future<void> verifyCode() async {\n+    if (!_validateAllInputs()) return;\n \n-        ErrorDisplayManager.showSuccess('تم التحقق بنجاح!');\n+    verificationAttempts.value++;\n \n-        // الانتقال للصفحة الرئيسية\n-        Get.offAllNamed('/home');\n+    if (verificationAttempts.value > _maxVerificationAttempts) {\n+      _handleError('تم تجاوز الحد الأقصى للمحاولات', 'يرجى المحاولة لاحقاً');\n+      return;\n+    }\n+\n+    final code = _getCompleteCode();\n+\n+    try {\n+      isLoading.value = true;\n+      statusMessage.value = 'جاري التحقق من الرمز...';\n+\n+      final result = await _phoneAuthService.verifyCode(code);\n+\n+      if (result.isSuccess) {\n+        await _handleSuccessfulVerification(result.user);\n       } else {\n-        isCodeValid.value = false;\n-        ErrorDisplayManager.showError(\n-          'رمز التحقق غير صحيح',\n-          details: result.error?.toString(),\n-        );\n+        _handleVerificationError(result.error ?? 'خطأ في التحقق من الرمز');\n       }\n     } catch (e) {\n-      print('ERROR in verifyCode: $e');\n-      isCodeValid.value = false;\n-      ErrorDisplayManager.showError(\n-        'خطأ أثناء التحقق من الرمز',\n-        details: e.toString(),\n-      );\n+      _handleVerificationError(e);\n     } finally {\n       isLoading.value = false;\n-      statusMessage.value = '';\n-      progress.value = 0.0;\n     }\n   }\n \n-  /// إكمال تسجيل المستخدم\n-  Future<void> _completeUserRegistration(User user) async {\n-    try {\n-      statusMessage.value = 'جارٍ رفع الصورة...';\n+  Future<void> resendCode() async {\n+    if (!canResend.value || resendAttempts.value >= _maxResendAttempts) {\n+      statusMessage.value = 'تم تجاوز الحد الأقصى لإعادة الإرسال';\n+      return;\n+    }\n \n-      final imageUrl = await _uploadUserImage(user.uid);\n+    resendAttempts.value++;\n+    _clearAllInputs();\n+    await sendVerificationCodeWithDiagnosis();\n+    _startResendTimer();\n+  }\n \n-      statusMessage.value = 'جارٍ حفظ بيانات المستخدم...';\n+  // ===================== Input Validation & Management =====================\n+  void _validateInput(int index) {\n+    final text = codeControllers[index].text;\n \n-      // إنشاء نموذج بيانات المستخدم\n-      final userData = {\n-        'uid': user.uid,\n-        'name': name,\n-        'email': email,\n-        'phone': phoneNumber,\n-        'profileImage': imageUrl,\n-        'isVerified': true,\n-        'createdAt': DateTime.now().toIso8601String(),\n-        'appName': 'Codora',\n-      };\n+    if (text.isNotEmpty &&\n+        text.length == 1 &&\n+        RegExp(r'[0-9]').hasMatch(text)) {\n+      isCodeValid.value = true;\n+      errorMessage.value = '';\n+      _moveToNextField(index);\n+    } else if (text.length > 1) {\n+      codeControllers[index].text = text[text.length - 1];\n+    }\n \n-      await FirebaseFirestore.instance\n-          .collection('users') // FirebaseX.collectionApp replacement\n-          .doc(user.uid)\n-          .set(userData);\n+    _updateAllCodeText();\n+    _checkAutoVerification();\n+  }\n \n-      print('User registration completed successfully');\n-    } catch (e) {\n-      print('ERROR in _completeUserRegistration: $e');\n-      throw Exception('فشل في إكمال تسجيل المستخدم: $e');\n+  void _moveToNextField(int currentIndex) {\n+    Future.delayed(const Duration(milliseconds: 50), () {\n+      if (currentIndex < _codeLength - 1) {\n+        focusNodes[currentIndex + 1].requestFocus();\n+        HapticFeedback.lightImpact();\n+      } else {\n+        focusNodes[currentIndex].unfocus();\n+      }\n+    });\n+  }\n+\n+  void _moveToPreviousField(int currentIndex) {\n+    if (currentIndex > 0) {\n+      focusNodes[currentIndex - 1].requestFocus();\n+      HapticFeedback.lightImpact();\n     }\n   }\n \n-  /// رفع صورة المستخدم\n-  Future<String> _uploadUserImage(String userId) async {\n-    try {\n-      final storageRef = FirebaseStorage.instance\n-          .ref('user_images') // FirebaseX.StorgeApp replacement\n-          .child('$userId.jpg');\n+  void _updateAllCodeText() {\n+    allCodeText.value = codeControllers.map((c) => c.text).join();\n+  }\n \n-      final uploadTask = storageRef.putData(userImage);\n+  void _checkAutoVerification() {\n+    if (allCodeText.value.length == _codeLength &&\n+        allCodeText.value\n+            .split('')\n+            .every((char) => RegExp(r'[0-9]').hasMatch(char))) {\n+      _autoFillTimer?.cancel();\n+      _autoFillTimer = Timer(const Duration(milliseconds: 500), () {\n+        if (!isLoading.value) {\n+          verifyCode();\n+        }\n+      });\n+    }\n+  }\n \n-      final snapshot = await uploadTask;\n-      final downloadUrl = await snapshot.ref.getDownloadURL();\n+  bool _validateAllInputs() {\n+    final code = _getCompleteCode();\n \n-      print('Image uploaded successfully: $downloadUrl');\n-      return downloadUrl;\n-    } catch (e) {\n-      print('ERROR in _uploadUserImage: $e');\n-      throw Exception('فشل في رفع الصورة: $e');\n+    if (code.length != _codeLength) {\n+      _showError('يرجى إدخال الرمز كاملاً');\n+      return false;\n     }\n+\n+    if (!RegExp(r'^[0-9]+$').hasMatch(code)) {\n+      _showError('الرمز يجب أن يحتوي على أرقام فقط');\n+      return false;\n+    }\n+\n+    return true;\n   }\n \n-  /// مسح حقول الرمز\n-  void _clearCodeFields() {\n+  String _getCompleteCode() {\n+    return codeControllers.map((controller) => controller.text).join();\n+  }\n+\n+  void _clearAllInputs() {\n     for (var controller in codeControllers) {\n       controller.clear();\n     }\n-    isCodeValid.value = true;\n+    allCodeText.value = '';\n     focusNodes[0].requestFocus();\n+    HapticFeedback.mediumImpact();\n   }\n \n-  @override\n-  void onClose() {\n+  // ===================== Success Handling =====================\n+  Future<void> _handleSuccessfulVerification(User? user) async {\n+    if (user == null) {\n+      _handleError('فشل في التحقق', 'لم يتم إنشاء المستخدم');\n+      return;\n+    }\n+\n+    try {\n+      statusMessage.value = 'تم التحقق بنجاح! جاري حفظ البيانات...';\n+\n+      await _saveUserDataToFirestore(user);\n+\n+      _showSuccessMessage();\n+      _navigateToBottomBar();\n+    } catch (e) {\n+      _handleError('فشل في حفظ البيانات', e);\n+    }\n+  }\n+\n+  Future<void> _saveUserDataToFirestore(User user) async {\n+    try {\n+      // الحصول على FCM Token\n+      String fcmToken = '';\n+      try {\n+        fcmToken = await FirebaseMessaging.instance.getToken() ?? '';\n+        print('FCM Token: $fcmToken');\n+      } catch (e) {\n+        print('خطأ في الحصول على FCM Token: $e');\n+      }\n+\n+      // رفع صورة المستخدم أولاً للحصول على الرابط\n+      String profileImageUrl = '';\n+      try {\n+        final storageRef = FirebaseStorage.instance\n+            .ref()\n+            .child(FirebaseX.StorgeApp)\n+            .child('${user.uid}.jpg');\n+\n+        await storageRef.putData(userImage);\n+        profileImageUrl = await storageRef.getDownloadURL();\n+      } catch (e) {\n+        print('خطأ في رفع الصورة: $e');\n+        profileImageUrl = ImageX.ImageOfPerson; // صورة افتراضية\n+      }\n+\n+      // إنشاء نموذج المستخدم مع FCM Token\n+      final userModel = UserModel(\n+        uid: user.uid,\n+        name: name,\n+        email: email,\n+        password: password, // ملاحظة: يجب تشفير كلمة المرور في بيئة الإنتاج\n+        phoneNumber: phoneNumber,\n+        token: fcmToken, // حفظ FCM Token\n+        url: profileImageUrl,\n+        appName: FirebaseX.appName,\n+      );\n+\n+      // حفظ بيانات المستخدم باستخدام UserModel و FirebaseX\n+      await FirebaseFirestore.instance\n+          .collection(FirebaseX.collectionApp)\n+          .doc(user.uid)\n+          .set({\n+            ...userModel.toMap(),\n+            'createdAt': FieldValue.serverTimestamp(),\n+            'lastLoginAt': FieldValue.serverTimestamp(),\n+            'isPhoneVerified': true,\n+            'userType': 'customer',\n+          });\n+\n+      print('تم حفظ بيانات المستخدم بنجاح في: ${FirebaseX.collectionApp}');\n+      print('FCM Token محفوظ: $fcmToken');\n+    } catch (e) {\n+      print('خطأ في حفظ بيانات المستخدم: $e');\n+      throw e;\n+    }\n+  }\n+\n+  void _showSuccessMessage() {\n+    statusMessage.value = 'تم التحقق من رقم الهاتف بنجاح!';\n+    HapticFeedback.heavyImpact();\n+  }\n+\n+  void _navigateToBottomBar() {\n+    Future.delayed(const Duration(milliseconds: 1000), () {\n+      // الانتقال إلى BottomBar مع initialIndex = 0\n+      Get.offAll(() => const BottomBar(initialIndex: 0));\n+    });\n+  }\n+\n+  // ===================== Error Handling =====================\n+  void _handleVerificationError(dynamic error) {\n+    String message = 'خطأ في التحقق من الرمز';\n+\n+    if (error is String) {\n+      message = error;\n+    } else if (error is FirebaseAuthException) {\n+      switch (error.code) {\n+        case 'invalid-verification-code':\n+          message = 'رمز التحقق غير صحيح';\n+          _clearAllInputs();\n+          break;\n+        case 'invalid-verification-id':\n+          message = 'معرف التحقق غير صالح';\n+          break;\n+        case 'session-expired':\n+          message = 'انتهت صلاحية الجلسة، يرجى المحاولة مرة أخرى';\n+          break;\n+        case 'too-many-requests':\n+          message = 'تم تجاوز الحد الأقصى للمحاولات';\n+          break;\n+        default:\n+          message = error.message ?? 'خطأ غير معروف';\n+      }\n+    } else {\n+      message = error.toString();\n+    }\n+\n+    _showError(message);\n+  }\n+\n+  void _handleError(String title, dynamic error) {\n+    final errorMsg = error.toString();\n+    print('خطأ في $title: $errorMsg');\n+\n+    // عرض رسالة خطأ بسيطة\n+    Get.snackbar(\n+      title,\n+      errorMsg,\n+      snackPosition: SnackPosition.TOP,\n+      backgroundColor: Colors.red.withOpacity(0.1),\n+      colorText: Colors.red,\n+    );\n+\n+    statusMessage.value = title;\n+  }\n+\n+  void _showError(String message) {\n+    errorMessage.value = message;\n+    isCodeValid.value = false;\n+    HapticFeedback.heavyImpact();\n+\n+    Future.delayed(const Duration(seconds: 3), () {\n+      errorMessage.value = '';\n+      isCodeValid.value = true;\n+    });\n+  }\n+\n+  // ===================== Resource Management =====================\n+  void _disposeResources() {\n     _resendTimer?.cancel();\n+    _autoFillTimer?.cancel();\n+    _connectivitySubscription.cancel();\n+    pinController.dispose();\n \n     for (var controller in codeControllers) {\n       controller.dispose();\n     }\n \n-    for (var focusNode in focusNodes) {\n-      focusNode.dispose();\n+    for (var node in focusNodes) {\n+      node.dispose();\n     }\n+  }\n \n-    super.onClose();\n+  // ===================== Public Methods for UI =====================\n+  void moveToNextField(int currentIndex) {\n+    _moveToNextField(currentIndex);\n   }\n+\n+  void handlePastedText(String text, int startIndex) {\n+    // تنظيف النص - إزالة كل شيء عدا الأرقام\n+    final cleanText = text.replaceAll(RegExp(r'[^0-9]'), '');\n+\n+    // ملء الحقول بناءً على النص المنسوخ\n+    for (\n+      int i = 0;\n+      i < cleanText.length && (startIndex + i) < _codeLength;\n+      i++\n+    ) {\n+      codeControllers[startIndex + i].text = cleanText[i];\n+    }\n+\n+    // التركيز على الحقل التالي المناسب\n+    final nextIndex = (startIndex + cleanText.length).clamp(0, _codeLength - 1);\n+    if (nextIndex < _codeLength) {\n+      focusNodes[nextIndex].requestFocus();\n+    }\n+\n+    // التحقق التلقائي إذا تم ملء جميع الحقول\n+    _updateAllCodeText();\n+    _checkAutoVerification();\n+  }\n+\n+  // ===================== Utility Methods =====================\n+  void onBackspacePressed(int index) {\n+    if (codeControllers[index].text.isEmpty && index > 0) {\n+      _moveToPreviousField(index);\n+    } else {\n+      codeControllers[index].clear();\n+    }\n+  }\n+\n+  void onFieldTapped(int index) {\n+    focusNodes[index].requestFocus();\n+    HapticFeedback.selectionClick();\n+  }\n+\n+  double get verificationProgress {\n+    final filledFields = codeControllers.where((c) => c.text.isNotEmpty).length;\n+    return filledFields / _codeLength;\n+  }\n+\n+  String get resendButtonText {\n+    if (canResend.value) {\n+      return 'إعادة إرسال الرمز';\n+    } else {\n+      return 'إعادة الإرسال خلال ${resendCounter.value}s';\n+    }\n+  }\n+\n+  bool get isResendEnabled =>\n+      canResend.value && resendAttempts.value < _maxResendAttempts;\n }\n"
                },
                {
                    "date": 1752832216762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -507,9 +507,9 @@\n       print('تم حفظ بيانات المستخدم بنجاح في: ${FirebaseX.collectionApp}');\n       print('FCM Token محفوظ: $fcmToken');\n     } catch (e) {\n       print('خطأ في حفظ بيانات المستخدم: $e');\n-      throw e;\n+      rethrow;\n     }\n   }\n \n   void _showSuccessMessage() {\n"
                },
                {
                    "date": 1752858134127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,8 +47,14 @@\n   final RxDouble progress = 0.0.obs;\n   final RxBool isAutoVerifying = false.obs;\n   final RxString allCodeText = ''.obs;\n \n+  // ===================== حماية من الطلبات المتكررة =====================\n+  bool _isCodeSendingInProgress = false;\n+  DateTime? _lastCodeSendTime;\n+  bool _hasInitialCodeBeenSent = false;\n+  static const int _minimumSendInterval = 5000; // 5 ثواني\n+\n   // ===================== Services & Utilities =====================\n   late PhoneAuthService _phoneAuthService;\n   Timer? _resendTimer;\n   Timer? _autoFillTimer;\n@@ -101,10 +107,15 @@\n       _setupAutoFill();\n \n       statusMessage.value = 'تم إرسال رمز التحقق إلى $phoneNumber';\n \n-      // تشخيص Firebase وإرسال الرمز\n-      await sendVerificationCodeWithDiagnosis();\n+      // ✅ إرسال الرمز فقط إذا لم يتم إرساله من قبل\n+      if (!_hasInitialCodeBeenSent) {\n+        await sendVerificationCodeWithDiagnosis();\n+      } else {\n+        print('ℹ️ تم تخطي إرسال الرمز - تم إرساله مسبقاً');\n+        statusMessage.value = 'في انتظار إدخال رمز التحقق';\n+      }\n     } catch (e) {\n       _handleError('فشل في تهيئة النظام', e);\n     }\n   }\n@@ -273,18 +284,60 @@\n       statusMessage.value = 'يمكنك إدخال رمز التحقق يدوياً';\n     }\n   }\n \n-  // ===================== Success Handling =====================\n+  // ===================== دوال الحماية من الطلبات المتكررة =====================\n+  \n+  /// التحقق من إمكانية إرسال طلب جديد\n+  bool _canSendNewCode() {\n+    if (_isCodeSendingInProgress) {\n+      print('⚠️ طلب إرسال رمز التحقق قيد التنفيذ بالفعل');\n+      return false;\n+    }\n+    \n+    if (_lastCodeSendTime != null) {\n+      final timeSinceLastSend = DateTime.now().difference(_lastCodeSendTime!).inMilliseconds;\n+      if (timeSinceLastSend < _minimumSendInterval) {\n+        final waitTime = _minimumSendInterval - timeSinceLastSend;\n+        print('⚠️ يجب الانتظار ${(waitTime / 1000).ceil()} ثانية قبل إرسال رمز جديد');\n+        statusMessage.value = 'يجب الانتظار ${(waitTime / 1000).ceil()} ثانية قبل إعادة الإرسال';\n+        return false;\n+      }\n+    }\n+    \n+    return true;\n+  }\n+  \n+  /// تحديث حالة إرسال الرمز\n+  void _updateCodeSendingState(bool isInProgress) {\n+    _isCodeSendingInProgress = isInProgress;\n+    if (isInProgress) {\n+      _lastCodeSendTime = DateTime.now();\n+    }\n+  }\n+  \n+  /// إعادة تعيين حالة الحماية\n+  void _resetDuplicateProtection() {\n+    _isCodeSendingInProgress = false;\n+    _lastCodeSendTime = null;\n+    _hasInitialCodeBeenSent = false;\n+  }\n \n-  // ===================== Core Verification Logic =====================\n+  // ===================== Main Controller Methods =====================\n   Future<void> sendVerificationCodeWithDiagnosis() async {\n+    // ✅ التحقق من الحماية من الطلبات المتكررة\n+    if (!_canSendNewCode()) {\n+      return;\n+    }\n+\n     if (!isNetworkConnected.value) {\n       _handleError('لا يوجد اتصال بالإنترنت', 'تحقق من الاتصال وحاول مرة أخرى');\n       return;\n     }\n \n     try {\n+      // ✅ تعيين حالة إرسال الطلب\n+      _updateCodeSendingState(true);\n       isLoading.value = true;\n       statusMessage.value = 'جاري إرسال رمز التحقق...';\n \n       final result = await _phoneAuthService.sendVerificationCode(phoneNumber);\n@@ -292,8 +345,9 @@\n       if (result.isSuccess) {\n         if (result.type == PhoneAuthResultType.codeSent) {\n           verificationId = result.verificationId;\n           statusMessage.value = 'تم إرسال رمز التحقق بنجاح';\n+          _hasInitialCodeBeenSent = true;\n         } else if (result.type == PhoneAuthResultType.autoVerified) {\n           await _handleSuccessfulVerification(result.user);\n           return;\n         }\n@@ -305,8 +359,10 @@\n       }\n     } catch (e) {\n       _handleError('فشل في إرسال رمز التحقق', e);\n     } finally {\n+      // ✅ إنهاء حالة إرسال الطلب\n+      _updateCodeSendingState(false);\n       isLoading.value = false;\n     }\n   }\n \n@@ -340,13 +396,18 @@\n     }\n   }\n \n   Future<void> resendCode() async {\n+    // ✅ التحقق من القيود والحماية من الطلبات المتكررة\n     if (!canResend.value || resendAttempts.value >= _maxResendAttempts) {\n       statusMessage.value = 'تم تجاوز الحد الأقصى لإعادة الإرسال';\n       return;\n     }\n \n+    if (!_canSendNewCode()) {\n+      return;\n+    }\n+\n     resendAttempts.value++;\n     _clearAllInputs();\n     await sendVerificationCodeWithDiagnosis();\n     _startResendTimer();\n@@ -588,8 +649,11 @@\n     _autoFillTimer?.cancel();\n     _connectivitySubscription.cancel();\n     pinController.dispose();\n \n+    // ✅ تنظيف حالة الحماية من الطلبات المتكررة\n+    _resetDuplicateProtection();\n+\n     for (var controller in codeControllers) {\n       controller.dispose();\n     }\n \n"
                },
                {
                    "date": 1753181639034,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,8 +9,9 @@\n import 'package:connectivity_plus/connectivity_plus.dart';\n import 'package:permission_handler/permission_handler.dart';\n \n import '../../../services/phone_auth_service.dart';\n+import '../../../services/firebase_phone_helper.dart';\n import '../../../../Model/model_user.dart';\n import '../../../../XXX/xxx_firebase.dart';\n import '../../../bottonBar/botonBar.dart';\n \n@@ -54,9 +55,9 @@\n   bool _hasInitialCodeBeenSent = false;\n   static const int _minimumSendInterval = 5000; // 5 ثواني\n \n   // ===================== Services & Utilities =====================\n-  late PhoneAuthService _phoneAuthService;\n+  PhoneAuthService? _phoneAuthService;\n   Timer? _resendTimer;\n   Timer? _autoFillTimer;\n   late StreamSubscription<List<ConnectivityResult>> _connectivitySubscription;\n \n@@ -107,8 +108,15 @@\n       _setupAutoFill();\n \n       statusMessage.value = 'تم إرسال رمز التحقق إلى $phoneNumber';\n \n+      // ✅ فحص جاهزية النظام قبل الإرسال\n+      final systemReady = await _checkSystemReadiness();\n+      if (!systemReady) {\n+        statusMessage.value = 'يتم تهيئة النظام...';\n+        await Future.delayed(Duration(seconds: 2));\n+      }\n+\n       // ✅ إرسال الرمز فقط إذا لم يتم إرساله من قبل\n       if (!_hasInitialCodeBeenSent) {\n         await sendVerificationCodeWithDiagnosis();\n       } else {\n@@ -119,10 +127,94 @@\n       _handleError('فشل في تهيئة النظام', e);\n     }\n   }\n \n+  /// فحص جاهزية النظام\n+  Future<bool> _checkSystemReadiness() async {\n+    try {\n+      debugPrint(\"🔍 فحص جاهزية النظام...\");\n+\n+      // 1. فحص خدمة المصادقة\n+      if (_phoneAuthService == null) {\n+        debugPrint(\"❌ خدمة المصادقة غير مهيأة\");\n+        return false;\n+      }\n+\n+      // 2. فحص الاتصال بالشبكة\n+      if (!isNetworkConnected.value) {\n+        debugPrint(\"❌ لا يوجد اتصال بالإنترنت\");\n+        return false;\n+      }\n+\n+      // 3. تشخيص Firebase\n+      final diagnosis = await FirebasePhoneHelper.comprehensiveDiagnosis();\n+      if (diagnosis.containsKey('error')) {\n+        debugPrint(\"❌ خطأ في تشخيص Firebase: ${diagnosis['error']}\");\n+        return false;\n+      }\n+\n+      // 4. فحص رقم الهاتف\n+      final phoneValidation = FirebasePhoneHelper.validatePhoneNumberAdvanced(\n+        phoneNumber,\n+      );\n+      final suggestions = phoneValidation['suggestions'] as List<String>;\n+      if (suggestions.isNotEmpty && suggestions.first != 'الرقم يبدو صحيحاً') {\n+        debugPrint(\"⚠️ مشاكل في رقم الهاتف: ${suggestions.join(', ')}\");\n+        statusMessage.value = \"تحقق من رقم الهاتف: ${suggestions.first}\";\n+        return false;\n+      }\n+\n+      debugPrint(\"✅ النظام جاهز للعمل\");\n+      return true;\n+    } catch (e) {\n+      debugPrint(\"❌ خطأ في فحص جاهزية النظام: $e\");\n+      return false;\n+    }\n+  }\n+\n   Future<void> _initializeService() async {\n-    _phoneAuthService = Get.find<PhoneAuthService>();\n+    try {\n+      // التحقق من وجود الخدمة أولاً\n+      if (!Get.isRegistered<PhoneAuthService>()) {\n+        debugPrint(\"⚠️ PhoneAuthService غير مسجلة، جاري التسجيل...\");\n+        Get.put(PhoneAuthService(), permanent: true);\n+        await Future.delayed(Duration(milliseconds: 500)); // انتظار للتهيئة\n+      }\n+\n+      _phoneAuthService = Get.find<PhoneAuthService>();\n+\n+      // التحقق من جاهزية الخدمة\n+      if (_phoneAuthService != null && !_phoneAuthService!.canMakeRequest) {\n+        debugPrint(\"⚠️ الخدمة غير جاهزة، جاري إعادة التعيين...\");\n+        _phoneAuthService!.resetRequestState();\n+      }\n+\n+      debugPrint(\"✅ تم تهيئة PhoneAuthService بنجاح في الكنترولر\");\n+\n+      // اختبار سريع للخدمة\n+      if (_phoneAuthService != null) {\n+        final report = _phoneAuthService!.getServiceReport();\n+        debugPrint(\"📊 تقرير الخدمة في الكنترولر: ${report['status']}\");\n+      }\n+    } catch (e) {\n+      debugPrint(\"❌ خطأ في تهيئة PhoneAuthService: $e\");\n+\n+      // محاولة إنشاء خدمة جديدة\n+      try {\n+        debugPrint(\"🔄 محاولة إنشاء خدمة جديدة...\");\n+        Get.delete<PhoneAuthService>(force: true);\n+        await Future.delayed(Duration(milliseconds: 200));\n+\n+        Get.put(PhoneAuthService(), permanent: true);\n+        await Future.delayed(Duration(milliseconds: 500));\n+\n+        _phoneAuthService = Get.find<PhoneAuthService>();\n+        debugPrint(\"✅ تم إنشاء وتهيئة خدمة جديدة\");\n+      } catch (retryError) {\n+        debugPrint(\"❌ فشل في إنشاء خدمة جديدة: $retryError\");\n+        throw Exception(\"فشل في تهيئة خدمة المصادقة: $retryError\");\n+      }\n+    }\n   }\n \n   void _setupNetworkMonitoring() {\n     _connectivitySubscription = Connectivity().onConnectivityChanged.listen((\n@@ -252,10 +344,14 @@\n     try {\n       isLoading.value = true;\n       statusMessage.value = 'جاري التحقق من الرمز...';\n \n-      final result = await _phoneAuthService.verifyCode(code);\n+      if (_phoneAuthService == null) {\n+        throw Exception('خدمة المصادقة غير مهيأة');\n+      }\n \n+      final result = await _phoneAuthService!.verifyCode(code);\n+\n       if (result.isSuccess) {\n         await _handleSuccessfulVerification(result.user);\n       } else {\n         _handleVerificationError(result.error ?? 'خطأ في التحقق من الرمز');\n@@ -285,85 +381,175 @@\n     }\n   }\n \n   // ===================== دوال الحماية من الطلبات المتكررة =====================\n-  \n+\n   /// التحقق من إمكانية إرسال طلب جديد\n   bool _canSendNewCode() {\n     if (_isCodeSendingInProgress) {\n       print('⚠️ طلب إرسال رمز التحقق قيد التنفيذ بالفعل');\n       return false;\n     }\n-    \n+\n     if (_lastCodeSendTime != null) {\n-      final timeSinceLastSend = DateTime.now().difference(_lastCodeSendTime!).inMilliseconds;\n+      final timeSinceLastSend =\n+          DateTime.now().difference(_lastCodeSendTime!).inMilliseconds;\n       if (timeSinceLastSend < _minimumSendInterval) {\n         final waitTime = _minimumSendInterval - timeSinceLastSend;\n-        print('⚠️ يجب الانتظار ${(waitTime / 1000).ceil()} ثانية قبل إرسال رمز جديد');\n-        statusMessage.value = 'يجب الانتظار ${(waitTime / 1000).ceil()} ثانية قبل إعادة الإرسال';\n+        print(\n+          '⚠️ يجب الانتظار ${(waitTime / 1000).ceil()} ثانية قبل إرسال رمز جديد',\n+        );\n+        statusMessage.value =\n+            'يجب الانتظار ${(waitTime / 1000).ceil()} ثانية قبل إعادة الإرسال';\n         return false;\n       }\n     }\n-    \n+\n     return true;\n   }\n-  \n+\n   /// تحديث حالة إرسال الرمز\n   void _updateCodeSendingState(bool isInProgress) {\n     _isCodeSendingInProgress = isInProgress;\n     if (isInProgress) {\n       _lastCodeSendTime = DateTime.now();\n     }\n   }\n-  \n+\n   /// إعادة تعيين حالة الحماية\n   void _resetDuplicateProtection() {\n     _isCodeSendingInProgress = false;\n     _lastCodeSendTime = null;\n     _hasInitialCodeBeenSent = false;\n   }\n \n   // ===================== Main Controller Methods =====================\n+  /// إرسال رمز التحقق مع تشخيص شامل\n   Future<void> sendVerificationCodeWithDiagnosis() async {\n-    // ✅ التحقق من الحماية من الطلبات المتكررة\n+    debugPrint(\"🔍 بدء عملية إرسال رمز التحقق إلى: $phoneNumber\");\n+\n+    // التحقق من تهيئة الخدمة أولاً\n+    if (_phoneAuthService == null) {\n+      try {\n+        await _initializeService();\n+      } catch (e) {\n+        _handleError(\"فشل في تهيئة خدمة المصادقة\", e);\n+        return;\n+      }\n+    }\n+\n+    // ✅ التحقق من الحماية من الطلبات المتكررة مع مرونة أكبر\n     if (!_canSendNewCode()) {\n-      return;\n+      // إذا كان هناك خطأ سابق، امنح فرصة جديدة\n+      if (_hasInitialCodeBeenSent && !canResend.value) {\n+        debugPrint(\"⚠️ إعطاء فرصة جديدة بعد خطأ سابق\");\n+        _hasInitialCodeBeenSent = false;\n+        _resetDuplicateProtection();\n+      } else {\n+        return;\n+      }\n     }\n \n     if (!isNetworkConnected.value) {\n       _handleError('لا يوجد اتصال بالإنترنت', 'تحقق من الاتصال وحاول مرة أخرى');\n       return;\n     }\n \n     try {\n+      // ✅ تشخيص ما قبل الإرسال مع المساعد المحسن\n+      debugPrint(\"🔍 تشخيص ما قبل الإرسال...\");\n+\n+      if (_phoneAuthService == null) {\n+        throw Exception('خدمة المصادقة غير مهيأة');\n+      }\n+\n+      // تشخيص شامل باستخدام المساعد\n+      final comprehensiveDiagnosis =\n+          await FirebasePhoneHelper.comprehensiveDiagnosis();\n+      debugPrint(\n+        \"📊 تشخيص Firebase الشامل: ${comprehensiveDiagnosis['firebase']}\",\n+      );\n+\n+      // فحص صحة رقم الهاتف المحسن\n+      final phoneValidation = FirebasePhoneHelper.validatePhoneNumberAdvanced(\n+        phoneNumber,\n+      );\n+      debugPrint(\"📞 فحص رقم الهاتف المحسن: ${phoneValidation['type']}\");\n+\n+      // طباعة نصائح إذا كان رقماً تجريبياً\n+      if (phoneValidation['type']['is_test_number'] == true) {\n+        debugPrint(\n+          \"🧪 رقم تجريبي مكتشف: ${phoneValidation['type']['test_note']}\",\n+        );\n+      }\n+\n+      // التحقق من الاقتراحات\n+      final suggestions = phoneValidation['suggestions'] as List<String>;\n+      if (suggestions.isNotEmpty && suggestions.first != 'الرقم يبدو صحيحاً') {\n+        debugPrint(\"💡 اقتراحات تحسين الرقم: ${suggestions.join(', ')}\");\n+        statusMessage.value = \"اقتراحات: ${suggestions.first}\";\n+        await Future.delayed(Duration(seconds: 2));\n+      }\n+\n+      if (phoneValidation['basic']['is_numeric_only'] != true) {\n+        final suggestions = phoneValidation['suggestions'] as List<String>;\n+        _handleError(\"رقم الهاتف غير صحيح\", suggestions.join('\\n'));\n+        return;\n+      }\n+\n       // ✅ تعيين حالة إرسال الطلب\n       _updateCodeSendingState(true);\n       isLoading.value = true;\n       statusMessage.value = 'جاري إرسال رمز التحقق...';\n+      progress.value = 0.2;\n \n-      final result = await _phoneAuthService.sendVerificationCode(phoneNumber);\n+      debugPrint(\"📤 إرسال طلب التحقق إلى Firebase...\");\n+      final result = await _phoneAuthService!.sendVerificationCode(phoneNumber);\n \n+      progress.value = 0.8;\n+\n       if (result.isSuccess) {\n         if (result.type == PhoneAuthResultType.codeSent) {\n           verificationId = result.verificationId;\n           statusMessage.value = 'تم إرسال رمز التحقق بنجاح';\n           _hasInitialCodeBeenSent = true;\n+          progress.value = 1.0;\n+\n+          debugPrint(\"✅ تم إرسال رمز التحقق بنجاح\");\n+          debugPrint(\"🔑 معرف التحقق: ${verificationId?.substring(0, 10)}...\");\n+\n+          // إزالة رسالة الخطأ إن وجدت\n+          errorMessage.value = '';\n         } else if (result.type == PhoneAuthResultType.autoVerified) {\n+          debugPrint(\"✅ تم التحقق التلقائي\");\n           await _handleSuccessfulVerification(result.user);\n           return;\n         }\n       } else {\n-        _handleError(\n-          'فشل في إرسال رمز التحقق',\n-          result.error ?? 'خطأ غير معروف',\n-        );\n+        final errorMsg = result.error ?? 'خطأ غير معروف في إرسال الرمز';\n+        debugPrint(\"❌ فشل في إرسال الرمز: $errorMsg\");\n+\n+        // إعادة تعيين الحماية في حالة الفشل لإتاحة المحاولة مرة أخرى\n+        _hasInitialCodeBeenSent = false;\n+        _resetDuplicateProtection();\n+\n+        _handleError('فشل في إرسال رمز التحقق', errorMsg);\n       }\n     } catch (e) {\n+      debugPrint(\"🚨 استثناء في إرسال رمز التحقق: $e\");\n+\n+      // إعادة تعيين الحماية في حالة الاستثناء\n+      _hasInitialCodeBeenSent = false;\n+      _resetDuplicateProtection();\n+\n       _handleError('فشل في إرسال رمز التحقق', e);\n     } finally {\n       // ✅ إنهاء حالة إرسال الطلب\n       _updateCodeSendingState(false);\n       isLoading.value = false;\n+      progress.value = 0.0;\n+\n+      debugPrint(\"🔄 تم إنهاء عملية إرسال الرمز\");\n     }\n   }\n \n   Future<void> verifyCode() async {\n@@ -381,10 +567,14 @@\n     try {\n       isLoading.value = true;\n       statusMessage.value = 'جاري التحقق من الرمز...';\n \n-      final result = await _phoneAuthService.verifyCode(code);\n+      if (_phoneAuthService == null) {\n+        throw Exception('خدمة المصادقة غير مهيأة');\n+      }\n \n+      final result = await _phoneAuthService!.verifyCode(code);\n+\n       if (result.isSuccess) {\n         await _handleSuccessfulVerification(result.user);\n       } else {\n         _handleVerificationError(result.error ?? 'خطأ في التحقق من الرمز');\n@@ -595,17 +785,27 @@\n       switch (error.code) {\n         case 'invalid-verification-code':\n           message = 'رمز التحقق غير صحيح';\n           _clearAllInputs();\n+\n+          // إضافة نصائح للأرقام التجريبية\n+          final phoneValidation =\n+              FirebasePhoneHelper.validatePhoneNumberAdvanced(phoneNumber);\n+          if (phoneValidation['type']['is_test_number'] == true) {\n+            message +=\n+                '\\n\\n💡 للأرقام التجريبية: استخدم الرمز المحدد في Firebase Console تحت \"Phone numbers for testing\"';\n+          } else {\n+            message += '\\n\\n💡 للأرقام الحقيقية: استخدم الرمز المُرسل عبر SMS';\n+          }\n           break;\n         case 'invalid-verification-id':\n-          message = 'معرف التحقق غير صالح';\n+          message = 'معرف التحقق غير صالح - قد تحتاج لطلب رمز جديد';\n           break;\n         case 'session-expired':\n-          message = 'انتهت صلاحية الجلسة، يرجى المحاولة مرة أخرى';\n+          message = 'انتهت صلاحية الجلسة، يرجى طلب رمز جديد';\n           break;\n         case 'too-many-requests':\n-          message = 'تم تجاوز الحد الأقصى للمحاولات';\n+          message = 'تم تجاوز الحد الأقصى للمحاولات - انتظر بضع دقائق';\n           break;\n         default:\n           message = error.message ?? 'خطأ غير معروف';\n       }\n@@ -613,21 +813,48 @@\n       message = error.toString();\n     }\n \n     _showError(message);\n+\n+    // إظهار حلول مقترحة\n+    final solutions = FirebasePhoneHelper.getCommonSolutions();\n+    if (message.contains('غير صحيح')) {\n+      Future.delayed(Duration(seconds: 3), () {\n+        statusMessage.value =\n+            'نصائح: ${solutions['رمز التحقق غير صحيح']?.first ?? ''}';\n+      });\n+    }\n   }\n \n   void _handleError(String title, dynamic error) {\n     final errorMsg = error.toString();\n     print('خطأ في $title: $errorMsg');\n \n-    // عرض رسالة خطأ بسيطة\n+    // الحصول على حلول مقترحة من المساعد\n+    final solutions = FirebasePhoneHelper.getCommonSolutions();\n+    String solutionText = '';\n+\n+    // البحث عن حل مناسب\n+    if (title.contains('إرسال')) {\n+      solutionText =\n+          '\\nحلول مقترحة:\\n${solutions['فشل إرسال الرمز']?.take(3).join('\\n• ') ?? ''}';\n+    } else if (errorMsg.contains('internal-error')) {\n+      solutionText =\n+          '\\nحلول مقترحة:\\n${solutions['خطأ internal-error']?.take(3).join('\\n• ') ?? ''}';\n+    } else if (errorMsg.contains('too-many-requests')) {\n+      solutionText =\n+          '\\nحلول مقترحة:\\n${solutions['الحد الأقصى للطلبات']?.take(3).join('\\n• ') ?? ''}';\n+    }\n+\n+    // عرض رسالة خطأ مع الحلول\n     Get.snackbar(\n       title,\n-      errorMsg,\n+      errorMsg + solutionText,\n       snackPosition: SnackPosition.TOP,\n       backgroundColor: Colors.red.withOpacity(0.1),\n       colorText: Colors.red,\n+      duration: Duration(seconds: 8), // مدة أطول لقراءة الحلول\n+      maxWidth: Get.width * 0.95,\n     );\n \n     statusMessage.value = title;\n   }\n"
                }
            ],
            "date": 1752751503159,
            "name": "Commit-0",
            "content": "import 'dart:async';\nimport 'dart:typed_data';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:firebase_storage/firebase_storage.dart';\nimport 'package:flutter/material.dart';\nimport 'package:get/get.dart';\n\nimport '../../../core/error_display_manager.dart';\nimport '../../../services/phone_auth_service.dart';\n\n/// تحكم متقدم لصفحة إدخال رمز التحقق\nclass CodePhoneController extends GetxController {\n  // Controllers للحقول\n  final List<TextEditingController> codeControllers = List.generate(\n    6,\n    (index) => TextEditingController(),\n  );\n\n  // FocusNodes للحقول\n  final List<FocusNode> focusNodes = List.generate(6, (index) => FocusNode());\n\n  // متغيرات التحكم\n  final RxBool isLoading = false.obs;\n  final RxBool isCodeValid = true.obs;\n  final RxBool canResend = false.obs;\n  final RxInt resendCounter = 60.obs;\n  final RxString statusMessage = ''.obs;\n  final RxDouble progress = 0.0.obs;\n\n  // خدمة المصادقة\n  late PhoneAuthService _phoneAuthService;\n\n  // Timer لإعادة الإرسال\n  Timer? _resendTimer;\n\n  // بيانات المستخدم\n  final String phoneNumber;\n  final Uint8List userImage;\n  final String name;\n  final String email;\n  final String password;\n  final bool hasPassword;\n\n  CodePhoneController({\n    required this.phoneNumber,\n    required this.userImage,\n    required this.name,\n    required this.email,\n    required this.password,\n    required this.hasPassword,\n  });\n\n  @override\n  void onInit() {\n    super.onInit();\n    _initializeService();\n    _startResendTimer();\n    _setupFocusListeners();\n\n    print('CodePhoneController initialized for $phoneNumber');\n  }\n\n  /// تهيئة خدمة المصادقة\n  void _initializeService() {\n    try {\n      if (!Get.isRegistered<PhoneAuthService>()) {\n        Get.put(PhoneAuthService());\n      }\n      _phoneAuthService = Get.find<PhoneAuthService>();\n    } catch (e) {\n      print('ERROR: Failed to initialize PhoneAuthService: $e');\n      ErrorDisplayManager.showError(\n        'فشل في تهيئة خدمة المصادقة',\n        details: e.toString(),\n      );\n    }\n  }\n\n  /// إعداد listeners للحقول\n  void _setupFocusListeners() {\n    for (int i = 0; i < focusNodes.length; i++) {\n      codeControllers[i].addListener(() {\n        if (codeControllers[i].text.length == 1) {\n          if (i < focusNodes.length - 1) {\n            focusNodes[i + 1].requestFocus();\n          } else {\n            focusNodes[i].unfocus();\n          }\n        }\n      });\n    }\n  }\n\n  /// بدء مؤقت إعادة الإرسال\n  void _startResendTimer() {\n    canResend.value = false;\n    resendCounter.value = 60;\n\n    _resendTimer = Timer.periodic(const Duration(seconds: 1), (timer) {\n      if (resendCounter.value > 0) {\n        resendCounter.value--;\n      } else {\n        canResend.value = true;\n        timer.cancel();\n        print('Resend code is now available');\n      }\n    });\n  }\n\n  /// إعادة إرسال الرمز\n  Future<void> resendCode() async {\n    if (!canResend.value) return;\n\n    try {\n      isLoading.value = true;\n      statusMessage.value = 'جارٍ إعادة إرسال الرمز...';\n\n      final result = await _phoneAuthService.sendVerificationCode(phoneNumber);\n\n      if (result.isSuccess) {\n        ErrorDisplayManager.showSuccess('تم إعادة إرسال الرمز بنجاح');\n        _startResendTimer();\n        _clearCodeFields();\n      } else {\n        ErrorDisplayManager.showError(\n          'فشل في إعادة إرسال الرمز',\n          details: result.error?.toString(),\n        );\n      }\n    } catch (e) {\n      print('ERROR in resendCode: $e');\n      ErrorDisplayManager.showError(\n        'خطأ غير متوقع أثناء إعادة الإرسال',\n        details: e.toString(),\n      );\n    } finally {\n      isLoading.value = false;\n      statusMessage.value = '';\n    }\n  }\n\n  /// التحقق من الرمز عند اكتماله\n  void checkCodeOnComplete() {\n    final code = codeControllers.map((c) => c.text).join();\n    if (code.length == 6) {\n      verifyCode(code);\n    }\n  }\n\n  /// التحقق من الرمز\n  Future<void> verifyCode(String code) async {\n    if (code.length != 6) {\n      isCodeValid.value = false;\n      ErrorDisplayManager.showError('يجب أن يكون الرمز مكون من 6 أرقام');\n      return;\n    }\n\n    try {\n      isLoading.value = true;\n      isCodeValid.value = true;\n      statusMessage.value = 'جارٍ التحقق من الرمز...';\n      progress.value = 0.2;\n\n      final result = await _phoneAuthService.verifyCode(code);\n      progress.value = 0.6;\n\n      if (result.isSuccess && result.user != null) {\n        statusMessage.value = 'تم التحقق بنجاح، جارٍ إنشاء الحساب...';\n        progress.value = 0.8;\n\n        await _completeUserRegistration(result.user!);\n        progress.value = 1.0;\n\n        ErrorDisplayManager.showSuccess('تم التحقق بنجاح!');\n\n        // الانتقال للصفحة الرئيسية\n        Get.offAllNamed('/home');\n      } else {\n        isCodeValid.value = false;\n        ErrorDisplayManager.showError(\n          'رمز التحقق غير صحيح',\n          details: result.error?.toString(),\n        );\n      }\n    } catch (e) {\n      print('ERROR in verifyCode: $e');\n      isCodeValid.value = false;\n      ErrorDisplayManager.showError(\n        'خطأ أثناء التحقق من الرمز',\n        details: e.toString(),\n      );\n    } finally {\n      isLoading.value = false;\n      statusMessage.value = '';\n      progress.value = 0.0;\n    }\n  }\n\n  /// إكمال تسجيل المستخدم\n  Future<void> _completeUserRegistration(User user) async {\n    try {\n      statusMessage.value = 'جارٍ رفع الصورة...';\n\n      final imageUrl = await _uploadUserImage(user.uid);\n\n      statusMessage.value = 'جارٍ حفظ بيانات المستخدم...';\n\n      // إنشاء نموذج بيانات المستخدم\n      final userData = {\n        'uid': user.uid,\n        'name': name,\n        'email': email,\n        'phone': phoneNumber,\n        'profileImage': imageUrl,\n        'isVerified': true,\n        'createdAt': DateTime.now().toIso8601String(),\n        'appName': 'Codora',\n      };\n\n      await FirebaseFirestore.instance\n          .collection('users') // FirebaseX.collectionApp replacement\n          .doc(user.uid)\n          .set(userData);\n\n      print('User registration completed successfully');\n    } catch (e) {\n      print('ERROR in _completeUserRegistration: $e');\n      throw Exception('فشل في إكمال تسجيل المستخدم: $e');\n    }\n  }\n\n  /// رفع صورة المستخدم\n  Future<String> _uploadUserImage(String userId) async {\n    try {\n      final storageRef = FirebaseStorage.instance\n          .ref('user_images') // FirebaseX.StorgeApp replacement\n          .child('$userId.jpg');\n\n      final uploadTask = storageRef.putData(userImage);\n\n      final snapshot = await uploadTask;\n      final downloadUrl = await snapshot.ref.getDownloadURL();\n\n      print('Image uploaded successfully: $downloadUrl');\n      return downloadUrl;\n    } catch (e) {\n      print('ERROR in _uploadUserImage: $e');\n      throw Exception('فشل في رفع الصورة: $e');\n    }\n  }\n\n  /// مسح حقول الرمز\n  void _clearCodeFields() {\n    for (var controller in codeControllers) {\n      controller.clear();\n    }\n    isCodeValid.value = true;\n    focusNodes[0].requestFocus();\n  }\n\n  @override\n  void onClose() {\n    _resendTimer?.cancel();\n\n    for (var controller in codeControllers) {\n      controller.dispose();\n    }\n\n    for (var focusNode in focusNodes) {\n      focusNode.dispose();\n    }\n\n    super.onClose();\n  }\n}\n"
        }
    ]
}