{
    "sourceFile": "lib/الكود الخاص بتطبيق العميل /theـchosen/GetXController/GetSendandtotalprice.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753157006802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753157006802,
            "name": "Commit-0",
            "content": "import 'dart:async';\nimport 'dart:ui' as ui;\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:get/get.dart';\nimport 'package:geolocator/geolocator.dart';\n\nimport '../../../XXX/xxx_firebase.dart';\nimport '../../googleMap/GoogleMapOrder.dart';\n\n/// يتحكم هذا المتحكم في إرسال الطلب وحساب الأسعار الإجمالية (كما في سياق التطبيق).\n/// يقوم باستيراد صورة من الأصول لتحويلها إلى Marker على الخريطة، ويتحقق من صلاحيات وخدمات الموقع،\n/// ثم ينتقل إلى شاشة الخريطة مع تمرير بيانات الموقع والرمز الخاص بالمستخدم.\nclass GetSendAndTotalPrice extends GetxController {\n  final String uid; // معرّف المستخدم من قاعدة البيانات\n  // حالة التحميل (يمكن متابعة التغييرات باستخدام RxBool)\n  RxBool isLoading = false.obs;\n\n  // المتغير الذي سيحمل بيانات صورة Marker بشكل Uint8List لاستخدامها على الخريطة.\n  Uint8List? markerUser;\n\n  // اشتراك في خدمة الموقع (يمكن استخدامه لاحقاً إذا أردت متابعة تحديث الموقع بشكل مستمر)\n  late StreamSubscription<Position> positionStream;\n\n  GetSendAndTotalPrice({required this.uid});\n\n  /// دالة محسنة لتحويل صورة من الأصول إلى Uint8List مع معالجة شاملة للأخطاء\n  Future<Uint8List> getBytesFromAsset(String path, int width) async {\n    try {\n      debugPrint(\"🖼️ جاري تحميل الصورة من: $path\");\n\n      // التحقق من وجود الصورة أولاً\n      ByteData? data;\n      try {\n        data = await rootBundle.load(path);\n        debugPrint(\n          \"✅ تم تحميل بيانات الصورة بنجاح، الحجم: ${data.lengthInBytes} bytes\",\n        );\n      } catch (e) {\n        debugPrint(\"❌ الصورة غير موجودة في المسار: $path\");\n        debugPrint(\"🔄 سيتم إنشاء marker افتراضي...\");\n        return await _createDefaultMarkerImage(width);\n      }\n\n      // التحقق من صحة البيانات\n      if (data.lengthInBytes == 0) {\n        debugPrint(\"❌ الصورة فارغة\");\n        return await _createDefaultMarkerImage(width);\n      }\n\n      // تحويل البيانات إلى Uint8List\n      final Uint8List imageBytes = data.buffer.asUint8List();\n\n      // التحقق من صحة تنسيق الصورة\n      if (!_isValidImageFormat(imageBytes)) {\n        debugPrint(\"❌ تنسيق الصورة غير مدعوم\");\n        return await _createDefaultMarkerImage(width);\n      }\n\n      // محاولة إنشاء Codec مع معالجة محسنة للأخطاء\n      ui.Codec? codec;\n      try {\n        codec = await ui.instantiateImageCodec(imageBytes, targetWidth: width);\n        debugPrint(\"✅ تم إنشاء codec بنجاح\");\n      } catch (codecError) {\n        debugPrint(\"❌ فشل في إنشاء codec: $codecError\");\n        return await _createDefaultMarkerImage(width);\n      }\n\n      // الحصول على الإطار الأول من الصورة\n      ui.FrameInfo? frameInfo;\n      try {\n        frameInfo = await codec.getNextFrame();\n        debugPrint(\"✅ تم الحصول على frame بنجاح\");\n      } catch (frameError) {\n        debugPrint(\"❌ فشل في الحصول على frame: $frameError\");\n        codec.dispose();\n        return await _createDefaultMarkerImage(width);\n      }\n\n      // تحويل الصورة إلى ByteData\n      ByteData? byteData;\n      try {\n        byteData = await frameInfo.image.toByteData(\n          format: ui.ImageByteFormat.png,\n        );\n        debugPrint(\"✅ تم تحويل الصورة إلى ByteData بنجاح\");\n      } catch (conversionError) {\n        debugPrint(\"❌ فشل في تحويل الصورة: $conversionError\");\n        frameInfo.image.dispose();\n        codec.dispose();\n        return await _createDefaultMarkerImage(width);\n      }\n\n      if (byteData == null) {\n        debugPrint(\"❌ فشل في تحويل الصورة إلى ByteData\");\n        frameInfo.image.dispose();\n        codec.dispose();\n        return await _createDefaultMarkerImage(width);\n      }\n\n      final Uint8List result = byteData.buffer.asUint8List();\n      debugPrint(\n        \"✅ تم تحويل الصورة بنجاح، الحجم النهائي: ${result.length} bytes\",\n      );\n\n      // تنظيف الذاكرة\n      frameInfo.image.dispose();\n      codec.dispose();\n\n      return result;\n    } catch (e, stackTrace) {\n      debugPrint(\"❌ خطأ عام في تحميل الصورة من $path: $e\");\n      debugPrint(\"📍 Stack trace: $stackTrace\");\n      return await _createDefaultMarkerImage(width);\n    }\n  }\n\n  /// التحقق من صحة تنسيق الصورة\n  bool _isValidImageFormat(Uint8List bytes) {\n    if (bytes.length < 4) return false;\n\n    // فحص PNG signature\n    if (bytes[0] == 0x89 &&\n        bytes[1] == 0x50 &&\n        bytes[2] == 0x4E &&\n        bytes[3] == 0x47) {\n      debugPrint(\"✅ تم التعرف على تنسيق PNG\");\n      return true;\n    }\n\n    // فحص JPEG signature\n    if (bytes[0] == 0xFF && bytes[1] == 0xD8) {\n      debugPrint(\"✅ تم التعرف على تنسيق JPEG\");\n      return true;\n    }\n\n    // فحص WebP signature\n    if (bytes.length >= 12 &&\n        bytes[0] == 0x52 &&\n        bytes[1] == 0x49 &&\n        bytes[2] == 0x46 &&\n        bytes[3] == 0x46 &&\n        bytes[8] == 0x57 &&\n        bytes[9] == 0x45 &&\n        bytes[10] == 0x42 &&\n        bytes[11] == 0x50) {\n      debugPrint(\"✅ تم التعرف على تنسيق WebP\");\n      return true;\n    }\n\n    debugPrint(\"❌ تنسيق صورة غير مدعوم\");\n    return false;\n  }\n\n  /// إنشاء صورة marker افتراضية في حالة فشل تحميل الصورة الأصلية\n  Future<Uint8List> _createDefaultMarkerImage(int size) async {\n    try {\n      debugPrint(\"🔄 إنشاء صورة marker افتراضية...\");\n\n      // إنشاء مسطح رسم\n      final ui.PictureRecorder recorder = ui.PictureRecorder();\n      final Canvas canvas = Canvas(recorder);\n\n      // رسم خلفية بيضاء\n      final Paint backgroundPaint =\n          Paint()\n            ..color = Colors.white\n            ..style = PaintingStyle.fill;\n      canvas.drawRect(\n        Rect.fromLTWH(0, 0, size.toDouble(), size.toDouble()),\n        backgroundPaint,\n      );\n\n      // رسم دائرة ملونة كـ marker\n      final Paint circlePaint =\n          Paint()\n            ..color = const Color(0xFF667EEA)\n            ..style = PaintingStyle.fill;\n\n      canvas.drawCircle(Offset(size / 2, size / 2), size / 3, circlePaint);\n\n      // رسم نقطة بيضاء في المنتصف\n      final Paint centerPaint =\n          Paint()\n            ..color = Colors.white\n            ..style = PaintingStyle.fill;\n\n      canvas.drawCircle(Offset(size / 2, size / 2), size / 6, centerPaint);\n\n      // رسم حدود\n      final Paint borderPaint =\n          Paint()\n            ..color = Colors.grey.shade300\n            ..style = PaintingStyle.stroke\n            ..strokeWidth = 1.0;\n\n      canvas.drawCircle(Offset(size / 2, size / 2), size / 3, borderPaint);\n\n      // تحويل الرسم إلى صورة\n      final ui.Picture picture = recorder.endRecording();\n      final ui.Image image = await picture.toImage(size, size);\n      final ByteData? byteData = await image.toByteData(\n        format: ui.ImageByteFormat.png,\n      );\n\n      // تنظيف الذاكرة\n      picture.dispose();\n      image.dispose();\n\n      if (byteData != null) {\n        debugPrint(\"✅ تم إنشاء الصورة الافتراضية بنجاح\");\n        return byteData.buffer.asUint8List();\n      } else {\n        throw Exception(\"فشل في إنشاء الصورة الافتراضية\");\n      }\n    } catch (e) {\n      debugPrint(\"❌ خطأ في إنشاء الصورة الافتراضية: $e\");\n\n      // إرجاع أبسط marker ممكن - صورة PNG بسيطة مكتوبة يدوياً\n      return _createMinimalMarker();\n    }\n  }\n\n  /// إنشاء أبسط marker ممكن كـ fallback نهائي\n  Uint8List _createMinimalMarker() {\n    // PNG صغير أحمر بسيط (16x16 pixels) - مُولّد يدوياً\n    return Uint8List.fromList([\n      0x89,\n      0x50,\n      0x4E,\n      0x47,\n      0x0D,\n      0x0A,\n      0x1A,\n      0x0A,\n      0x00,\n      0x00,\n      0x00,\n      0x0D,\n      0x49,\n      0x48,\n      0x44,\n      0x52,\n      0x00,\n      0x00,\n      0x00,\n      0x10,\n      0x00,\n      0x00,\n      0x00,\n      0x10,\n      0x08,\n      0x02,\n      0x00,\n      0x00,\n      0x00,\n      0x90,\n      0x91,\n      0x68,\n      0x36,\n      0x00,\n      0x00,\n      0x00,\n      0x3C,\n      0x49,\n      0x44,\n      0x41,\n      0x54,\n      0x28,\n      0xCF,\n      0x63,\n      0xF8,\n      0x0F,\n      0x00,\n      0x01,\n      0x01,\n      0x01,\n      0x00,\n      0x18,\n      0xDD,\n      0x8D,\n      0xB4,\n      0x1C,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x49,\n      0x45,\n      0x4E,\n      0x44,\n      0xAE,\n      0x42,\n      0x60,\n      0x82,\n    ]);\n  }\n\n  /// دالة placeholder (قيد التطوير) لمعالجة منطق عرض أيقونة (marker) على الخريطة.\n  Future<void> iconMarket() async {\n    // TODO: تنفيذ منطق تحديد وعرض Marker على الخريطة إذا تطلب الأمر.\n  }\n\n  /// دالة إرسال الطلب:\n  /// - تتحقق أولاً من وجود منتجات في السلة.\n  /// - تقوم بتحميل صورة الماركر (Marker) من الأصول.\n  /// - تتحقق من تفعيل خدمة الموقع وصلاحياته.\n  /// - تحصل على الموقع الحالي للمستخدم.\n  /// - تحصل على رمز المستخدم (token) من Firestore.\n  /// - تنتقل إلى شاشة GoogleMapOrder مع تمرير الإحداثيات، الماركر، ورمز المستخدم.\n  Future<void> send() async {\n    try {\n      // بدء حالة التحميل\n      isLoading.value = true;\n      update();\n\n      // تحميل الماركر من الأصول (يستخدم ImageX.ImageHome من إعدادات المشروع)\n      markerUser = await getBytesFromAsset(ImageX.ImageHome, 60);\n      update();\n\n      // جلب بيانات السلة من Firestore (the-chosen)\n      QuerySnapshot chosenSnapshot =\n          await FirebaseFirestore.instance\n              .collection('the-chosen')\n              .doc(FirebaseAuth.instance.currentUser!.uid)\n              .collection(FirebaseX.appName)\n              .get();\n\n      // التأكد من وجود عناصر في السلة\n      if (chosenSnapshot.docs.isNotEmpty) {\n        double? longitude;\n        double? latitude;\n\n        // التحقق من تفعيل خدمة الموقع على الجهاز\n        bool serviceEnabled = await Geolocator.isLocationServiceEnabled();\n        if (!serviceEnabled) {\n          // عرض رسالة تنبيه إذا كانت خدمة الموقع غير مفعلة\n          Get.defaultDialog(\n            title: 'خدمة الموقع',\n            middleText: 'الرجاء تفعيل خدمة الموقع',\n            textCancel: 'رجوع',\n          );\n          isLoading.value = false;\n          update();\n          return;\n        }\n\n        // التحقق من أذونات الموقع\n        LocationPermission permission = await Geolocator.checkPermission();\n        if (permission == LocationPermission.denied) {\n          permission = await Geolocator.requestPermission();\n          if (permission == LocationPermission.denied) {\n            Get.defaultDialog(\n              title: 'أذونات الموقع',\n              middleText: 'تم رفض أذونات الموقع',\n              textCancel: 'رجوع',\n            );\n            isLoading.value = false;\n            update();\n            return;\n          }\n        }\n        if (permission == LocationPermission.deniedForever) {\n          Get.defaultDialog(\n            title: 'أذونات الموقع',\n            middleText:\n                'تم رفض أذونات الموقع بشكل دائم. يرجى التحقق من الإعدادات.',\n            textCancel: 'رجوع',\n          );\n          isLoading.value = false;\n          update();\n          return;\n        }\n\n        // جلب رمز المستخدم (token) من مجموعة التطبيق في Firestore\n        DocumentSnapshot tokenSnapshot =\n            await FirebaseFirestore.instance\n                .collection(FirebaseX.collectionApp)\n                .doc(uid)\n                .get();\n\n        // الحصول على الموقع الحالي للمستخدم\n        Position position = await Geolocator.getCurrentPosition();\n        latitude = position.latitude;\n        longitude = position.longitude;\n        update();\n\n        // الانتقال إلى شاشة الخريطة مع تمرير البيانات المطلوبة:\n        // - الإحداثيات: latitude و longitude\n        // - صورة الماركر للمستخدم\n        // - رمز المستخدم (token)\n        Get.to(\n          () => GoogleMapOrder(\n            initialLongitude: longitude!,\n            initialLatitude: latitude!,\n            markerIconBytes: markerUser!,\n            tokenUser: tokenSnapshot.get('token'),\n          ),\n        );\n      } else {\n        // إذا كانت السلة فارغة (أي لم يتم اختيار أي منتج)، يتم عرض رسالة للمستخدم.\n        Get.defaultDialog(\n          title: \"تنبيه\",\n          titleStyle: TextStyle(\n            fontWeight: FontWeight.bold,\n            fontSize: 20,\n            color: Colors.redAccent,\n          ),\n          middleText: \"يرجى اختيار منتج من القائمة أولاً.\",\n          middleTextStyle: TextStyle(fontSize: 16, color: Colors.black87),\n          textCancel: \"رجوع\",\n          cancelTextColor: Colors.black54,\n          barrierDismissible: false,\n          radius: 12,\n          backgroundColor: Colors.white,\n          buttonColor: Colors.redAccent,\n          // يمكنك إضافة callback عند الضغط على زر الرجوع إذا رغبت\n          onCancel: () {\n            // تنفيذ أي إجراء عند إلغاء عملية التنبيه\n          },\n          // يمكن أيضاً إضافة أيقونة أو عناصر إضافية إذا رغبت:\n          // titlePadding: EdgeInsets.only(top: 16, bottom: 8),\n          // contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n        );\n      }\n    } catch (e) {\n      // التقاط أي أخطاء تحدث أثناء عملية الإرسال وعرض رسالة تنبيه للمستخدم\n      Get.snackbar(\n        'حدث خطأ',\n        'تعذر إرسال الطلب. يرجى التأكد من اتصالك بالإنترنت وحاول مرة أخرى.\\nتفاصيل الخطأ: $e',\n        icon: const Icon(Icons.error_outline, color: Colors.white),\n        backgroundColor: Colors.red.shade700,\n        colorText: Colors.white,\n        snackPosition: SnackPosition.BOTTOM,\n        margin: const EdgeInsets.all(16),\n        borderRadius: 10,\n        duration: const Duration(seconds: 4),\n      );\n    } finally {\n      // إعادة تعيين حالة التحميل وتحديث الواجهة\n      isLoading.value = false;\n      update();\n    }\n  }\n}\n"
        }
    ]
}